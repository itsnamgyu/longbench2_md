# binning.cpp

//************************************************************************
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<binning.h>

Binning::Binning(System* s):system(s) {}

void Binning::create_binning(T_X_FLOAT dx, T_X_FLOAT dy, T_X_FLOAT dz, int halo_depth, bool do_local, bool do_ghost, bool sort) {}
const char* Binning::name() { return "BinningNone"; }



---

# binning.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef BINNING_H
#define BINNING_H
#include <types.h>
#include <system.h>
class Binning {
protected:
  System* system;


public: 

  T_INT nbinx, nbiny, nbinz, nhalo;
  T_X_FLOAT minx,maxx,miny,maxy,minz,maxz;

  typedef Kokkos::View<int***> t_bincount;
  typedef Kokkos::View<T_INT***> t_binoffsets;
  typedef Kokkos::View<T_INT*> t_permute_vector;

  t_bincount bincount;
  t_binoffsets binoffsets;
  t_permute_vector permute_vector;

  bool is_sorted;

  Binning(System* s);
  
  virtual void create_binning(T_X_FLOAT dx, T_X_FLOAT dy, T_X_FLOAT dz, int halo_depth, bool do_local, bool do_ghost, bool sort);
  virtual const char* name();
};

#include<modules_binning.h>

#endif


---

# CMakeLists.txt

set(HEADERS
  binning.h
  comm.h
  examinimd.h
  force.h
  input.h
  integrator.h
  integrator_nve.h
  math_extra.h
  modules_binning.h
  modules_comm.h
  modules_force.h
  modules_integrator.h
  modules_neighbor.h
  modules_property.h
  neighbor.h
  property_kine.h
  property_pote.h
  property_temperature.h
  system.h
  types.h)

set(SOURCES
  binning.cpp
  comm.cpp
  examinimd.cpp
  force.cpp
  input.cpp
  integrator.cpp
  integrator_nve.cpp
  neighbor.cpp
  property_kine.cpp
  property_pote.cpp
  property_temperature.cpp
  system.cpp)

add_executable(ExaMiniMD main.cpp ${SOURCES} ${HEADERS})

set(SUBDIRECTORIES
  binning_types
  comm_types
  force_types
  neighbor_types)

foreach(SUBDIR ${SUBDIRECTORIES})
  add_subdirectory(${SUBDIR})
endforeach()

if (USE_CUDA)
  set_target_properties(ExaMiniMD PROPERTIES LANGUAGE CUDA)
endif()

if (USE_MPI)
  target_compile_definitions(ExaMiniMD PRIVATE EXAMINIMD_ENABLE_MPI)
endif()

target_include_directories(ExaMiniMD PRIVATE ${Kokkos_DIR} ${CMAKE_CURRENT_SOURCE_DIR} ${SUBDIRECTORIES})
target_link_libraries(ExaMiniMD PRIVATE $<$<BOOL:${USE_MPI}>:MPI::MPI_CXX> Kokkos::kokkos)

install(TARGETS ExaMiniMD DESTINATION ${CMAKE_INSTALL_BINDIR})


---

# comm.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<comm.h>
Comm::Comm(System* s, T_X_FLOAT comm_depth_):system(s),comm_depth(comm_depth_) {}
Comm::~Comm() {}
void Comm::init() {};
void Comm::exchange() {};
void Comm::exchange_halo() {};
void Comm::update_halo() {};
void Comm::update_force() {};
void Comm::reduce_float(T_FLOAT*, T_INT) {};
void Comm::reduce_int(T_INT*, T_INT) {};
void Comm::reduce_max_float(T_FLOAT*, T_INT) {};
void Comm::reduce_max_int(T_INT*, T_INT) {};
void Comm::reduce_min_float(T_FLOAT*, T_INT) {};
void Comm::reduce_min_int(T_INT*, T_INT) {};
void Comm::scan_int(T_INT*, T_INT) {};
void Comm::weighted_reduce_float(T_FLOAT* , T_INT* , T_INT ) {};
void Comm::create_domain_decomposition() {
  system->sub_domain_lo_x = 0.0;
  system->sub_domain_lo_y = 0.0;
  system->sub_domain_lo_z = 0.0;
  system->sub_domain_x = system->sub_domain_hi_x = system->domain_x;
  system->sub_domain_y = system->sub_domain_hi_y = system->domain_y;
  system->sub_domain_z = system->sub_domain_hi_z = system->domain_z;
};
int Comm::process_rank() {return 0;}
int Comm::num_processes() {return 1;}
void Comm::error(const char *errormsg) {
  printf("%s\n",errormsg);
  exit(1);
};
const char* Comm::name() {return "InvalidComm";}



---

# comm.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#if !defined(MODULES_OPTION_CHECK) && !defined(MODULES_INSTANTIATION)

#ifndef COMM_H
#define COMM_H
#include <types.h>
#include <system.h>
#include <binning.h>

class Comm {

protected:
  System* system;

  T_X_FLOAT comm_depth;

public:
  Comm(System* s, T_X_FLOAT comm_depth);
  virtual ~Comm();
  virtual void init();

  // Move particles which left local domain
  virtual void exchange();

  // Exchange ghost particles
  virtual void exchange_halo();

  // Update ghost particles
  virtual void update_halo();

  // Reverse communication of forces
  virtual void update_force();

  // Do a sum reduction over floats
  virtual void reduce_float(T_FLOAT* values, T_INT N);

  // Do a sum reduction over integers
  virtual void reduce_int(T_INT* values, T_INT N);

  // Do a max reduction over floats
  virtual void reduce_max_float(T_FLOAT* values, T_INT N);

  // Do a max reduction over integers
  virtual void reduce_max_int(T_INT* values, T_INT N);

  // Do a min reduction over floats
  virtual void reduce_min_float(T_FLOAT* values, T_INT N);

  // Do a min reduction over integers
  virtual void reduce_min_int(T_INT* values, T_INT N);

  // Do an inclusive scan over integers
  virtual void scan_int(T_INT* values, T_INT N);

  // Do a sum reduction over floats with weights
  virtual void weighted_reduce_float(T_FLOAT* values, T_INT* weight, T_INT N);

  // Create a processor grid
  virtual void create_domain_decomposition();

  // Get Processor rank
  virtual int process_rank();

  // Get number of processors
  virtual int num_processes();

  // Exit with error message
  virtual void error(const char *);

  // Get class name
  virtual const char* name();
};


#include<modules_comm.h>

#endif
#endif



---

# examinimd.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <examinimd.h>
#include <property_temperature.h>
#include <property_kine.h>
#include <property_pote.h>
#include <iostream>

#define MAXPATHLEN 1024

ExaMiniMD::ExaMiniMD() {
  // First we need to create the System data structures
  // They are used by input
  system = new System();
  system->init();

  // Create the Input System, no modules for that,
  // so we can init it in constructor
  input = new Input(system);

  neighbor = NULL;
}

void ExaMiniMD::init(int argc, char* argv[]) {

  if(system->do_print)
    Kokkos::DefaultExecutionSpace{}.print_configuration(std::cout);

  // Lets parse the command line arguments
  input->read_command_line_args(argc,argv);

  // Read input file
  input->read_file();

  // Now we know which integrator type to use
  if(input->integrator_type == INTEGRATOR_NVE)
    integrator = new IntegratorNVE(system);

  // Fill some binning
  if(input->binning_type == BINNING_KKSORT)
    binning = new BinningKKSort(system);

  // Create Force Type
  if(false) {}
#define FORCE_MODULES_INSTANTIATION
#include<modules_force.h>
#undef FORCE_MODULES_INSTANTIATION
  else comm->error("Invalid ForceType");
  for(int line = 0; line < input->force_coeff_lines.extent(0); line++) {
    //input->input_data.print_line(input->force_coeff_lines(line));
    //printf("init_coeff: %i %i\n",line,input->input_data.words_in_line(input->force_coeff_lines(line)));
    force->init_coeff(input->input_data.words_in_line(input->force_coeff_lines(line)),
                      input->input_data.words[input->force_coeff_lines(line)]);
  }

  // Create Neighbor Instance
  if (false) {}
#define NEIGHBOR_MODULES_INSTANTIATION
#include<modules_neighbor.h>
#undef NEIGHBOR_MODULES_INSTANTIATION
  else comm->error("Invalid NeighborType");

  // Create Communication Submodule
  if (false) {}
#define COMM_MODULES_INSTANTIATION
#include<modules_comm.h>
#undef COMM_MODULES_INSTANTIATION
  else comm->error("Invalid CommType");

  // Do some additional settings
  force->comm_newton = input->comm_newton;
  if(neighbor)
    neighbor->comm_newton = input->comm_newton;

  // system->print_particles();
  if(system->do_print) {
    printf("Using: %s %s %s %s\n",force->name(),neighbor->name(),comm->name(),binning->name());
  }

  // Ok lets go ahead and create the particles if that didn't happen yet
  if(system->N == 0)
    input->create_lattice(comm);

  // Create the Halo
  comm->exchange();

  // Sort particles
  T_F_FLOAT neigh_cutoff = input->force_cutoff + input->neighbor_skin;
  binning->create_binning(neigh_cutoff,neigh_cutoff,neigh_cutoff,1,true,false,true);

  // Set up particles
  comm->exchange_halo();

  // Create binning for neighborlist construction
  binning->create_binning(neigh_cutoff,neigh_cutoff,neigh_cutoff,1,true,true,false);

  // Compute NeighList
  if(neighbor)
    neighbor->create_neigh_list(system,binning,force->half_neigh,false);

  // Compute initial forces
  Kokkos::deep_copy(system->f,0.0);
  force->compute(system,binning,neighbor);

  if(input->comm_newton) {
    // Reverse Communicate Force Update on Halo
    comm->update_force();
  }

  // Initial output
  int step = 0;
  if(input->thermo_rate > 0) {
    Temperature temp(comm);
    PotE pote(comm);
    KinE kine(comm);
    T_FLOAT T = temp.compute(system);
    T_FLOAT PE = pote.compute(system,binning,neighbor,force)/system->N;
    T_FLOAT KE = kine.compute(system)/system->N;
    if(system->do_print) {
      if (!system->print_lammps) {
        printf("\n");
        printf("#Timestep Temperature PotE ETot Time Atomsteps/s\n");
        printf("%i %lf %lf %lf %lf %e\n",step,T,PE,PE+KE,0.0,0.0);
      } else {
        printf("\n");
        printf("Step Temp E_pair TotEng CPU\n");
        printf("     %i %lf %lf %lf %lf\n",step,T,PE,PE+KE,0.0);
      }
    }
  }

  if(input->dumpbinaryflag)
    dump_binary(step);

  if(input->correctnessflag)
    check_correctness(step);

}

void ExaMiniMD::run(int nsteps) {
  T_F_FLOAT neigh_cutoff = input->force_cutoff + input->neighbor_skin;

  Temperature temp(comm);
  PotE pote(comm);
  KinE kine(comm);

  double force_time = 0;
  double comm_time  = 0;
  double neigh_time = 0;
  double other_time = 0;

  double last_time;
  Kokkos::Timer timer,force_timer,comm_timer,neigh_timer,other_timer;

  // Timestep Loop
  for(int step = 1; step <= nsteps; step++ ) {

    // Do first part of the verlet time step integration
    other_timer.reset();
    integrator->initial_integrate();
    other_time += other_timer.seconds();

    if(step%input->comm_exchange_rate==0 && step >0) {
      // Exchange particles
      comm_timer.reset();
      comm->exchange();
      comm_time += comm_timer.seconds();

      // Sort particles
      other_timer.reset();
      binning->create_binning(neigh_cutoff,neigh_cutoff,neigh_cutoff,1,true,false,true);
      other_time += other_timer.seconds();

      // Exchange Halo
      comm_timer.reset();
      comm->exchange_halo();
      comm_time += comm_timer.seconds();

      // Create binning for neighborlist construction
      neigh_timer.reset();
      binning->create_binning(neigh_cutoff,neigh_cutoff,neigh_cutoff,1,true,true,false);

      // Compute Neighbor List if necessary
      if(neighbor)
        neighbor->create_neigh_list(system,binning,force->half_neigh,false);
      neigh_time += neigh_timer.seconds();
    } else {
      // Exchange Halo
      comm_timer.reset();
      comm->update_halo();
      comm_time += comm_timer.seconds();
    }

    // Zero out forces
    force_timer.reset();
    Kokkos::deep_copy(system->f,0.0);

    // Compute Short Range Force
    force->compute(system,binning,neighbor);
    force_time += force_timer.seconds();

    // This is where Bonds, Angles and KSpace should go eventually

    // Reverse Communicate Force Update on Halo
    if(input->comm_newton) {
      comm_timer.reset();
      comm->update_force();
      comm_time += comm_timer.seconds();
    }

    // Do second part of the verlet time step integration
    other_timer.reset();
    integrator->final_integrate();

    // On output steps print output
    if(step%input->thermo_rate==0) {
      T_FLOAT T = temp.compute(system);
      T_FLOAT PE = pote.compute(system,binning,neighbor,force)/system->N;
      T_FLOAT KE = kine.compute(system)/system->N;
      if(system->do_print) {
        if (!system->print_lammps) {
          double time = timer.seconds();
          printf("%i %lf %lf %lf %lf %e\n",step, T, PE, PE+KE, timer.seconds(),1.0*system->N*input->thermo_rate/(time-last_time));
          last_time = time;
        } else {
          double time = timer.seconds();
          printf("     %i %lf %lf %lf %lf\n",step, T, PE, PE+KE, timer.seconds());
          last_time = time;
        }
      }
    }

    if(input->dumpbinaryflag)
      dump_binary(step);

    if(input->correctnessflag)
      check_correctness(step);

    other_time += other_timer.seconds();
  }

  double time = timer.seconds();
  T_FLOAT T = temp.compute(system);
  T_FLOAT PE = pote.compute(system,binning,neighbor,force)/system->N;
  T_FLOAT KE = kine.compute(system)/system->N;

  if(system->do_print) {
    if (!system->print_lammps) {
      printf("\n");
      printf("#Procs Particles | Time T_Force T_Neigh T_Comm T_Other | Steps/s Atomsteps/s Atomsteps/(proc*s)\n");
      printf("%i %i | %lf %lf %lf %lf %lf | %lf %e %e PERFORMANCE\n",comm->num_processes(),system->N,time,
        force_time,neigh_time,comm_time,other_time,
        1.0*nsteps/time,1.0*system->N*nsteps/time,1.0*system->N*nsteps/time/comm->num_processes());
    } else {
      printf("Loop time of %f on %i procs for %i steps with %i atoms\n",time,comm->num_processes(),nsteps,system->N);
    }
  }
}

void ExaMiniMD::dump_binary(int step) {

  // On dump steps print configuration

  if(step%input->dumpbinary_rate) return;

  FILE* fp;
  T_INT n = system->N_local;

  char* filename = new char[MAXPATHLEN];
  sprintf(filename,"%s%s.%010d.%03d",input->dumpbinary_path,
          "/output",step,comm->process_rank());
  fp = fopen(filename,"wb");
  if (fp == NULL) {
    char str[MAXPATHLEN];
    sprintf(str,"Cannot open dump file %s",filename);
    comm->error(str);
  }

  System s = *system;
  t_id::HostMirror h_id = Kokkos::create_mirror_view(s.id);
  t_type::HostMirror h_type = Kokkos::create_mirror_view(s.type);
  t_q::HostMirror h_q = Kokkos::create_mirror_view(s.q);
  t_x::HostMirror h_x = Kokkos::create_mirror_view(s.x);
  t_v::HostMirror h_v = Kokkos::create_mirror_view(s.v);
  t_f::HostMirror h_f = Kokkos::create_mirror_view(s.f);
  Kokkos::deep_copy(h_id,s.id);
  Kokkos::deep_copy(h_type,s.type);
  Kokkos::deep_copy(h_q,s.q);
  Kokkos::deep_copy(h_x,s.x);
  Kokkos::deep_copy(h_v,s.v);
  Kokkos::deep_copy(h_f,s.f);

  // ensure correct transpose for multi-arrays
  Kokkos::View<T_X_FLOAT*[3],Kokkos::LayoutRight> o_x("dump_binary::x",s.x.extent(0));
  Kokkos::View<T_V_FLOAT*[3],Kokkos::LayoutRight> o_v("dump_binary::v",s.v.extent(0));
  Kokkos::View<T_F_FLOAT*[3],Kokkos::LayoutRight> o_f("dump_binary::f",s.f.extent(0));
  Kokkos::deep_copy(o_x,h_x);
  Kokkos::deep_copy(o_v,h_v);
  Kokkos::deep_copy(o_f,h_f);

  fwrite(&n,sizeof(T_INT),1,fp);
  fwrite(h_id.data(),sizeof(T_INT),n,fp);
  fwrite(h_type.data(),sizeof(T_INT),n,fp);
  fwrite(h_q.data(),sizeof(T_FLOAT),n,fp);
  fwrite(o_x.data(),sizeof(T_X_FLOAT),3*n,fp);
  fwrite(o_v.data(),sizeof(T_V_FLOAT),3*n,fp);
  fwrite(o_f.data(),sizeof(T_F_FLOAT),3*n,fp);

  fclose(fp);
}

// TODO: 1. Add path to Reference [DONE]
//       2. Add MPI Rank file ids in Reference [DONE]
//       3. Move to separate class
//       4. Add pressure to thermo output
//       5. basis_offset [DONE]
//       6. correctness output to file [DONE]

void ExaMiniMD::check_correctness(int step) {

  if(step%input->correctness_rate) return;

  FILE* fpref;
  T_INT n = system->N_local;
  T_INT ntmp;

  char* filename = new char[MAXPATHLEN];
  sprintf(filename,"%s%s.%010d.%03d",input->reference_path,
          "/output",step,comm->process_rank());
  fpref = fopen(filename,"rb");
  if (fpref == NULL) {
    char str[MAXPATHLEN];
    sprintf(str,"Cannot open input file %s",filename);
    comm->error(str);
  }

  fread(&ntmp,sizeof(T_INT),1,fpref);
  if (ntmp != n)
    comm->error("Mismatch in current and reference atom counts");

  t_id idref = t_id("Correctness::id",n);
  t_type typeref = t_type("Correctness::type",n);
  t_q qref = t_q("Correctness::q",n);
  t_x xref = t_x("Correctness::x",n);
  t_v vref = t_v("Correctness::v",n);
  t_f fref = t_f("Correctness::f",n);

  fread(idref.data(),sizeof(T_INT),n,fpref);
  fread(typeref.data(),sizeof(T_INT),n,fpref);
  fread(qref.data(),sizeof(T_FLOAT),n,fpref);
  fread(xref.data(),sizeof(T_X_FLOAT),3*n,fpref);
  fread(vref.data(),sizeof(T_V_FLOAT),3*n,fpref);
  fread(fref.data(),sizeof(T_F_FLOAT),3*n,fpref);

  T_FLOAT sumdelrsq = 0.0;
  T_FLOAT sumdelvsq = 0.0;
  T_FLOAT sumdelfsq = 0.0;
  T_FLOAT maxdelr = 0.0;
  T_FLOAT maxdelv = 0.0;
  T_FLOAT maxdelf = 0.0;
  for (int i = 0; i < n; i++) {
    int ii = -1;
    if (system->id(i) != idref(i))
      for (int j = 0; j < n; j++) {
        if (system->id(j) == idref(i)) {
          ii = j;
          break;
        }
      }
    else
      ii = i;

    if (ii == -1)
      printf("Unable to find current id matchinf reference id %d \n",idref(i));
    else {
      T_FLOAT delx, dely, delz, delrsq;
      delx = system->x(ii,0)-xref(i,0);
      dely = system->x(ii,1)-xref(i,1);
      delz = system->x(ii,2)-xref(i,2);
      delrsq = delx*delx + dely*dely + delz*delz;
      sumdelrsq += delrsq;
      maxdelr = MAX(fabs(delx),maxdelr);
      maxdelr = MAX(fabs(dely),maxdelr);
      maxdelr = MAX(fabs(delz),maxdelr);

      delx = system->v(ii,0)-vref(i,0);
      dely = system->v(ii,1)-vref(i,1);
      delz = system->v(ii,2)-vref(i,2);
      delrsq = delx*delx + dely*dely + delz*delz;
      sumdelvsq += delrsq;
      maxdelv = MAX(fabs(delx),maxdelv);
      maxdelv = MAX(fabs(dely),maxdelv);
      maxdelv = MAX(fabs(delz),maxdelv);

      delx = system->f(ii,0)-fref(i,0);
      dely = system->f(ii,1)-fref(i,1);
      delz = system->f(ii,2)-fref(i,2);
      delrsq = delx*delx + dely*dely + delz*delz;
      sumdelfsq += delrsq;
      maxdelf = MAX(fabs(delx),maxdelf);
      maxdelf = MAX(fabs(dely),maxdelf);
      maxdelf = MAX(fabs(delz),maxdelf);
    }
  }

  fclose(fpref);

  // Can't use this with current CommMPI::reduce_float()
  // T_FLOAT buf[3];
  // buf[0] = sumdelrsq;
  // buf[1] = sumdelvsq;
  // buf[2] = sumdelfsq;
  // comm->reduce_float(&buf[0],3);
  // sumdelrsq = buf[0];
  // sumdelrsq = buf[1];
  // sumdelrsq = buf[2];
  // buf[0] = maxdelr;
  // buf[1] = maxdelv;
  // buf[2] = maxdelf;
  // comm->reduce_max_float(buf,3);
  // maxdelr =   buf[0];
  // maxdelv =   buf[1];
  // maxdelf =   buf[2];

  comm->reduce_float(&sumdelrsq,1);
  comm->reduce_float(&sumdelvsq,1);
  comm->reduce_float(&sumdelfsq,1);
  comm->reduce_max_float(&maxdelr,1);
  comm->reduce_max_float(&maxdelv,1);
  comm->reduce_max_float(&maxdelf,1);

  if (system->do_print) {
    if (step == 0) {
      FILE* fpout = fopen(input->correctness_file,"w");
      fprintf(fpout, "# timestep deltarnorm maxdelr deltavnorm maxdelv deltafnorm maxdelf\n");
      fprintf(fpout, "%d %g %g %g %g %g %g\n",step,sqrt(sumdelrsq),maxdelr,sqrt(sumdelvsq),
              maxdelv,sqrt(sumdelfsq),maxdelf);
      fclose(fpout);
    } else {
      FILE* fpout = fopen(input->correctness_file,"a");
      fprintf(fpout, "%d %g %g %g %g %g %g\n",step,sqrt(sumdelrsq),maxdelr,sqrt(sumdelvsq),
              maxdelv,sqrt(sumdelfsq),maxdelf);
      fclose(fpout);
    }
  }
}

void ExaMiniMD::print_performance() {}

void ExaMiniMD::shutdown() {
  system->destroy();
}


---

# examinimd.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <types.h>

#include<system.h>
#include<integrator.h>
#include<force.h>
#include<neighbor.h>
#include<comm.h>
#include<input.h>
#include<binning.h>

class ExaMiniMD {
  public:
    System* system;
    Integrator* integrator;
    Force* force;
    Neighbor* neighbor;
    Comm* comm;
    Input* input;
    Binning* binning;

    ExaMiniMD();

    void init(int argc,char* argv[]);
       
    void run(int nsteps);

    void dump_binary(int);
    void check_correctness(int);

    void print_performance();

    void shutdown();
};



---

# force.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force.h>

Force::Force(char** args, System* system, bool half_neigh_):half_neigh(half_neigh_) {}

void Force::init_coeff(int nargs, char** args) {}
void Force::compute(System*, Binning*, Neighbor*) { }
const char* Force::name() { return "ForceNone"; }



---

# force.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef FORCE_H
#define FORCE_H
#include<types.h>
#include<system.h>
#include<binning.h>
#include<neighbor.h>

class Force {
public:
  bool half_neigh, comm_newton;
  Force(char** args, System* system, bool half_neigh_);

  virtual void init_coeff(int nargs, char** args);

  virtual void compute(System* system, Binning* binning, Neighbor* neigh);
  virtual T_F_FLOAT compute_energy(System* system, Binning* binning, Neighbor* neigh){return 0.0;}; // Only needed for thermo output

  virtual const char* name();
};

#include<modules_force.h>
#endif


---

# input.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <input.h>
#include <iostream>
#include <fstream>
#include <property_temperature.h>

ItemizedFile::ItemizedFile () {
  nlines = 0;
  max_nlines = 0;
  words = NULL;
  words_per_line = 32;
  max_word_size = 32;
}

void ItemizedFile::allocate_words(int num_lines) {
  nlines = 0;

  if(max_nlines>=num_lines) {
    for(int i=0; i<max_nlines; i++)
      for(int j=0; j<words_per_line; j++)
        words[i][j][0] = 0;
    return;
  }

  free_words();
  max_nlines = num_lines;
  words = new char**[max_nlines];
  for(int i=0; i<max_nlines; i++) {
    words[i] = new char*[words_per_line];
    for(int j=0; j<words_per_line; j++) {
      words[i][j] = new char[max_word_size];
      words[i][j][0] = 0;
    }
  }
}

void ItemizedFile::free_words() {
  for(int i=0; i<max_nlines; i++) {
    for(int j=0; j<words_per_line; j++)
        delete [] words[i][j];
      delete [] words[i];
  }
  delete [] words;
}

void ItemizedFile::print_line(int i) {
  for(int j=0; j<words_per_line; j++) {
    if(words[i][j][0])
      std::cout << words[i][j] << " ";
  }
  std::cout << std::endl;
}

int ItemizedFile::words_in_line(int i){
  int count = 0;
  for(int j=0; j<words_per_line; j++)
    if(words[i][j][0]) count++;
  return count;
}
void ItemizedFile::print() {
  for(int l=0; l<nlines; l++)
    print_line(l);
}

void ItemizedFile::add_line(const char* const line) {
  const char* pos = line;
  if(nlines<max_nlines) {
    int j = 0;
    while((*pos) && (j<words_per_line)) {
      while(((*pos == ' ') || (*pos == '\t')) && *pos) pos++;
      int k = 0;
      while(((*pos != ' ') && (*pos != '\t')) && (*pos) && (k<max_word_size)) {
        words[nlines][j][k] = *pos;
        k++; pos++;
      }
      words[nlines][j][k] = 0;
      j++;
    }
  }
  nlines++;
}

Input::Input(System* p):system(p),input_data(ItemizedFile()),integrator_type(INTEGRATOR_NVE) {

  nsteps = 0;
  force_coeff_lines = Kokkos::View<int*,Kokkos::HostSpace>("Input::force_coeff_lines",0);
  input_file_type = -1;


#ifdef EXAMINIMD_ENABLE_MPI
  comm_type = COMM_MPI;
#else
  comm_type = COMM_SERIAL;
#endif
  neighbor_type = NEIGH_2D;
  force_iteration_type = FORCE_ITER_NEIGH_FULL;
  binning_type = BINNING_KKSORT;
  comm_exchange_rate = 20;

  // set defaults

  thermo_rate = 0;
  dumpbinary_rate = 0;
  correctness_rate = 0;
  dumpbinaryflag = false;
  correctnessflag = false;
  timestepflag = false;
  lattice_offset_x = 0.0;
  lattice_offset_y = 0.0;
  lattice_offset_z = 0.0;
  comm_newton = 0;
}

void Input::read_command_line_args(int argc, char* argv[]) {
#define MODULES_OPTION_CHECK
  for(int i = 1; i < argc; i++) {
    // Help command
    if( (strcmp(argv[i], "-h") == 0) || (strcmp(argv[i], "--help") == 0) ) {
      if(system->do_print) {
        printf("ExaMiniMD 1.0 (Kokkos Reference Version)\n\n");
        printf("Options:\n");
        printf("  -il [file] / --input-lammps [FILE]: Provide LAMMPS input file\n");
        printf("  --force-iteration [TYPE]:   Specify which iteration style to use\n");
        printf("                              for force calculations (CELL_FULL, NEIGH_FULL, NEIGH_HALF)\n");
        printf("  --comm-type [TYPE]:         Specify Communication Routines implementation \n");
        printf("                              (MPI, SERIAL)\n");
        printf("  --dumpbinary [N] [PATH]:    Request that binary output files PATH/output* be generated every N steps\n");
        printf("                              (N = positive integer)\n");
        printf("                              (PATH = location of directory)\n");
        printf("  --correctness [N] [PATH] [FILE]:   Request that correctness check against files PATH/output* be performed every N steps, correctness data written to FILE\n");
        printf("                              (N = positive integer)\n");
        printf("                              (PATH = location of directory)\n");
        printf("  --neigh-type [TYPE]:        Specify Neighbor Routines implementation \n");
        printf("                              (2D, CSR, CSR_MAPCONSTR)\n");
      }
    }

    // Read Lammps input deck
    else if( (strcmp(argv[i], "-il") == 0) || (strcmp(argv[i], "--input-lammps") == 0) ) {
      input_file = argv[++i];
      input_file_type = INPUT_LAMMPS;
    }

    // Force Iteration Type Related
    else if( (strcmp(argv[i], "--force-iteration") == 0) ) {
     #include<modules_force.h>
      ++i;
    }

    // Communication Type
    else if( (strcmp(argv[i], "--comm-type") == 0) ) {
     #include<modules_comm.h>
      ++i;
    }

    // Neighbor Type
    else if( (strcmp(argv[i], "--neigh-type") == 0) ) {
     #include<modules_neighbor.h>
      ++i;
    }

    // Dump Binary
    else if( (strcmp(argv[i], "--dumpbinary") == 0) ) {
      dumpbinary_rate = atoi(argv[i+1]);
      dumpbinary_path = argv[i+2];
      dumpbinaryflag = true;
      i += 2;
    }

    // Correctness Check
    else if( (strcmp(argv[i], "--correctness") == 0) ) {
      correctness_rate = atoi(argv[i+1]);
      reference_path = argv[i+2];
      correctness_file = argv[i+3];
      correctnessflag = true;
      i += 3;
    }

    else if( (strstr(argv[i], "--kokkos-") == NULL) ) {
      if(system->do_print)
        printf("ERROR: Unknown command line argument: %s\n",argv[i]);
      exit(1);
    }

  }
#undef MODULES_OPTION_CHECK
}

void Input::read_file(const char* filename) {
  if( filename == NULL )
    filename = input_file;
  if( input_file_type == INPUT_LAMMPS ) {
    read_lammps_file(filename);
    return;
  }
  if(system->do_print)
    printf("ERROR: Unknown input file type\n");
  exit(1);
}

void Input::read_lammps_file(const char* filename) {
  input_data.allocate_words(100);


  std::ifstream file(filename);
  char* line = new char[512];
  line[0] = 0;
  file.getline(line,std::streamsize(511));
  while(file.good()) {
    input_data.add_line(line);
    line[0] = 0;
    file.getline(line,511);
  }
  if(system->do_print) {
    printf("\n");
    printf("#InputFile:\n");
    printf("#=========================================================\n");

    input_data.print();

    printf("#=========================================================\n");
    printf("\n");
  }
  for(int l = 0; l<input_data.nlines; l++)
    check_lammps_command(l);
}

void Input::check_lammps_command(int line) {
  bool known = false;

  if(input_data.words[line][0][0]==0) { known = true; }
  if(strstr(input_data.words[line][0],"#")) { known = true; }
  if(strcmp(input_data.words[line][0],"variable")==0) {
    if(system->do_print)
      printf("LAMMPS-Command: 'variable' keyword is not supported in ExaMiniMD\n");
  }
  if(strcmp(input_data.words[line][0],"units")==0) {
    if(strcmp(input_data.words[line][1],"metal")==0) {
      known = true;
      units = UNITS_METAL;
      system->boltz = 8.617343e-5;
      //hplanck = 95.306976368;
      system->mvv2e = 1.0364269e-4;
      system->dt = 0.001;
    } else if(strcmp(input_data.words[line][1],"real")==0) {
      known = true;
      units = UNITS_REAL;
      system->boltz = 0.0019872067;
      //hplanck = 95.306976368;
      system->mvv2e = 48.88821291 * 48.88821291;
      if (!timestepflag)
        system->dt = 1.0;
    } else if(strcmp(input_data.words[line][1],"lj")==0) {
      known = true;
      units = UNITS_LJ;
      system->boltz = 1.0;
      //hplanck = 0.18292026;
      system->mvv2e = 1.0;
      if (!timestepflag)
        system->dt = 0.005;
    } else {
      if(system->do_print)
        printf("LAMMPS-Command: 'units' command only supports 'real' and 'lj' in ExaMiniMD\n");
    }
  }
  if(strcmp(input_data.words[line][0],"atom_style")==0) {
    if(strcmp(input_data.words[line][1],"atomic")==0) {
      known = true;
    } else {
      if(system->do_print)
        printf("LAMMPS-Command: 'atom_style' command only supports 'atomic' in ExaMiniMD\n");
    }
  }
  if(strcmp(input_data.words[line][0],"lattice")==0) {
    if(strcmp(input_data.words[line][1],"sc")==0) {
      known = true;
      lattice_style = LATTICE_SC;
      lattice_constant = atof(input_data.words[line][2]);
    } else if(strcmp(input_data.words[line][1],"fcc")==0) {
      known = true;
      lattice_style = LATTICE_FCC;
      lattice_constant = std::pow((4.0 / atof(input_data.words[line][2])), (1.0 / 3.0));
    } else {
      if(system->do_print)
        printf("LAMMPS-Command: 'lattice' command only supports 'sc' and 'fcc' in ExaMiniMD\n");
    }
    if(strcmp(input_data.words[line][3],"origin")==0) {
       lattice_offset_x = atof(input_data.words[line][4]);
       lattice_offset_y = atof(input_data.words[line][5]);
       lattice_offset_z = atof(input_data.words[line][6]);
    }
  }
  if(strcmp(input_data.words[line][0],"region")==0) {
    if(strcmp(input_data.words[line][2],"block")==0) {
      known = true;
      int box[6];
      box[0] = atoi(input_data.words[line][3]);
      box[1] = atoi(input_data.words[line][4]);
      box[2] = atoi(input_data.words[line][5]);
      box[3] = atoi(input_data.words[line][6]);
      box[4] = atoi(input_data.words[line][7]);
      box[5] = atoi(input_data.words[line][8]);
      if( (box[0]!=0) || (box[2]!=0) || (box[4]!=0))
        if(system->do_print)
          printf("Error: LAMMPS-Command: region only allows for boxes with 0,0,0 offset\n");
      lattice_nx = box[1];
      lattice_ny = box[3];
      lattice_nz = box[5];
    } else {
      if(system->do_print)
        printf("LAMMPS-Command: 'region' command only supports 'block' option in ExaMiniMD\n");
    }
  }
  if(strcmp(input_data.words[line][0],"create_box")==0) {
    known = true;
    system->ntypes = atoi(input_data.words[line][1]);
    system->mass = t_mass("System::mass",system->ntypes);
  }
  if(strcmp(input_data.words[line][0],"create_atoms")==0) {
    known = true;
  }
  if(strcmp(input_data.words[line][0],"mass")==0) {
    known = true;
    int type = atoi(input_data.words[line][1])-1;
    Kokkos::View<T_V_FLOAT> mass_one(system->mass,type);
    T_V_FLOAT mass = atof(input_data.words[line][2]);
    Kokkos::deep_copy(mass_one,mass);
  }
  if(strcmp(input_data.words[line][0],"pair_style")==0) {
    if(strcmp(input_data.words[line][1],"lj/cut/idial")==0) {
      known = true;
      force_type = FORCE_LJ_IDIAL;
      force_cutoff = atof(input_data.words[line][2]);
      force_line = line;
    } else if(strcmp(input_data.words[line][1],"lj/cut")==0) {
      known = true;
      force_type = FORCE_LJ;
      force_cutoff = atof(input_data.words[line][2]);
      force_line = line;
    }
    if(strcmp(input_data.words[line][1],"snap")==0) {
      known = true;
      force_type = FORCE_SNAP;
      force_cutoff = 4.73442;// atof(input_data.words[line][2]);
      force_line = line;
    }
    if(system->do_print && !known)
      printf("LAMMPS-Command: 'pair_style' command only supports 'lj/cut', 'lj/cut/idial', and 'snap' style in ExaMiniMD\n");
  }
  if(strcmp(input_data.words[line][0],"pair_coeff")==0) {
    known = true;
    int n_coeff_lines = force_coeff_lines.extent(0);
    Kokkos::resize(force_coeff_lines,n_coeff_lines+1);
    force_coeff_lines( n_coeff_lines) = line;
    n_coeff_lines++;
  }
  if(strcmp(input_data.words[line][0],"velocity")==0) {
    known = true;
    if(strcmp(input_data.words[line][1],"all")!=0) {
      if(system->do_print)
        printf("Error: LAMMPS-Command: 'velocity' command can only be applied to 'all'\n");
    }
    if(strcmp(input_data.words[line][2],"create")!=0) {
      if(system->do_print)
        printf("Error: LAMMPS-Command: 'velocity' command can only be used with option 'create'\n");
    }
    temperature_target = atof(input_data.words[line][3]);
    temperature_seed = atoi(input_data.words[line][4]);
  }
  if(strcmp(input_data.words[line][0],"neighbor")==0) {
    known = true;
    neighbor_skin = atof(input_data.words[line][1]);
  }
  if(strcmp(input_data.words[line][0],"neigh_modify")==0) {
    known = true;
    for(int i=1; i<input_data.words_per_line-1;i++)
      if(strcmp(input_data.words[line][i],"every")==0) {
        comm_exchange_rate = atoi(input_data.words[line][i+1]);
      }
  }
  if(strcmp(input_data.words[line][0],"fix")==0) {
    if(strcmp(input_data.words[line][3],"nve")==0) {
      known = true;
      integrator_type = INTEGRATOR_NVE;
    } else {
      if(system->do_print)
        printf("LAMMPS-Command: 'fix' command only supports 'nve' style in ExaMiniMD\n");
    }
  }
  if(strcmp(input_data.words[line][0],"run")==0) {
    known = true;
    nsteps = atoi(input_data.words[line][1]);
  }
  if(strcmp(input_data.words[line][0],"thermo")==0) {
    known = true;
    thermo_rate = atoi(input_data.words[line][1]);
  }
  if(strcmp(input_data.words[line][0],"timestep")==0) {
    known = true;
    system->dt = atof(input_data.words[line][1]);
    timestepflag = true;
  }
  if(strcmp(input_data.words[line][0],"newton")==0) {
    known = true;
    if(strcmp(input_data.words[line][1],"on")==0) {
      comm_newton=1;
    } else if(strcmp(input_data.words[line][1],"off")==0) {
      comm_newton=0;
    } else {
      if(system->do_print)
        printf("LAMMPS-Command: 'newton' must be followed by 'on' or 'off'\n");
    }
  }
  if(input_data.words[line][0][0]=='#') {
    known = true;
  }
  if(!known && system->do_print) {
    printf("ERROR: unknown keyword\n");
    input_data.print_line(line);
  }
}

void Input::create_lattice(Comm* comm) {

  System s = *system;

  t_x::HostMirror h_x = Kokkos::create_mirror_view(s.x);
  t_v::HostMirror h_v = Kokkos::create_mirror_view(s.v);
  t_q::HostMirror h_q = Kokkos::create_mirror_view(s.q);
  t_mass::HostMirror h_mass = Kokkos::create_mirror_view(s.mass);
  t_type::HostMirror h_type = Kokkos::create_mirror_view(s.type);
  t_id::HostMirror h_id = Kokkos::create_mirror_view(s.id);

  Kokkos::deep_copy(h_mass,s.mass);

  // Create Simple Cubic Lattice
  if(lattice_style == LATTICE_SC) {
    system->domain_x = lattice_constant * lattice_nx;
    system->domain_y = lattice_constant * lattice_ny;
    system->domain_z = lattice_constant * lattice_nz;

    comm->create_domain_decomposition();
    s = *system;

    T_INT ix_start = s.sub_domain_lo_x/s.domain_x * lattice_nx - 0.5;
    T_INT iy_start = s.sub_domain_lo_y/s.domain_y * lattice_ny - 0.5;
    T_INT iz_start = s.sub_domain_lo_z/s.domain_z * lattice_nz - 0.5;

    T_INT ix_end = s.sub_domain_hi_x/s.domain_x * lattice_nx + 0.5;
    T_INT iy_end = s.sub_domain_hi_y/s.domain_y * lattice_ny + 0.5;
    T_INT iz_end = s.sub_domain_hi_z/s.domain_z * lattice_nz + 0.5;

    T_INT n = 0;

    for(T_INT iz=iz_start; iz<=iz_end; iz++) {
      T_FLOAT ztmp = lattice_constant * (iz+lattice_offset_z);
      for(T_INT iy=iy_start; iy<=iy_end; iy++) {
        T_FLOAT ytmp = lattice_constant * (iy+lattice_offset_y);
        for(T_INT ix=ix_start; ix<=ix_end; ix++) {
          T_FLOAT xtmp = lattice_constant * (ix+lattice_offset_x);
          if((xtmp >= s.sub_domain_lo_x) &&
             (ytmp >= s.sub_domain_lo_y) &&
             (ztmp >= s.sub_domain_lo_z) &&
             (xtmp <  s.sub_domain_hi_x) &&
             (ytmp <  s.sub_domain_hi_y) &&
             (ztmp <  s.sub_domain_hi_z) ) {
            n++;
          }
        }
      }
    }
    system->N_local = n;
    system->N = n;
    system->grow(n);
    s = *system;
    h_x = Kokkos::create_mirror_view(s.x);
    h_v = Kokkos::create_mirror_view(s.v);
    h_q = Kokkos::create_mirror_view(s.q);
    h_type = Kokkos::create_mirror_view(s.type);
    h_id = Kokkos::create_mirror_view(s.id);

    // Initialize system using the equivalent of the LAMMPS
    // velocity geom option, i.e. uniform random kinetic energies.
    // zero out momentum of the whole system afterwards, to eliminate
    // drift (bad for energy statistics)

    for(T_INT iz=iz_start; iz<=iz_end; iz++) {
      T_FLOAT ztmp = lattice_constant * (iz+lattice_offset_z);
      for(T_INT iy=iy_start; iy<=iy_end; iy++) {
        T_FLOAT ytmp = lattice_constant * (iy+lattice_offset_y);
        for(T_INT ix=ix_start; ix<=ix_end; ix++) {
          T_FLOAT xtmp = lattice_constant * (ix+lattice_offset_x);
          if((xtmp >= s.sub_domain_lo_x) &&
             (ytmp >= s.sub_domain_lo_y) &&
             (ztmp >= s.sub_domain_lo_z) &&
             (xtmp <  s.sub_domain_hi_x) &&
             (ytmp <  s.sub_domain_hi_y) &&
             (ztmp <  s.sub_domain_hi_z) ) {
            n++;
          }
        }
      }
    }
    system->grow(n);
    System s = *system;
    h_x = Kokkos::create_mirror_view(s.x);
    h_v = Kokkos::create_mirror_view(s.v);
    h_q = Kokkos::create_mirror_view(s.q);
    h_type = Kokkos::create_mirror_view(s.type);
    h_id = Kokkos::create_mirror_view(s.id);

    n = 0;

    // Initialize system using the equivalent of the LAMMPS
    // velocity geom option, i.e. uniform random kinetic energies.
    // zero out momentum of the whole system afterwards, to eliminate
    // drift (bad for energy statistics)

    for(T_INT iz=iz_start; iz<=iz_end; iz++) {
      T_FLOAT ztmp = lattice_constant * (iz+lattice_offset_z);
      for(T_INT iy=iy_start; iy<=iy_end; iy++) {
        T_FLOAT ytmp = lattice_constant * (iy+lattice_offset_y);
        for(T_INT ix=ix_start; ix<=ix_end; ix++) {
          T_FLOAT xtmp = lattice_constant * (ix+lattice_offset_x);
          if((xtmp >= s.sub_domain_lo_x) &&
             (ytmp >= s.sub_domain_lo_y) &&
             (ztmp >= s.sub_domain_lo_z) &&
             (xtmp <  s.sub_domain_hi_x) &&
             (ytmp <  s.sub_domain_hi_y) &&
             (ztmp <  s.sub_domain_hi_z) ) {
            h_x(n,0) = xtmp;
            h_x(n,1) = ytmp;
            h_x(n,2) = ztmp;
            h_type(n) = rand()%s.ntypes;
            h_id(n) = n+1;
            n++;
          }
        }
      }
    }
    comm->reduce_int(&system->N,1);

    // Make ids unique over all processes
    T_INT N_local_offset = n;
    comm->scan_int(&N_local_offset,1);
    for(T_INT i = 0; i<n; i++)
      h_id(i) += N_local_offset - n;

    if(system->do_print)
      printf("Atoms: %i %i\n",system->N,system->N_local);
  }

  // Create Face Centered Cubic (FCC) Lattice
  if(lattice_style == LATTICE_FCC) {
    system->domain_x = lattice_constant * lattice_nx;
    system->domain_y = lattice_constant * lattice_ny;
    system->domain_z = lattice_constant * lattice_nz;

    comm->create_domain_decomposition();
    s = *system;

    double basis[4][3];
    basis[0][0] = 0.0; basis[0][1] = 0.0; basis[0][2] = 0.0;
    basis[1][0] = 0.5; basis[1][1] = 0.5; basis[1][2] = 0.0;
    basis[2][0] = 0.5; basis[2][1] = 0.0; basis[2][2] = 0.5;
    basis[3][0] = 0.0; basis[3][1] = 0.5; basis[3][2] = 0.5;

    for (int i = 0; i < 4; i++) {
      basis[i][0] += lattice_offset_x;
      basis[i][1] += lattice_offset_y;
      basis[i][2] += lattice_offset_z;
    }

    T_INT ix_start = s.sub_domain_lo_x/s.domain_x * lattice_nx - 0.5;
    T_INT iy_start = s.sub_domain_lo_y/s.domain_y * lattice_ny - 0.5;
    T_INT iz_start = s.sub_domain_lo_z/s.domain_z * lattice_nz - 0.5;

    T_INT ix_end = s.sub_domain_hi_x/s.domain_x * lattice_nx + 0.5;
    T_INT iy_end = s.sub_domain_hi_y/s.domain_y * lattice_ny + 0.5;
    T_INT iz_end = s.sub_domain_hi_z/s.domain_z * lattice_nz + 0.5;

    T_INT n = 0;

    for(T_INT iz=iz_start; iz<=iz_end; iz++) {
      for(T_INT iy=iy_start; iy<=iy_end; iy++) {
        for(T_INT ix=ix_start; ix<=ix_end; ix++) {
          for(int k = 0; k<4; k++) {
            T_FLOAT xtmp = lattice_constant * (1.0*ix+basis[k][0]);
            T_FLOAT ytmp = lattice_constant * (1.0*iy+basis[k][1]);
            T_FLOAT ztmp = lattice_constant * (1.0*iz+basis[k][2]);
            if((xtmp >= s.sub_domain_lo_x) &&
               (ytmp >= s.sub_domain_lo_y) &&
               (ztmp >= s.sub_domain_lo_z) &&
               (xtmp <  s.sub_domain_hi_x) &&
               (ytmp <  s.sub_domain_hi_y) &&
               (ztmp <  s.sub_domain_hi_z) ) {
              n++;
            }
          }
        }
      }
    }

    system->N_local = n;
    system->N = n;
    system->grow(n);
    s = *system;
    h_x = Kokkos::create_mirror_view(s.x);
    h_v = Kokkos::create_mirror_view(s.v);
    h_q = Kokkos::create_mirror_view(s.q);
    h_type = Kokkos::create_mirror_view(s.type);
    h_id = Kokkos::create_mirror_view(s.id);

    // Initialize system using the equivalent of the LAMMPS
    // velocity geom option, i.e. uniform random kinetic energies.
    // zero out momentum of the whole system afterwards, to eliminate
    // drift (bad for energy statistics)

    for(T_INT iz=iz_start; iz<=iz_end; iz++) {
      for(T_INT iy=iy_start; iy<=iy_end; iy++) {
        for(T_INT ix=ix_start; ix<=ix_end; ix++) {
          for(int k = 0; k<4; k++) {
            T_FLOAT xtmp = lattice_constant * (1.0*ix+basis[k][0]);
            T_FLOAT ytmp = lattice_constant * (1.0*iy+basis[k][1]);
            T_FLOAT ztmp = lattice_constant * (1.0*iz+basis[k][2]);
            if((xtmp >= s.sub_domain_lo_x) &&
               (ytmp >= s.sub_domain_lo_y) &&
               (ztmp >= s.sub_domain_lo_z) &&
               (xtmp <  s.sub_domain_hi_x) &&
               (ytmp <  s.sub_domain_hi_y) &&
               (ztmp <  s.sub_domain_hi_z) ) {
              n++;
            }
          }
        }
      }
    }
    system->grow(n);
    System s = *system;
    h_x = Kokkos::create_mirror_view(s.x);
    h_v = Kokkos::create_mirror_view(s.v);
    h_q = Kokkos::create_mirror_view(s.q);
    h_type = Kokkos::create_mirror_view(s.type);
    h_id = Kokkos::create_mirror_view(s.id);

    n = 0;

    // Initialize system using the equivalent of the LAMMPS
    // velocity geom option, i.e. uniform random kinetic energies.
    // zero out momentum of the whole system afterwards, to eliminate
    // drift (bad for energy statistics)

    for(T_INT iz=iz_start; iz<=iz_end; iz++) {
      for(T_INT iy=iy_start; iy<=iy_end; iy++) {
        for(T_INT ix=ix_start; ix<=ix_end; ix++) {
          for(int k = 0; k<4; k++) {
            T_FLOAT xtmp = lattice_constant * (1.0*ix+basis[k][0]);
            T_FLOAT ytmp = lattice_constant * (1.0*iy+basis[k][1]);
            T_FLOAT ztmp = lattice_constant * (1.0*iz+basis[k][2]);
            if((xtmp >= s.sub_domain_lo_x) &&
               (ytmp >= s.sub_domain_lo_y) &&
               (ztmp >= s.sub_domain_lo_z) &&
               (xtmp <  s.sub_domain_hi_x) &&
               (ytmp <  s.sub_domain_hi_y) &&
               (ztmp <  s.sub_domain_hi_z) ) {
              h_x(n,0) = xtmp;
              h_x(n,1) = ytmp;
              h_x(n,2) = ztmp;
              h_type(n) = rand()%s.ntypes;
              h_id(n) = n+1;
              n++;
            }
          }
        }
      }
    }

    // Make ids unique over all processes
    T_INT N_local_offset = n;
    comm->scan_int(&N_local_offset,1);
    for(T_INT i = 0; i<n; i++)
      h_id(i) += N_local_offset - n;

    comm->reduce_int(&system->N,1);

    if(system->do_print)
      printf("Atoms: %i %i\n",system->N,system->N_local);
  }
  // Initialize velocity using the equivalent of the LAMMPS
  // velocity geom option, i.e. uniform random kinetic energies.
  // zero out momentum of the whole system afterwards, to eliminate
  // drift (bad for energy statistics)

  {  // Scope s
    System s = *system;
    T_FLOAT total_mass = 0.0;
    T_FLOAT total_momentum_x = 0.0;
    T_FLOAT total_momentum_y = 0.0;
    T_FLOAT total_momentum_z = 0.0;

    for(T_INT i=0; i<system->N_local; i++) {
      LAMMPS_RandomVelocityGeom random;
      double x[3] = {h_x(i,0),h_x(i,1),h_x(i,2)};
      random.reset(temperature_seed,x);

      T_FLOAT mass_i = h_mass(h_type(i));
      T_FLOAT vx = random.uniform()-0.5;
      T_FLOAT vy = random.uniform()-0.5;
      T_FLOAT vz = random.uniform()-0.5;

      h_v(i,0) = vx/sqrt(mass_i);
      h_v(i,1) = vy/sqrt(mass_i);
      h_v(i,2) = vz/sqrt(mass_i);

      h_q(i) = 0.0;

      total_mass += mass_i;
      total_momentum_x += mass_i * h_v(i,0);
      total_momentum_y += mass_i * h_v(i,1);
      total_momentum_z += mass_i * h_v(i,2);

    }
    comm->reduce_float(&total_momentum_x,1);
    comm->reduce_float(&total_momentum_y,1);
    comm->reduce_float(&total_momentum_z,1);
    comm->reduce_float(&total_mass,1);

    T_FLOAT system_vx = total_momentum_x / total_mass;
    T_FLOAT system_vy = total_momentum_y / total_mass;
    T_FLOAT system_vz = total_momentum_z / total_mass;

    for(T_INT i=0; i<system->N_local; i++) {
      h_v(i,0) -= system_vx;
      h_v(i,1) -= system_vy;
      h_v(i,2) -= system_vz;
    }

    Kokkos::deep_copy(s.v,h_v);
    Temperature temp(comm);
    T_V_FLOAT T = temp.compute(system);

    T_V_FLOAT T_init_scale = sqrt(temperature_target/T);

    for(T_INT i=0; i<system->N_local; i++) {
      h_v(i,0) *= T_init_scale;
      h_v(i,1) *= T_init_scale;
      h_v(i,2) *= T_init_scale;
    }
    Kokkos::deep_copy(s.x,h_x);
    Kokkos::deep_copy(s.v,h_v);
    Kokkos::deep_copy(s.q,h_q);
    Kokkos::deep_copy(s.type,h_type);
    Kokkos::deep_copy(s.id,h_id);
  }
}


---

# input.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <types.h>
#include <system.h>
#include <comm.h>

class ItemizedFile {
public:
  char*** words;
  int max_nlines;
  int nlines;
  int words_per_line;
  int max_word_size;
  ItemizedFile();
  void allocate_words(int num_lines);
  void free_words();
  void print_line(int line);
  int words_in_line(int line);
  void print();
  void add_line(const char* const line);
};

// Class replicating LAMMPS Random velocity initialization with GEOM option
#define IA 16807
#define IM 2147483647
#define AM (1.0/IM)
#define IQ 127773
#define IR 2836

class LAMMPS_RandomVelocityGeom {
 private:
  int seed;
 public:

  KOKKOS_INLINE_FUNCTION
  LAMMPS_RandomVelocityGeom (): seed(0) {};

  KOKKOS_INLINE_FUNCTION
  double uniform() {
    int k = seed/IQ;
    seed = IA*(seed-k*IQ) - IR*k;
    if (seed < 0) seed += IM;
    double ans = AM*seed;
    return ans;
  }

  KOKKOS_INLINE_FUNCTION
  double gaussian() {
    double v1,v2,rsq;
    do {
      v1 = 2.0*uniform()-1.0;
      v2 = 2.0*uniform()-1.0;
      rsq = v1*v1 + v2*v2;
    } while ((rsq >= 1.0) || (rsq == 0.0));

    const double fac = sqrt(-2.0*log(rsq)/rsq);
    return v2*fac;
  }

  KOKKOS_INLINE_FUNCTION
  void reset(int ibase, double *coord)
  {
    int i;

    char *str = (char *) &ibase;
    int n = sizeof(int);

    unsigned int hash = 0;
    for (i = 0; i < n; i++) {
      hash += str[i];
      hash += (hash << 10);
      hash ^= (hash >> 6);
    }

    str = (char *) coord;
    n = 3 * sizeof(double);
    for (i = 0; i < n; i++) {
      hash += str[i];
      hash += (hash << 10);
      hash ^= (hash >> 6);
    }

    hash += (hash << 3);
    hash ^= (hash >> 11);
    hash += (hash << 15);

    // keep 31 bits of unsigned int as new seed
    // do not allow seed = 0, since will cause hang in gaussian()

    seed = hash & 0x7ffffff;
    if (!seed) seed = 1;

    // warm up the RNG

    for (i = 0; i < 5; i++) uniform();
  }
};


class Input {
 private:
  bool timestepflag; // input timestep?  
 public:
  System* system;
  
  char* input_file;
  int input_file_type;
  ItemizedFile input_data;

  int units;

  int lattice_style;
  double lattice_constant, lattice_offset_x, lattice_offset_y, lattice_offset_z;
  int lattice_nx, lattice_ny, lattice_nz;

  double temperature_target;
  int temperature_seed;

  int integrator_type;
  int nsteps;

  int binning_type;

  int comm_type;
  int comm_exchange_rate;
  int comm_newton;

  int force_type;
  int force_iteration_type;
  int force_line;
  T_F_FLOAT force_cutoff;
  Kokkos::View<int*,Kokkos::HostSpace> force_coeff_lines;


  T_F_FLOAT neighbor_skin; 
  int neighbor_type;
  
  int thermo_rate, dumpbinary_rate, correctness_rate;
  bool dumpbinaryflag, correctnessflag;
  char *dumpbinary_path, *reference_path, *correctness_file;
 
public:
  Input(System* s);
  void read_command_line_args(int argc, char* argv[]);
  void read_file(const char* filename = NULL);
  void read_lammps_file(const char* filename);
  void check_lammps_command(int line);
  void create_lattice(Comm* comm);
};


---

# integrator.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<integrator.h>
Integrator::Integrator(System* p):system(p) {}
Integrator::~Integrator() {}

void Integrator::initial_integrate() {}
void Integrator::final_integrate() {}


---

# integrator.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef INTEGRATORS_H
#define INTEGRATORS_H

#include <types.h>
#include <system.h>

class Integrator {
public:
  System* system;

  Integrator(System* s);
  virtual ~Integrator();
  T_V_FLOAT timestep_size;

  virtual void initial_integrate();
  virtual void final_integrate();
};

#include<modules_integrator.h>
#endif


---

# integrator_nve.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <integrator_nve.h>

IntegratorNVE::IntegratorNVE(System* s):Integrator(s) {
  dtv = system->dt;
  dtf = 0.5 * system->dt / system->mvv2e;
}

namespace {
  struct InitialIntegrateFunctor {
    t_x x;
    t_v v;
    t_f_const f;
    t_type_const type;
    t_mass_const mass;
    t_id id;
    int step;

    T_V_FLOAT dtf,dtv;
    InitialIntegrateFunctor(
      t_x& x_, t_v& v_, t_f& f_,
      t_type type_, t_mass mass_, t_id id_,
      T_V_FLOAT dtf_, T_V_FLOAT dtv_, int step_
    ):x(x_),v(v_),f(f_),type(type_),mass(mass_),
      id(id_),dtf(dtf_),dtv(dtv_),step(step_) {}

    KOKKOS_INLINE_FUNCTION
    void operator() (const T_INT& i) const {
      const T_V_FLOAT dtfm = dtf / mass(type(i));
      v(i,0) += dtfm * f(i,0);
      v(i,1) += dtfm * f(i,1);
      v(i,2) += dtfm * f(i,2);
      x(i,0) += dtv * v(i,0);
      x(i,1) += dtv * v(i,1);
      x(i,2) += dtv * v(i,2);
    }
  };
}

void IntegratorNVE::initial_integrate() {
  static int step =1;
  Kokkos::parallel_for("IntegratorNVE::initial_integrate",system->N_local,
                       InitialIntegrateFunctor(system->x, system->v, system->f,
                                               system->type, system->mass, system->id, dtf, dtv, step));
  step++;
}


namespace {
  struct FinalIntegrateFunctor {
    t_v v;
    t_f_const f;
    t_type_const type;
    t_mass_const mass;
    t_id id;
    int step;
    t_x x;

    T_V_FLOAT dtf,dtv;
    FinalIntegrateFunctor(
      t_v& v_, t_f& f_,
      t_type type_, t_mass mass_,
      T_V_FLOAT dtf_, T_V_FLOAT dtv_,
      t_id id_, int step_, t_x x_
    ):v(v_),f(f_),type(type_),mass(mass_),
      dtf(dtf_),dtv(dtv_),id(id_),step(step_),x(x_) {}

    KOKKOS_INLINE_FUNCTION
    void operator() (const T_INT& i) const {
      const T_V_FLOAT dtfm = dtf / mass(type(i));
      v(i,0) += dtfm * f(i,0);
      v(i,1) += dtfm * f(i,1);
      v(i,2) += dtfm * f(i,2);
    }
  };
}

void IntegratorNVE::final_integrate() {
  static int step = 1;
  Kokkos::parallel_for("IntegratorNVE::final_integrate",system->N_local, 
                       FinalIntegrateFunctor(system->v, system->f,
                                             system->type, system->mass, dtf, dtv, system->id, step, system->x));
  step++;
}



---

# integrator_nve.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef INTEGRATOR_NVE_H
#define INTEGRATOR_NVE_H

#include <types.h>
#include <integrator.h>

class IntegratorNVE: public Integrator {
  T_V_FLOAT dtv, dtf;

public:
  IntegratorNVE(System* s);
  void initial_integrate();
  void final_integrate();
};
#endif


---

# main.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<examinimd.h>

// ExaMiniMD can be used as a library
// This main file is simply a driver

#ifdef EXAMINIMD_ENABLE_MPI
#include "mpi.h"
#endif

int main(int argc, char* argv[]) {

   #ifdef EXAMINIMD_ENABLE_MPI
   MPI_Init(&argc,&argv);
   #endif

   Kokkos::initialize(argc,argv);

   ExaMiniMD examinimd;
   examinimd.init(argc,argv);
  
   examinimd.run(examinimd.input->nsteps);

   //   examinimd.check_correctness();

   examinimd.print_performance();

   examinimd.shutdown();

   Kokkos::finalize();

   #ifdef EXAMINIMD_ENABLE_MPI
   MPI_Finalize();
   #endif
}



---

# Makefile

#Kokkos root path
KOKKOS_PATH = ${HOME}/kokkos

#Backend and architecture configuration
KOKKOS_DEVICES=OpenMP
KOKKOS_ARCH = ""

#MPI On or off (1/0)
MPI = 1

MAKEFILE_PATH := $(abspath $(lastword $(MAKEFILE_LIST)))
EXAMINIMD_PATH = $(subst Makefile,,$(MAKEFILE_PATH))/..

default: build
	echo "Start Build"


EXE = ExaMiniMD
CXXFLAGS = -O3 -g
LINKFLAGS = -O3 -g

ifeq ($(MPI), 1)
  CXX = mpicxx
  CXXFLAGS += -DEXAMINIMD_ENABLE_MPI
else
  ifneq (,$(findstring Cuda,$(KOKKOS_DEVICES)))
    CXX = $(KOKKOS_PATH)/bin/nvcc_wrapper
  else
    CXX = g++
  endif
endif

LINK = ${CXX}

KOKKOS_OPTIONS=aggressive_vectorization

DEPFLAGS = -M

vpath %.cpp $(EXAMINIMD_PATH)/src
SRC =  $(wildcard $(EXAMINIMD_PATH)/src/*.cpp) 
HEADERS = $(wildcard $(EXAMINIMD_PATH)/src/*.h) 
CXXFLAGS += -I$(EXAMINIMD_PATH)/src

vpath %.cpp $(EXAMINIMD_PATH)/src/force_types
SRC += $(wildcard $(EXAMINIMD_PATH)/src/force_types/*.cpp)
HEADERS += $(wildcard $(EXAMINIMD_PATH)/src/force_types/*.h)
CXXFLAGS += -I$(EXAMINIMD_PATH)/src/force_types

vpath %.cpp $(EXAMINIMD_PATH)/src/comm_types
SRC += $(wildcard $(EXAMINIMD_PATH)/src/comm_types/*.cpp)
HEADERS += $(wildcard $(EXAMINIMD_PATH)/src/comm_types/*.h)
CXXFLAGS += -I$(EXAMINIMD_PATH)/src/comm_types

vpath %.cpp $(EXAMINIMD_PATH)/src/neighbor_types
SRC += $(wildcard $(EXAMINIMD_PATH)/src/neighbor_types/*.cpp)
HEADERS += $(wildcard $(EXAMINIMD_PATH)/src/neighbor_types/*.h)
CXXFLAGS += -I$(EXAMINIMD_PATH)/src/neighbor_types

vpath %.cpp $(EXAMINIMD_PATH)/src/binning_types
SRC += $(wildcard $(EXAMINIMD_PATH)/src/binning_types/*.cpp)
HEADERS += $(wildcard $(EXAMINIMD_PATH)/src/binning_types/*.h)
CXXFLAGS += -I$(EXAMINIMD_PATH)/src/binning_types

SRC_NOTDIR = $(notdir $(SRC))
OBJ = $(SRC_NOTDIR:.cpp=.o)
LIB =

include $(KOKKOS_PATH)/Makefile.kokkos

build: $(EXE)

$(EXE): $(OBJ) $(KOKKOS_LINK_DEPENDS)
	$(LINK) $(KOKKOS_LDFLAGS) $(LINKFLAGS) $(EXTRA_PATH) $(OBJ) $(KOKKOS_LIBS) $(LIB) -o $(EXE)

clean: kokkos-clean 
	rm -f *.o $(EXE)

# Compilation rules

%.o:%.cpp $(KOKKOS_CPP_DEPENDS) ${HEADERS}
	$(CXX) $(KOKKOS_CPPFLAGS) $(KOKKOS_CXXFLAGS) $(CXXFLAGS) $(EXTRA_INC) -c $<



---

# math_extra.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

/* -*- c++ -*- ----------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
   Contributing author: Mike Brown (SNL)
------------------------------------------------------------------------- */

#ifndef LMP_MATH_EXTRA_H
#define LMP_MATH_EXTRA_H

#include <math.h>
#include <stdio.h>
#include <string.h>
#include "error.h"

namespace MathExtra {

  // 3 vector operations

  inline void copy3(const double *v, double *ans);
  inline void zero3(double *v);
  inline void norm3(double *v);
  inline void normalize3(const double *v, double *ans);
  inline void snormalize3(const double, const double *v, double *ans);
  inline void negate3(double *v);
  inline void scale3(double s, double *v);
  inline void add3(const double *v1, const double *v2, double *ans);
  inline void scaleadd3(double s, const double *v1, const double *v2, 
                        double *ans);
  inline void sub3(const double *v1, const double *v2, double *ans);
  inline double len3(const double *v);
  inline double lensq3(const double *v);
  inline double distsq3(const double *v1, const double *v2);
  inline double dot3(const double *v1, const double *v2);
  inline void cross3(const double *v1, const double *v2, double *ans);

  // 3x3 matrix operations

  inline void col2mat(const double *ex, const double *ey, const double *ez,
                      double m[3][3]);
  inline double det3(const double mat[3][3]);
  inline void diag_times3(const double *d, const double m[3][3],
                          double ans[3][3]);
  inline void times3_diag(const double m[3][3], const double *d,
                          double ans[3][3]);
  inline void plus3(const double m[3][3], const double m2[3][3],
                    double ans[3][3]);
  inline void times3(const double m[3][3], const double m2[3][3],
                     double ans[3][3]);
  inline void transpose_times3(const double m[3][3], const double m2[3][3],
                               double ans[3][3]);
  inline void times3_transpose(const double m[3][3], const double m2[3][3],
                               double ans[3][3]);
  inline void invert3(const double mat[3][3], double ans[3][3]);
  inline void matvec(const double mat[3][3], const double *vec, double *ans);
  inline void matvec(const double *ex, const double *ey, const double *ez,
                     const double *vec, double *ans);
  inline void transpose_matvec(const double mat[3][3], const double *vec,
                               double *ans);
  inline void transpose_matvec(const double *ex, const double *ey,
                               const double *ez, const double *v,
                               double *ans);
  inline void transpose_diag3(const double m[3][3], const double *d,
                              double ans[3][3]);
  inline void vecmat(const double *v, const double m[3][3], double *ans);
  inline void scalar_times3(const double f, double m[3][3]);

  void write3(const double mat[3][3]);
  int mldivide3(const double mat[3][3], const double *vec, double *ans);
  int jacobi(double matrix[3][3], double *evalues, double evectors[3][3]);
  void rotate(double matrix[3][3], int i, int j, int k, int l,
              double s, double tau);
  void richardson(double *q, double *m, double *w, double *moments, double dtq);
  void no_squish_rotate(int k, double *p, double *q, double *inertia, 
                        double dt);

  // shape matrix operations
  // upper-triangular 3x3 matrix stored in Voigt notation as 6-vector

  inline void multiply_shape_shape(const double *one, const double *two,
                                   double *ans);

  // quaternion operations

  inline void qnormalize(double *q);
  inline void qconjugate(double *q, double *qc);
  inline void vecquat(double *a, double *b, double *c);
  inline void quatvec(double *a, double *b, double *c);
  inline void quatquat(double *a, double *b, double *c);
  inline void invquatvec(double *a, double *b, double *c);
  inline void axisangle_to_quat(const double *v, const double angle,
                                double *quat);

  void angmom_to_omega(double *m, double *ex, double *ey, double *ez,
                       double *idiag, double *w);
  void omega_to_angmom(double *w, double *ex, double *ey, double *ez,
                       double *idiag, double *m);
  void mq_to_omega(double *m, double *q, double *moments, double *w);
  void exyz_to_q(double *ex, double *ey, double *ez, double *q);
  void q_to_exyz(double *q, double *ex, double *ey, double *ez);
  void quat_to_mat(const double *quat, double mat[3][3]);
  void quat_to_mat_trans(const double *quat, double mat[3][3]);

  // rotation operations

  inline void rotation_generator_x(const double m[3][3], double ans[3][3]);
  inline void rotation_generator_y(const double m[3][3], double ans[3][3]);
  inline void rotation_generator_z(const double m[3][3], double ans[3][3]);
  
  void BuildRxMatrix(double R[3][3], const double angle);
  void BuildRyMatrix(double R[3][3], const double angle);
  void BuildRzMatrix(double R[3][3], const double angle);

  // moment of inertia operations

  void inertia_ellipsoid(double *shape, double *quat, double mass,
                         double *inertia);
  void inertia_line(double length, double theta, double mass,
                    double *inertia);
  void inertia_triangle(double *v0, double *v1, double *v2,
                        double mass, double *inertia);
  void inertia_triangle(double *idiag, double *quat, double mass,
                        double *inertia);
}

/* ----------------------------------------------------------------------
   copy a vector, return in ans
------------------------------------------------------------------------- */

inline void MathExtra::copy3(const double *v, double *ans)
{
  ans[0] = v[0];
  ans[1] = v[1];
  ans[2] = v[2];
}

/* ----------------------------------------------------------------------
   set vector equal to zero
------------------------------------------------------------------------- */

inline void MathExtra::zero3(double *v)
{
  v[0] = 0.0;
  v[1] = 0.0;
  v[2] = 0.0;
}

/* ----------------------------------------------------------------------
   normalize a vector in place
------------------------------------------------------------------------- */

inline void MathExtra::norm3(double *v)
{
  double scale = 1.0/sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  v[0] *= scale;
  v[1] *= scale;
  v[2] *= scale;
}

/* ----------------------------------------------------------------------
   normalize a vector, return in ans
------------------------------------------------------------------------- */

inline void MathExtra::normalize3(const double *v, double *ans)
{
  double scale = 1.0/sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  ans[0] = v[0]*scale;
  ans[1] = v[1]*scale;
  ans[2] = v[2]*scale;
}

/* ----------------------------------------------------------------------
   scale a vector to length
------------------------------------------------------------------------- */

inline void MathExtra::snormalize3(const double length, const double *v, 
                                   double *ans)
{
  double scale = length/sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);
  ans[0] = v[0]*scale;
  ans[1] = v[1]*scale;
  ans[2] = v[2]*scale;
}

/* ----------------------------------------------------------------------
   negate vector v
------------------------------------------------------------------------- */

inline void MathExtra::negate3(double *v)
{
  v[0] = -v[0];
  v[1] = -v[1];
  v[2] = -v[2];
}

/* ----------------------------------------------------------------------
   scale vector v by s
------------------------------------------------------------------------- */

inline void MathExtra::scale3(double s, double *v)
{
  v[0] *= s;
  v[1] *= s;
  v[2] *= s;
}

/* ----------------------------------------------------------------------
   ans = v1 + v2
------------------------------------------------------------------------- */

inline void MathExtra::add3(const double *v1, const double *v2, double *ans)
{
  ans[0] = v1[0] + v2[0];
  ans[1] = v1[1] + v2[1];
  ans[2] = v1[2] + v2[2];
}

/* ----------------------------------------------------------------------
   ans = s*v1 + v2
------------------------------------------------------------------------- */

inline void MathExtra::scaleadd3(double s, const double *v1, 
                                 const double *v2, double *ans)
{
  ans[0] = s*v1[0] + v2[0];
  ans[1] = s*v1[1] + v2[1];
  ans[2] = s*v1[2] + v2[2];
}

/* ----------------------------------------------------------------------
   ans = v1 - v2
------------------------------------------------------------------------- */

inline void MathExtra::sub3(const double *v1, const double *v2, double *ans)
{
  ans[0] = v1[0] - v2[0];
  ans[1] = v1[1] - v2[1];
  ans[2] = v1[2] - v2[2];
}

/* ----------------------------------------------------------------------
   length of vector v
------------------------------------------------------------------------- */

inline double MathExtra::len3(const double *v)
{
  return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
}

/* ----------------------------------------------------------------------
   squared length of vector v, or dot product of v with itself
------------------------------------------------------------------------- */

inline double MathExtra::lensq3(const double *v)
{
  return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
}

/* ----------------------------------------------------------------------
   ans = distance squared between pts v1 and v2
------------------------------------------------------------------------- */

inline double MathExtra::distsq3(const double *v1, const double *v2)
{
  double dx = v1[0] - v2[0];
  double dy = v1[1] - v2[1];
  double dz = v1[2] - v2[2];
  return dx*dx + dy*dy + dz*dz;
}

/* ----------------------------------------------------------------------
   dot product of 2 vectors
------------------------------------------------------------------------- */

inline double MathExtra::dot3(const double *v1, const double *v2)
{
  return v1[0]*v2[0]+v1[1]*v2[1]+v1[2]*v2[2];
}

/* ----------------------------------------------------------------------
   cross product of 2 vectors
------------------------------------------------------------------------- */

inline void MathExtra::cross3(const double *v1, const double *v2, double *ans)
{
  ans[0] = v1[1]*v2[2] - v1[2]*v2[1];
  ans[1] = v1[2]*v2[0] - v1[0]*v2[2];
  ans[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

/* ----------------------------------------------------------------------
   construct matrix from 3 column vectors
------------------------------------------------------------------------- */

void MathExtra::col2mat(const double *ex, const double *ey, const double *ez,
                        double m[3][3])
{
  m[0][0] = ex[0];
  m[1][0] = ex[1];
  m[2][0] = ex[2];
  m[0][1] = ey[0];
  m[1][1] = ey[1];
  m[2][1] = ey[2];
  m[0][2] = ez[0];
  m[1][2] = ez[1];
  m[2][2] = ez[2];
}

/* ----------------------------------------------------------------------
   determinant of a matrix
------------------------------------------------------------------------- */

inline double MathExtra::det3(const double m[3][3])
{
  double ans = m[0][0]*m[1][1]*m[2][2] - m[0][0]*m[1][2]*m[2][1] -
    m[1][0]*m[0][1]*m[2][2] + m[1][0]*m[0][2]*m[2][1] +
    m[2][0]*m[0][1]*m[1][2] - m[2][0]*m[0][2]*m[1][1];
  return ans;
}

/* ----------------------------------------------------------------------
   diagonal matrix times a full matrix
------------------------------------------------------------------------- */

inline void MathExtra::diag_times3(const double *d, const double m[3][3],
                                   double ans[3][3])
{
  ans[0][0] = d[0]*m[0][0];
  ans[0][1] = d[0]*m[0][1];
  ans[0][2] = d[0]*m[0][2];
  ans[1][0] = d[1]*m[1][0];
  ans[1][1] = d[1]*m[1][1];
  ans[1][2] = d[1]*m[1][2];
  ans[2][0] = d[2]*m[2][0];
  ans[2][1] = d[2]*m[2][1];
  ans[2][2] = d[2]*m[2][2];
}

/* ----------------------------------------------------------------------
   full matrix times a diagonal matrix
------------------------------------------------------------------------- */

void MathExtra::times3_diag(const double m[3][3], const double *d,
                            double ans[3][3])
{
  ans[0][0] = m[0][0]*d[0];
  ans[0][1] = m[0][1]*d[1];
  ans[0][2] = m[0][2]*d[2];
  ans[1][0] = m[1][0]*d[0];
  ans[1][1] = m[1][1]*d[1];
  ans[1][2] = m[1][2]*d[2];
  ans[2][0] = m[2][0]*d[0];
  ans[2][1] = m[2][1]*d[1];
  ans[2][2] = m[2][2]*d[2];
}

/* ----------------------------------------------------------------------
   add two matrices
------------------------------------------------------------------------- */

inline void MathExtra::plus3(const double m[3][3], const double m2[3][3],
                             double ans[3][3])
{
  ans[0][0] = m[0][0]+m2[0][0];
  ans[0][1] = m[0][1]+m2[0][1];
  ans[0][2] = m[0][2]+m2[0][2];
  ans[1][0] = m[1][0]+m2[1][0];
  ans[1][1] = m[1][1]+m2[1][1];
  ans[1][2] = m[1][2]+m2[1][2];
  ans[2][0] = m[2][0]+m2[2][0];
  ans[2][1] = m[2][1]+m2[2][1];
  ans[2][2] = m[2][2]+m2[2][2];
}

/* ----------------------------------------------------------------------
   multiply mat1 times mat2
------------------------------------------------------------------------- */

inline void MathExtra::times3(const double m[3][3], const double m2[3][3],
                              double ans[3][3])
{
  ans[0][0] = m[0][0]*m2[0][0] + m[0][1]*m2[1][0] + m[0][2]*m2[2][0];
  ans[0][1] = m[0][0]*m2[0][1] + m[0][1]*m2[1][1] + m[0][2]*m2[2][1];
  ans[0][2] = m[0][0]*m2[0][2] + m[0][1]*m2[1][2] + m[0][2]*m2[2][2];
  ans[1][0] = m[1][0]*m2[0][0] + m[1][1]*m2[1][0] + m[1][2]*m2[2][0];
  ans[1][1] = m[1][0]*m2[0][1] + m[1][1]*m2[1][1] + m[1][2]*m2[2][1];
  ans[1][2] = m[1][0]*m2[0][2] + m[1][1]*m2[1][2] + m[1][2]*m2[2][2];
  ans[2][0] = m[2][0]*m2[0][0] + m[2][1]*m2[1][0] + m[2][2]*m2[2][0];
  ans[2][1] = m[2][0]*m2[0][1] + m[2][1]*m2[1][1] + m[2][2]*m2[2][1];
  ans[2][2] = m[2][0]*m2[0][2] + m[2][1]*m2[1][2] + m[2][2]*m2[2][2];
}

/* ----------------------------------------------------------------------
   multiply the transpose of mat1 times mat2
------------------------------------------------------------------------- */

inline void MathExtra::transpose_times3(const double m[3][3], 
                                        const double m2[3][3],double ans[3][3])
{
  ans[0][0] = m[0][0]*m2[0][0] + m[1][0]*m2[1][0] + m[2][0]*m2[2][0];
  ans[0][1] = m[0][0]*m2[0][1] + m[1][0]*m2[1][1] + m[2][0]*m2[2][1];
  ans[0][2] = m[0][0]*m2[0][2] + m[1][0]*m2[1][2] + m[2][0]*m2[2][2];
  ans[1][0] = m[0][1]*m2[0][0] + m[1][1]*m2[1][0] + m[2][1]*m2[2][0];
  ans[1][1] = m[0][1]*m2[0][1] + m[1][1]*m2[1][1] + m[2][1]*m2[2][1];
  ans[1][2] = m[0][1]*m2[0][2] + m[1][1]*m2[1][2] + m[2][1]*m2[2][2];
  ans[2][0] = m[0][2]*m2[0][0] + m[1][2]*m2[1][0] + m[2][2]*m2[2][0];
  ans[2][1] = m[0][2]*m2[0][1] + m[1][2]*m2[1][1] + m[2][2]*m2[2][1];
  ans[2][2] = m[0][2]*m2[0][2] + m[1][2]*m2[1][2] + m[2][2]*m2[2][2];
}

/* ----------------------------------------------------------------------
   multiply mat1 times transpose of mat2
------------------------------------------------------------------------- */

inline void MathExtra::times3_transpose(const double m[3][3], 
                                        const double m2[3][3],double ans[3][3])
{
  ans[0][0] = m[0][0]*m2[0][0] + m[0][1]*m2[0][1] + m[0][2]*m2[0][2];
  ans[0][1] = m[0][0]*m2[1][0] + m[0][1]*m2[1][1] + m[0][2]*m2[1][2];
  ans[0][2] = m[0][0]*m2[2][0] + m[0][1]*m2[2][1] + m[0][2]*m2[2][2];
  ans[1][0] = m[1][0]*m2[0][0] + m[1][1]*m2[0][1] + m[1][2]*m2[0][2];
  ans[1][1] = m[1][0]*m2[1][0] + m[1][1]*m2[1][1] + m[1][2]*m2[1][2];
  ans[1][2] = m[1][0]*m2[2][0] + m[1][1]*m2[2][1] + m[1][2]*m2[2][2];
  ans[2][0] = m[2][0]*m2[0][0] + m[2][1]*m2[0][1] + m[2][2]*m2[0][2];
  ans[2][1] = m[2][0]*m2[1][0] + m[2][1]*m2[1][1] + m[2][2]*m2[1][2];
  ans[2][2] = m[2][0]*m2[2][0] + m[2][1]*m2[2][1] + m[2][2]*m2[2][2];
}

/* ----------------------------------------------------------------------
   invert a matrix
   does NOT check for singular or badly scaled matrix
------------------------------------------------------------------------- */

inline void MathExtra::invert3(const double m[3][3], double ans[3][3])
{
  double den = m[0][0]*m[1][1]*m[2][2]-m[0][0]*m[1][2]*m[2][1];
  den += -m[1][0]*m[0][1]*m[2][2]+m[1][0]*m[0][2]*m[2][1];
  den += m[2][0]*m[0][1]*m[1][2]-m[2][0]*m[0][2]*m[1][1];

  ans[0][0] = (m[1][1]*m[2][2]-m[1][2]*m[2][1]) / den;
  ans[0][1] = -(m[0][1]*m[2][2]-m[0][2]*m[2][1]) / den;
  ans[0][2] = (m[0][1]*m[1][2]-m[0][2]*m[1][1]) / den;
  ans[1][0] = -(m[1][0]*m[2][2]-m[1][2]*m[2][0]) / den;
  ans[1][1] = (m[0][0]*m[2][2]-m[0][2]*m[2][0]) / den;
  ans[1][2] = -(m[0][0]*m[1][2]-m[0][2]*m[1][0]) / den;
  ans[2][0] = (m[1][0]*m[2][1]-m[1][1]*m[2][0]) / den;
  ans[2][1] = -(m[0][0]*m[2][1]-m[0][1]*m[2][0]) / den;
  ans[2][2] = (m[0][0]*m[1][1]-m[0][1]*m[1][0]) / den;
}

/* ----------------------------------------------------------------------
   matrix times vector
------------------------------------------------------------------------- */

inline void MathExtra::matvec(const double m[3][3], const double *v, 
                              double *ans)
{
  ans[0] = m[0][0]*v[0] + m[0][1]*v[1] + m[0][2]*v[2];
  ans[1] = m[1][0]*v[0] + m[1][1]*v[1] + m[1][2]*v[2];
  ans[2] = m[2][0]*v[0] + m[2][1]*v[1] + m[2][2]*v[2];
}

/* ----------------------------------------------------------------------
   matrix times vector
------------------------------------------------------------------------- */

inline void MathExtra::matvec(const double *ex, const double *ey, 
                              const double *ez, const double *v, double *ans)
{
  ans[0] = ex[0]*v[0] + ey[0]*v[1] + ez[0]*v[2];
  ans[1] = ex[1]*v[0] + ey[1]*v[1] + ez[1]*v[2];
  ans[2] = ex[2]*v[0] + ey[2]*v[1] + ez[2]*v[2];
}

/* ----------------------------------------------------------------------
   transposed matrix times vector
------------------------------------------------------------------------- */

inline void MathExtra::transpose_matvec(const double m[3][3], const double *v,
                                 double *ans)
{
  ans[0] = m[0][0]*v[0] + m[1][0]*v[1] + m[2][0]*v[2];
  ans[1] = m[0][1]*v[0] + m[1][1]*v[1] + m[2][1]*v[2];
  ans[2] = m[0][2]*v[0] + m[1][2]*v[1] + m[2][2]*v[2];
}

/* ----------------------------------------------------------------------
   transposed matrix times vector
------------------------------------------------------------------------- */

inline void MathExtra::transpose_matvec(const double *ex, const double *ey,
                                 const double *ez, const double *v,
                                 double *ans)
{
  ans[0] = ex[0]*v[0] + ex[1]*v[1] + ex[2]*v[2];
  ans[1] = ey[0]*v[0] + ey[1]*v[1] + ey[2]*v[2];
  ans[2] = ez[0]*v[0] + ez[1]*v[1] + ez[2]*v[2];
}

/* ----------------------------------------------------------------------
   transposed matrix times diagonal matrix
------------------------------------------------------------------------- */

inline void MathExtra::transpose_diag3(const double m[3][3], const double *d,
                                double ans[3][3])
{
  ans[0][0] = m[0][0]*d[0];
  ans[0][1] = m[1][0]*d[1];
  ans[0][2] = m[2][0]*d[2];
  ans[1][0] = m[0][1]*d[0];
  ans[1][1] = m[1][1]*d[1];
  ans[1][2] = m[2][1]*d[2];
  ans[2][0] = m[0][2]*d[0];
  ans[2][1] = m[1][2]*d[1];
  ans[2][2] = m[2][2]*d[2];
}

/* ----------------------------------------------------------------------
   row vector times matrix
------------------------------------------------------------------------- */

inline void MathExtra::vecmat(const double *v, const double m[3][3], 
                              double *ans)
{
  ans[0] = v[0]*m[0][0] + v[1]*m[1][0] + v[2]*m[2][0];
  ans[1] = v[0]*m[0][1] + v[1]*m[1][1] + v[2]*m[2][1];
  ans[2] = v[0]*m[0][2] + v[1]*m[1][2] + v[2]*m[2][2];
}

/* ----------------------------------------------------------------------
   matrix times scalar, in place
------------------------------------------------------------------------- */

inline void MathExtra::scalar_times3(const double f, double m[3][3])
{
  m[0][0] *= f; m[0][1] *= f; m[0][2] *= f;
  m[1][0] *= f; m[1][1] *= f; m[1][2] *= f;
  m[2][0] *= f; m[2][1] *= f; m[2][2] *= f;
}

/* ----------------------------------------------------------------------
   multiply 2 shape matrices
   upper-triangular 3x3, stored as 6-vector in Voigt notation
------------------------------------------------------------------------- */

inline void MathExtra::multiply_shape_shape(const double *one, 
                                            const double *two, double *ans)
{
  ans[0] = one[0]*two[0];
  ans[1] = one[1]*two[1];
  ans[2] = one[2]*two[2];
  ans[3] = one[1]*two[3] + one[3]*two[2];
  ans[4] = one[0]*two[4] + one[5]*two[3] + one[4]*two[2];
  ans[5] = one[0]*two[5] + one[5]*two[1];
}

/* ----------------------------------------------------------------------
   normalize a quaternion
------------------------------------------------------------------------- */

inline void MathExtra::qnormalize(double *q)
{
  double norm = 1.0 / sqrt(q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
  q[0] *= norm;
  q[1] *= norm;
  q[2] *= norm;
  q[3] *= norm;
}

/* ----------------------------------------------------------------------
   conjugate of a quaternion: qc = conjugate of q
   assume q is of unit length
------------------------------------------------------------------------- */

inline void MathExtra::qconjugate(double *q, double *qc)
{
  qc[0] = q[0];
  qc[1] = -q[1];
  qc[2] = -q[2];
  qc[3] = -q[3];
}

/* ----------------------------------------------------------------------
   vector-quaternion multiply: c = a*b, where a = (0,a)
------------------------------------------------------------------------- */

inline void MathExtra::vecquat(double *a, double *b, double *c)
{
  c[0] = -a[0]*b[1] - a[1]*b[2] - a[2]*b[3];
  c[1] = b[0]*a[0] + a[1]*b[3] - a[2]*b[2];
  c[2] = b[0]*a[1] + a[2]*b[1] - a[0]*b[3];
  c[3] = b[0]*a[2] + a[0]*b[2] - a[1]*b[1];
}

/* ----------------------------------------------------------------------
   quaternion-vector multiply: c = a*b, where b = (0,b)
------------------------------------------------------------------------- */

inline void MathExtra::quatvec(double *a, double *b, double *c)
{
  c[0] = -a[1]*b[0] - a[2]*b[1] - a[3]*b[2];
  c[1] = a[0]*b[0] + a[2]*b[2] - a[3]*b[1];
  c[2] = a[0]*b[1] + a[3]*b[0] - a[1]*b[2];
  c[3] = a[0]*b[2] + a[1]*b[1] - a[2]*b[0];
}

/* ----------------------------------------------------------------------
   quaternion-quaternion multiply: c = a*b
------------------------------------------------------------------------- */

inline void MathExtra::quatquat(double *a, double *b, double *c)
{
  c[0] = a[0]*b[0] - a[1]*b[1] - a[2]*b[2] - a[3]*b[3];
  c[1] = a[0]*b[1] + b[0]*a[1] + a[2]*b[3] - a[3]*b[2];
  c[2] = a[0]*b[2] + b[0]*a[2] + a[3]*b[1] - a[1]*b[3];
  c[3] = a[0]*b[3] + b[0]*a[3] + a[1]*b[2] - a[2]*b[1];
}

/* ----------------------------------------------------------------------
   quaternion multiply: c = inv(a)*b
   a is a quaternion
   b is a four component vector
   c is a three component vector
------------------------------------------------------------------------- */

inline void MathExtra::invquatvec(double *a, double *b, double *c)
{
  c[0] = -a[1]*b[0] + a[0]*b[1] + a[3]*b[2] - a[2]*b[3];
  c[1] = -a[2]*b[0] - a[3]*b[1] + a[0]*b[2] + a[1]*b[3];
  c[2] = -a[3]*b[0] + a[2]*b[1] - a[1]*b[2] + a[0]*b[3];
}

/* ----------------------------------------------------------------------
   compute quaternion from axis-angle rotation
   v MUST be a unit vector
------------------------------------------------------------------------- */

inline void MathExtra::axisangle_to_quat(const double *v, const double angle,
                                         double *quat)
{
  double halfa = 0.5*angle;
  double sina = sin(halfa);
  quat[0] = cos(halfa);
  quat[1] = v[0]*sina;
  quat[2] = v[1]*sina;
  quat[3] = v[2]*sina;
}

/* ----------------------------------------------------------------------
   Apply principal rotation generator about x to rotation matrix m
------------------------------------------------------------------------- */

inline void MathExtra::rotation_generator_x(const double m[3][3], 
                                            double ans[3][3])
{
  ans[0][0] = 0;
  ans[0][1] = -m[0][2];
  ans[0][2] = m[0][1];
  ans[1][0] = 0;
  ans[1][1] = -m[1][2];
  ans[1][2] = m[1][1];
  ans[2][0] = 0;
  ans[2][1] = -m[2][2];
  ans[2][2] = m[2][1];
}

/* ----------------------------------------------------------------------
   Apply principal rotation generator about y to rotation matrix m
------------------------------------------------------------------------- */

inline void MathExtra::rotation_generator_y(const double m[3][3], 
                                            double ans[3][3])
{
  ans[0][0] = m[0][2];
  ans[0][1] = 0;
  ans[0][2] = -m[0][0];
  ans[1][0] = m[1][2];
  ans[1][1] = 0;
  ans[1][2] = -m[1][0];
  ans[2][0] = m[2][2];
  ans[2][1] = 0;
  ans[2][2] = -m[2][0];
}

/* ----------------------------------------------------------------------
   Apply principal rotation generator about z to rotation matrix m
------------------------------------------------------------------------- */

inline void MathExtra::rotation_generator_z(const double m[3][3], 
                                            double ans[3][3])
{
  ans[0][0] = -m[0][1];
  ans[0][1] = m[0][0];
  ans[0][2] = 0;
  ans[1][0] = -m[1][1];
  ans[1][1] = m[1][0];
  ans[1][2] = 0;
  ans[2][0] = -m[2][1];
  ans[2][1] = m[2][0];
  ans[2][2] = 0;
}

#endif


---

# modules_binning.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Include Module header files for binning
#include <binning_kksort.h>


---

# modules_comm.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Include Module header files for comm
#ifdef EXAMINIMD_ENABLE_MPI
#include <comm_mpi.h>
#endif
#include <comm_serial.h>


---

# modules_force.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Include Module header files for force
#include<Kokkos_Macros.hpp>
#include <force_lj_cell.h>
#include <force_lj_neigh.h>
#include <force_lj_idial_neigh.h>
#ifndef KOKKOS_ENABLE_OPENMPTARGET
#include <force_snap_neigh.h>
#endif


---

# modules_integrator.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Include Module header files for integrator
#include <integrator_nve.h>


---

# modules_neighbor.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Include Module header files for neighbor
#include <neighbor_2d.h>
#include <neighbor_csr.h>
#include <neighbor_csr_map_constr.h>


---

# modules_property.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Include Module header files for property
#include <property_temperature.h>
#include <property_kine.h>
#include <property_pote.h>


---

# neighbor.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <neighbor.h>

Neighbor::Neighbor():neigh_type(NEIGH_NONE) {}

Neighbor::~Neighbor() {};

void Neighbor::init(T_X_FLOAT neighcut) {};

void Neighbor::create_neigh_list(System* system, Binning* binning, bool half_neigh_ , bool ghost_neighs_) {};

Neighbor::t_neigh_list Neighbor::get_neigh_list() { return Neighbor::t_neigh_list(); };

const char* Neighbor::name() {return "NeighborNone";}



---

# neighbor.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef NEIGHBOR_H
#define NEIGHBOR_H
#include <types.h>
#include <system.h>
#include <binning.h>

class Neighbor {
public:
  int neigh_type;
  bool comm_newton;
  Neighbor();
  virtual ~Neighbor();
  typedef Kokkos::View<int**> t_neigh_list;
  virtual void init(T_X_FLOAT neighcut);
  virtual void create_neigh_list(System* system, Binning* binning, bool half_neigh_, bool ghost_neighs_);
  t_neigh_list get_neigh_list();
  virtual const char* name();
};

template<int Type>
struct NeighborAdaptor {
  typedef Neighbor type;
};

#include <modules_neighbor.h>

#endif


---

# property_kine.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <property_kine.h>

KinE::KinE(Comm* comm_):comm(comm_) {}

T_V_FLOAT KinE::compute(System* system) {
  v = system->v;
  mass = system->mass;
  type = system->type;

  T_V_FLOAT KE; 
  Kokkos::parallel_reduce(Kokkos::RangePolicy<Kokkos::IndexType<T_INT>>(0,system->N_local), *this, KE);

  // Make sure I don't carry around references to data
  v = t_v();
  mass = t_mass();
  type = t_type();

  // Multiply by scaling factor (units based) to get to kinetic energy
  T_V_FLOAT factor = 0.5 * system->mvv2e;

  comm->reduce_float(&KE,1);
  return KE * factor;
}


---

# property_kine.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************


#include <types.h>
#include <system.h>
#include <comm.h>

class KinE {
  private:
    t_v v;
    t_mass mass;
    t_type type;
    Comm* comm;
  public:
    KinE(Comm* comm_);

    T_V_FLOAT compute(System*);
    
    KOKKOS_INLINE_FUNCTION
    void operator() (const T_INT& i, T_V_FLOAT& KE) const {
      KE += (v(i,0)*v(i,0) + v(i,1)*v(i,1) + v(i,2)*v(i,2)) * mass(type(i));
    }
};


---

# property_pote.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <examinimd.h>
#include <property_pote.h>

PotE::PotE(Comm* comm_):comm(comm_) {}

T_F_FLOAT PotE::compute(System* system, Binning* binning, Neighbor* neighbor, Force* force) {
  T_F_FLOAT PE; 
  PE = force->compute_energy(system,binning,neighbor);
  comm->reduce_float(&PE,1);
  return PE;
}


---

# property_pote.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <types.h>
#include <system.h>
#include <comm.h>

class PotE {
  private:
    Comm* comm;
  public:
    PotE(Comm* comm_);

    T_F_FLOAT compute(System*, Binning*, Neighbor*, Force*);
};


---

# property_temperature.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <property_temperature.h>

Temperature::Temperature(Comm* comm_):comm(comm_) {}

T_V_FLOAT Temperature::compute(System* system) {
  v = system->v;
  mass = system->mass;
  type = system->type;

  T_V_FLOAT T; 
  Kokkos::parallel_reduce(Kokkos::RangePolicy<Kokkos::IndexType<T_INT>>(0,system->N_local), *this, T);

  // Make sure I don't carry around references to data
  v = t_v();
  mass = t_mass();
  type = t_type();

  // Multiply by scaling factor (units based) to get to temperature
  T_INT dof = 3 * system->N - 3;
  T_V_FLOAT factor = system->mvv2e / (1.0 * dof * system->boltz);

  comm->reduce_float(&T,1);
  return T * factor;
}


---

# property_temperature.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <types.h>
#include <system.h>
#include <comm.h>

class Temperature {
  private:
    t_v v;
    t_mass mass;
    t_type type;
    Comm* comm;
  public:
    Temperature(Comm* comm_);

    T_V_FLOAT compute(System*);
    
    KOKKOS_INLINE_FUNCTION
    void operator() (const T_INT& i, T_V_FLOAT& T) const {
      T += (v(i,0)*v(i,0) + v(i,1)*v(i,1) + v(i,2)*v(i,2)) * mass(type(i));
    }
};


---

# system.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<system.h>
#ifdef EXAMINIMD_ENABLE_MPI
#include<mpi.h>
#endif
System::System() {
  N = 0;
  N_max = 0;
  N_local = 0;
  N_ghost = 0;
  ntypes = 1;
  x = t_x();
  v = t_v();
  f = t_f();
  id = t_id();
  type = t_type();
  q = t_q();
  mass = t_mass();
  domain_x = domain_y = domain_z = 0.0;
  sub_domain_x = sub_domain_y = sub_domain_z = 0.0;
  sub_domain_hi_x = sub_domain_hi_y = sub_domain_hi_z = 0.0;
  sub_domain_lo_x = sub_domain_lo_y = sub_domain_lo_z = 0.0;
  mvv2e = boltz = dt = 0.0;
#ifdef EXAMINIMD_ENABLE_MPI
  int proc_rank;
  MPI_Comm_rank(MPI_COMM_WORLD, &proc_rank);
  do_print = proc_rank == 0;
#else
  do_print = true;
#endif
  print_lammps = false;
}

void System::init() {
  x = t_x("System::x",N_max);
  v = t_v("System::v",N_max);
  f = t_f("System::f",N_max);
  id = t_id("System::id",N_max);
  type = t_type("System::type",N_max);
  q = t_q("System::q",N_max);
  mass = t_mass("System::mass",ntypes);
}

void System::destroy() {
  N_max = 0;
  N_local = 0;
  N_ghost = 0;
  ntypes = 1;
  x = t_x();
  v = t_v();
  f = t_f();
  id = t_id();
  type = t_type();
  q = t_q();
  mass = t_mass();
}

void System::grow(T_INT N_new) {
  if(N_new > N_max) {
    N_max = N_new; // Number of global Particles

    Kokkos::resize(x,N_max);      // Positions
    Kokkos::resize(v,N_max);      // Velocities
    Kokkos::resize(f,N_max);      // Forces

    Kokkos::resize(id,N_max);     // Id

    Kokkos::resize(type,N_max);   // Particle Type

    Kokkos::resize(q,N_max);      // Charge
  }
}

void System::print_particles() {
  printf("Print all particles: \n");
  printf("  Owned: %d\n",N_local);
  for(T_INT i=0;i<N_local;i++) {
    printf("    %d %lf %lf %lf | %lf %lf %lf | %lf %lf %lf | %d %e\n",i,
        double(x(i,0)),double(x(i,1)),double(x(i,2)),
        double(v(i,0)),double(v(i,1)),double(v(i,2)),
        double(f(i,0)),double(f(i,1)),double(f(i,2)),
        type(i),q(i)
        );
  }

  printf("  Ghost: %d\n",N_ghost);
  for(T_INT i=N_local;i<N_local+N_ghost;i++) {
    printf("    %d %lf %lf %lf | %lf %lf %lf | %lf %lf %lf | %d %e\n",i,
        double(x(i,0)),double(x(i,1)),double(x(i,2)),
        double(v(i,0)),double(v(i,1)),double(v(i,2)),
        double(f(i,0)),double(f(i,1)),double(f(i,2)),
        type(i),q(i)
        );
  }

}


---

# system.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef SYSTEM_H
#define SYSTEM_H
#include<types.h>

struct Particle {
  KOKKOS_INLINE_FUNCTION
  Particle() {
    x=y=z=vx=vy=vz=mass=q=0.0;
    id = type = 0;
  }

  T_X_FLOAT x,y,z;
  T_V_FLOAT vx,vy,vz,mass;
  T_FLOAT q;
  T_INT id;
  int type;
};

class System {
public:
  T_INT N;       // Number of Global Particles
  T_INT N_max;   // Number of Particles I could have in available storage
  T_INT N_local; // Number of owned Particles
  T_INT N_ghost; // Number of non-owned Particles

  int ntypes;

  // Per Particle Property
  t_x x;         // Positions
  t_v v;         // Velocities
  t_f f;         // Forces

  t_type type;   // Particle Type
  t_id   id;     // Particle ID
    
  t_q q;         // Charge

  // Per Type Property
  t_mass mass;

  // Simulation domain
  T_X_FLOAT domain_x, domain_y, domain_z;

  // Simulation sub domain (for example of a single MPI rank)
  T_X_FLOAT sub_domain_x, sub_domain_y, sub_domain_z;
  T_X_FLOAT sub_domain_lo_x, sub_domain_lo_y, sub_domain_lo_z;
  T_X_FLOAT sub_domain_hi_x, sub_domain_hi_y, sub_domain_hi_z;

  // Units
  T_FLOAT boltz,mvv2e,dt;

  // Should this process print messages
  bool do_print;
  // Should print LAMMPS style messages
  bool print_lammps;

  System();
  ~System() {};
  void init();
  void destroy();

  void grow(T_INT new_N);

  KOKKOS_INLINE_FUNCTION
  Particle get_particle(const T_INT& i) const {
    Particle p;
    p.x  = x(i,0); p.y  = x(i,1); p.z  = x(i,2);
    p.vx = v(i,0); p.vy = v(i,1); p.vz = v(i,2);
    p.q = q(i);
    p.id = id(i);
    p.type = type(i);
    return p;
  }

  KOKKOS_INLINE_FUNCTION
  void set_particle(const T_INT& i, const Particle& p) const {
    x(i,0) = p.x;  x(i,1) = p.y;  x(i,2) = p.z;
    v(i,0) = p.vx; v(i,1) = p.vy; v(i,2) = p.vz;
    q(i) = p.q;
    id(i) = p.id;
    type(i) = p.type;
  }

  KOKKOS_INLINE_FUNCTION
  void copy(T_INT dest, T_INT src, int nx, int ny, int nz) const {
    x(dest,0) = x(src,0) + domain_x * nx;
    x(dest,1) = x(src,1) + domain_y * ny;
    x(dest,2) = x(src,2) + domain_z * nz;
    v(dest,0) = v(src,0);
    v(dest,1) = v(src,1);
    v(dest,2) = v(src,2);
    type(dest) = type(src);
    id(dest) = id(src);
    q(dest) = q(src);
  }

  KOKKOS_INLINE_FUNCTION
  void copy_halo_update(T_INT dest, T_INT src, int nx, int ny, int nz) const {
    x(dest,0) = x(src,0) + domain_x * nx;
    x(dest,1) = x(src,1) + domain_y * ny;
    x(dest,2) = x(src,2) + domain_z * nz;
  }

  void print_particles();
};
#endif


---

# types.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef TYPES_H
#define TYPES_H
#include<Kokkos_Core.hpp>

// Module Types etc
// Units to be used
enum {UNITS_REAL,UNITS_LJ,UNITS_METAL};
// Lattice Type
enum {LATTICE_SC,LATTICE_FCC};
// Integrator Type
enum {INTEGRATOR_NVE};
// Binning Type
enum {BINNING_KKSORT};
// Comm Type
enum {COMM_SERIAL,COMM_MPI};
// Force Type
enum {FORCE_LJ, FORCE_LJ_IDIAL, FORCE_SNAP};
// Force Iteration Type
enum {FORCE_ITER_CELL_FULL, FORCE_ITER_NEIGH_FULL, FORCE_ITER_NEIGH_HALF};
// Neighbor Type
enum {NEIGH_NONE, NEIGH_CSR, NEIGH_CSR_MAPCONSTR, NEIGH_2D};
// Input File Type
enum {INPUT_LAMMPS};

// Macros to work around the fact that std::max/min is not available on GPUs
#define MAX(a,b) (a>b?a:b)
#define MIN(a,b) (a<b?a:b)

#define MAX_TYPES_STACKPARAMS 12

// Define Scalar Types
#ifndef T_INT
#define T_INT int
#endif

#ifndef T_FLOAT
#define T_FLOAT double
#endif
#ifndef T_X_FLOAT
#define T_X_FLOAT T_FLOAT
#endif
#ifndef T_V_FLOAT
#define T_V_FLOAT T_FLOAT
#endif
#ifndef T_F_FLOAT
#define T_F_FLOAT T_FLOAT
#endif

// Define Kokkos View Types
typedef Kokkos::View<T_X_FLOAT*[3],Kokkos::LayoutRight>       t_x;          // Positions
typedef Kokkos::View<const T_X_FLOAT*[3],Kokkos::LayoutRight> t_x_const;    // Positions
typedef Kokkos::View<const T_X_FLOAT*[3],Kokkos::LayoutRight,
    Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_x_const_rnd;    // Positions
typedef Kokkos::View<T_V_FLOAT*[3]>       t_v;          // Velocities
typedef Kokkos::View<T_F_FLOAT*[3]>       t_f;          // Force
typedef Kokkos::View<T_F_FLOAT*[3],
#ifdef KOKKOS_ENABLE_SERIAL
    Kokkos::MemoryTraits<std::is_same<Kokkos::DefaultExecutionSpace,Kokkos::Serial>::value?0:Kokkos::Atomic>>
#else
    Kokkos::MemoryTraits<Kokkos::Atomic>>
#endif
        t_f_atomic;   // Force
typedef Kokkos::View<const T_F_FLOAT*[3]> t_f_const;    // Force

typedef Kokkos::View<int*>                t_type;       // Type (int is enough as type)
typedef Kokkos::View<const int*>          t_type_const; // Type (int is enough as type)
typedef Kokkos::View<const int*,
    Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_type_const_rnd; // Type (int is enough as type)
typedef Kokkos::View<T_INT*>              t_id;         // ID
typedef Kokkos::View<const T_INT*>        t_id_const;   // ID
typedef Kokkos::View<T_FLOAT*>            t_q;          // Charge
typedef Kokkos::View<const T_FLOAT*>      t_q_const;    // Charge

typedef Kokkos::View<T_V_FLOAT*>          t_mass;       // Mass
typedef Kokkos::View<const T_V_FLOAT*>    t_mass_const; // Mass

typedef Kokkos::DefaultExecutionSpace::memory_space t_neigh_mem_space;

template<class Scalar>
struct t_scalar3 {
  Scalar x,y,z;

  KOKKOS_FORCEINLINE_FUNCTION
  t_scalar3() {
    x = 0; y = 0; z = 0;
  }

  KOKKOS_FORCEINLINE_FUNCTION
  t_scalar3(const t_scalar3& rhs) {
    x = rhs.x; y = rhs.y; z = rhs.z;
  }

  KOKKOS_FORCEINLINE_FUNCTION
  t_scalar3(const Scalar& x_, const Scalar& y_, const Scalar& z_ ) {
    x = x_; y = y_; z = z_;
  }

  KOKKOS_FORCEINLINE_FUNCTION
  t_scalar3 operator= (const t_scalar3& rhs) {
    x = rhs.x; y = rhs.y; z = rhs.z;
    return *this;
  }

  KOKKOS_FORCEINLINE_FUNCTION
  t_scalar3 operator= (const volatile t_scalar3& rhs) {
    x = rhs.x; y = rhs.y; z = rhs.z;
    return *this;
  }

  KOKKOS_FORCEINLINE_FUNCTION
  t_scalar3 operator+= (const t_scalar3& rhs) {
    x += rhs.x; y += rhs.y; z += rhs.z;
    return *this;
  }

  KOKKOS_FORCEINLINE_FUNCTION
  t_scalar3 operator+= (const volatile t_scalar3& rhs) volatile {
    x += rhs.x; y += rhs.y; z += rhs.z;
    return *this;
  }
};

template<class Scalar>
KOKKOS_FORCEINLINE_FUNCTION
t_scalar3<Scalar> operator +
  (const t_scalar3<Scalar>& a, const t_scalar3<Scalar>& b) {
  return t_scalar3<Scalar>(a.x+b.x,a.y+b.y,a.z+b.z);
}

template<class Scalar>
KOKKOS_FORCEINLINE_FUNCTION
t_scalar3<Scalar> operator *
  (const t_scalar3<Scalar>& a, const Scalar& b) {
  return t_scalar3<Scalar>(a.x*b,a.y*b,a.z*b);
}

template<class Scalar>
KOKKOS_FORCEINLINE_FUNCTION
t_scalar3<Scalar> operator *
  (const Scalar& b, const t_scalar3<Scalar>& a) {
  return t_scalar3<Scalar>(a.x*b,a.y*b,a.z*b);
}

#if defined(KOKKOS_ENABLE_CUDA) || defined(KOKKOS_ENABLE_HIP) || defined(KOKKOS_ENABLE_OPENMPTARGET) || defined(KOKKOS_ENABLE_SYCL)
#define EMD_ENABLE_GPU
#endif

#endif



---

# binning_kksort.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<binning_kksort.h>

BinningKKSort::BinningKKSort(System* s): Binning(s) {}

namespace {
  //This needs to be multi dimensional Range Policy later
  template<class BinCount1D, class BinOffsets1D, class BinCount3D, class BinOffsets3D>
  struct BinningKKSort_AssignOffsets {
    BinCount1D bin_count_1d;
    BinOffsets1D bin_offsets_1d;
    BinCount3D bin_count_3d;
    BinOffsets3D bin_offsets_3d;

    T_INT nbinx,nbiny,nbinz;
    BinningKKSort_AssignOffsets(BinCount1D bc1d, BinOffsets1D bo1d, 
                                BinCount3D bc3d, BinOffsets3D bo3d,
                                T_INT nx, T_INT ny, T_INT nz):
            bin_count_1d(bc1d),bin_offsets_1d(bo1d),bin_count_3d(bc3d),bin_offsets_3d(bo3d),
            nbinx(nx),nbiny(ny),nbinz(nz) {}

    KOKKOS_INLINE_FUNCTION
    void operator() (const T_INT& i) const {
      T_INT ix = i/(nbiny*nbinz);
      T_INT iy = (i/nbinz)%nbiny;
      T_INT iz = i%nbinz;

      bin_offsets_3d(ix,iy,iz) = bin_offsets_1d(i);
      bin_count_3d(ix,iy,iz) = bin_count_1d(i);
    }
  };
}

void BinningKKSort::create_binning(T_X_FLOAT dx_in, T_X_FLOAT dy_in, T_X_FLOAT dz_in, int halo_depth, bool do_local, bool do_ghost, bool sort) {
  if(do_local||do_ghost) {
    nhalo = halo_depth;
    std::pair<T_INT,T_INT> range(do_local?0:system->N_local,
                                 do_ghost?system->N_local+system->N_ghost:system->N_local);

    nbinx = T_INT(system->sub_domain_x/dx_in);
    nbiny = T_INT(system->sub_domain_y/dy_in);
    nbinz = T_INT(system->sub_domain_z/dz_in);

    if(nbinx == 0) nbinx = 1;
    if(nbiny == 0) nbiny = 1;
    if(nbinz == 0) nbinz = 1;

    T_X_FLOAT dx = system->sub_domain_x/nbinx;
    T_X_FLOAT dy = system->sub_domain_y/nbiny;
    T_X_FLOAT dz = system->sub_domain_z/nbinz;

    nbinx += 2*halo_depth;
    nbiny += 2*halo_depth;
    nbinz += 2*halo_depth;

    T_X_FLOAT eps = dx/1000;
    minx = -dx * halo_depth - eps + system->sub_domain_lo_x;
    maxx =  dx * halo_depth + eps + system->sub_domain_hi_x;
    miny = -dy * halo_depth - eps + system->sub_domain_lo_y;
    maxy =  dy * halo_depth + eps + system->sub_domain_hi_y;
    minz = -dz * halo_depth - eps + system->sub_domain_lo_z;
    maxz =  dz * halo_depth + eps + system->sub_domain_hi_z;

    T_INT nbin[3] = {nbinx,nbiny,nbinz};
    T_X_FLOAT min[3] = {minx,miny,minz};
    T_X_FLOAT max[3] = {maxx,maxy,maxz};

    t_binop binop(nbin,min,max);

    auto x = Kokkos::subview(system->x,range,Kokkos::ALL);

    sorter = t_sorter(x,binop);

    sorter.create_permute_vector();

    permute_vector = sorter.get_permute_vector();

    typename t_sorter::bin_count_type bin_count_1d = sorter.get_bin_count();
    typename t_sorter::offset_type bin_offsets_1d = sorter.get_bin_offsets();

    bincount = t_bincount("Binning::bincount",nbinx,nbiny,nbinz);
    binoffsets = t_binoffsets("Binning::binoffsets",nbinx,nbiny,nbinz);

    Kokkos::parallel_for("Binning::AssignOffsets",nbinx*nbiny*nbinz,
                    BinningKKSort_AssignOffsets<t_sorter::bin_count_type,t_sorter::offset_type,
                                                t_bincount, t_binoffsets>(bin_count_1d,bin_offsets_1d,
                                                                          bincount,binoffsets,
                                                                          nbinx,nbiny,nbinz));
    if(sort) {
      sorter.sort(x);
      auto v = Kokkos::subview(system->v,range,Kokkos::ALL);
      sorter.sort(v);
      auto f = Kokkos::subview(system->f,range,Kokkos::ALL);
      sorter.sort(f);
      t_type type(system->type,range);
      sorter.sort(type);
      t_id id(system->id,range);
      sorter.sort(id);
      t_q q(system->q,range);
      sorter.sort(q);
    }
  }
}

const char* BinningKKSort::name() { return "BinningKKSort"; }



---

# binning_kksort.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef BINNING_KKSORT_H
#define BINNING_KKSORT_H
#include<binning.h>
#include<Kokkos_Sort.hpp>

class BinningKKSort: public Binning {
  typedef Kokkos::BinOp3D<t_x_const> t_binop;
  typedef Kokkos::BinSort<t_x_const,t_binop,Kokkos::DefaultExecutionSpace,T_INT> t_sorter;
  t_sorter sorter;

public:
  BinningKKSort(System* s);
  void create_binning(T_X_FLOAT dx, T_X_FLOAT dy, T_X_FLOAT dz, int halo_depth, bool do_local, bool do_ghost, bool sort);
  const char* name();
};
#endif


---

# CMakeLists.txt

SET(HEADERS
  binning_kksort.h)

SET(SOURCES
  binning_kksort.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# CMakeLists.txt

SET(HEADERS
  comm_mpi.h
  comm_serial.h)

SET(SOURCES
  comm_mpi.cpp
  comm_serial.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# comm_mpi.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef EXAMINIMD_ENABLE_MPI
#include<comm_mpi.h>

CommMPI::CommMPI(System* s, T_X_FLOAT comm_depth):Comm(s,comm_depth) {
  pack_count = Kokkos::View<int>("CommMPI::pack_count");
  pack_buffer = Kokkos::View<Particle*>("CommMPI::pack_buffer",200);
  unpack_buffer = Kokkos::View<Particle*>("CommMPI::pack_buffer",200);
  pack_indicies_all = Kokkos::View<T_INT**,Kokkos::LayoutRight>("CommMPI::pack_indicies_all",6,200);
  exchange_dest_list = Kokkos::View<T_INT*,Kokkos::LayoutRight >("CommMPI::exchange_dest_list",200);
}

void CommMPI::init() {};

void CommMPI::create_domain_decomposition() {

  //printf("Domain b: %p %lf %lf %lf\n",system,system->domain_x ,system->domain_y ,system->domain_z);

  MPI_Comm_size(MPI_COMM_WORLD, &proc_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &proc_rank);
  int ipx = 1;

  double area_xy = system->domain_x * system->domain_y;
  double area_xz = system->domain_x * system->domain_z;
  double area_yz = system->domain_y * system->domain_z;

  double smallest_surface = 2.0 * (area_xy + area_xz + area_yz);

  while(ipx <= proc_size) {
    if(proc_size % ipx == 0) {
      int nremain = proc_size / ipx;
      int ipy = 1;

      while(ipy <= nremain) {
        if(nremain % ipy == 0) {
          int ipz = nremain / ipy;
          double surface = area_xy / ipx / ipy + area_xz / ipx / ipz + area_yz / ipy / ipz;

          if(surface < smallest_surface) {
            smallest_surface = surface;
            proc_grid[0] = ipx;
            proc_grid[1] = ipy;
            proc_grid[2] = ipz;
          }
        }

        ipy++;
      }
    }

    ipx++;
  }
  proc_pos[2] = proc_rank / (proc_grid[0] * proc_grid[1]);
  proc_pos[1] = (proc_rank % (proc_grid[0] * proc_grid[1])) / proc_grid[0];
  proc_pos[0] = proc_rank % proc_grid[0];

  if(proc_grid[0]>1) {
    proc_neighbors_send[1] = ( proc_pos[0] > 0 )                ? proc_rank - 1 :
                                                                proc_rank + (proc_grid[0]-1);
    proc_neighbors_send[0] = ( proc_pos[0] < (proc_grid[0]-1) ) ? proc_rank + 1 :
                                                                proc_rank - (proc_grid[0]-1);

  } else {
    proc_neighbors_send[0] = -1;
    proc_neighbors_send[1] = -1;
  }

  if(proc_grid[1]>1) {
    proc_neighbors_send[3] = ( proc_pos[1] > 0 )                ? proc_rank - proc_grid[0] :
                                                                proc_rank + proc_grid[0]*(proc_grid[1]-1);
    proc_neighbors_send[2] = ( proc_pos[1] < (proc_grid[1]-1) ) ? proc_rank + proc_grid[0] :
                                                                proc_rank - proc_grid[0]*(proc_grid[1]-1);
  } else {
    proc_neighbors_send[2] = -1;
    proc_neighbors_send[3] = -1;
  }

  if(proc_grid[2]>1) {
    proc_neighbors_send[5] = ( proc_pos[2] > 0 )                ? proc_rank - proc_grid[0]*proc_grid[1] :
                                                                proc_rank + proc_grid[0]*proc_grid[1]*(proc_grid[2]-1);
    proc_neighbors_send[4] = ( proc_pos[2] < (proc_grid[2]-1) ) ? proc_rank + proc_grid[0]*proc_grid[1] :
                                                                proc_rank - proc_grid[0]*proc_grid[1]*(proc_grid[2]-1);
  } else {
    proc_neighbors_send[4] = -1;
    proc_neighbors_send[5] = -1;
  }

  proc_neighbors_recv[0] = proc_neighbors_send[1];
  proc_neighbors_recv[1] = proc_neighbors_send[0];
  proc_neighbors_recv[2] = proc_neighbors_send[3];
  proc_neighbors_recv[3] = proc_neighbors_send[2];
  proc_neighbors_recv[4] = proc_neighbors_send[5];
  proc_neighbors_recv[5] = proc_neighbors_send[4];

  system->sub_domain_x = system->domain_x / proc_grid[0];
  system->sub_domain_y = system->domain_y / proc_grid[1];
  system->sub_domain_z = system->domain_z / proc_grid[2];
  system->sub_domain_lo_x = proc_pos[0] * system->sub_domain_x;
  system->sub_domain_lo_y = proc_pos[1] * system->sub_domain_y;
  system->sub_domain_lo_z = proc_pos[2] * system->sub_domain_z;
  system->sub_domain_hi_x = ( proc_pos[0] + 1 ) * system->sub_domain_x;
  system->sub_domain_hi_y = ( proc_pos[1] + 1 ) * system->sub_domain_y;
  system->sub_domain_hi_z = ( proc_pos[2] + 1 ) * system->sub_domain_z;

  /*printf("MyRank: %i MyPos: %i %i %i Grid: %i %i %i Neighbors: %i %i , %i %i , %i %i\n",proc_rank,proc_pos[0],
      proc_pos[1],proc_pos[2],proc_grid[0],proc_grid[1],proc_grid[2],
      proc_neighbors_send[0],proc_neighbors_send[1],
      proc_neighbors_send[2],proc_neighbors_send[3],
      proc_neighbors_send[4],proc_neighbors_send[5]);*/
}


void CommMPI::scan_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Scan(MPI_IN_PLACE,vals,count,MPI_INT,MPI_SUM,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_INT,MPI_SUM,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_float(T_FLOAT* vals, T_INT count) {
  if(std::is_same<T_FLOAT,double>::value) {
    // This generates MPI_ERR_BUFFER for count>1
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_max_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_INT,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_max_float(T_FLOAT* vals, T_INT count) {
  if(std::is_same<T_FLOAT,double>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_DOUBLE,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_min_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_INT,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_min_float(T_FLOAT* vals, T_INT count) {
  if(std::is_same<T_FLOAT,double>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_DOUBLE,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::exchange() {

  Kokkos::Profiling::pushRegion("Comm::exchange");

  s = *system;
  N_local = system->N_local;
  N_ghost = 0;
  //printf("System A: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));
  Kokkos::parallel_for("CommMPI::exchange_self",
            Kokkos::RangePolicy<TagExchangeSelf, Kokkos::IndexType<T_INT> >(0,N_local), *this);

  T_INT N_total_recv = 0;
  T_INT N_total_send = 0;

  //printf("System B: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));
  for(phase = 0; phase < 6; phase ++) {
    proc_num_send[phase] = 0;
    proc_num_recv[phase] = 0;
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    T_INT count = 0;
    Kokkos::deep_copy(pack_count,0);

    if(proc_grid[phase/2]>1) {
      Kokkos::parallel_for("CommMPI::exchange_pack",
                Kokkos::RangePolicy<TagExchangePack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost),
                *this);

      Kokkos::deep_copy(count,pack_count);
      if(count > pack_indicies.extent(0)) {
        Kokkos::realloc(pack_buffer,count*1.1);
        Kokkos::realloc(pack_indicies_all,6,count*1.1);
        pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
        Kokkos::deep_copy(pack_count,0);
        Kokkos::parallel_for("CommMPI::exchange_pack",
                  Kokkos::RangePolicy<TagExchangePack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost),
                  *this);
      }
      proc_num_send[phase] = count;
      if(pack_buffer.extent(0)<count)
        pack_buffer = Kokkos::View<Particle*>("Comm::pack_buffer",count);
      MPI_Request request;
      MPI_Irecv(&proc_num_recv[phase],1,MPI_INT, proc_neighbors_recv[phase],100001,MPI_COMM_WORLD,&request);
      MPI_Send(&proc_num_send[phase],1,MPI_INT, proc_neighbors_send[phase],100001,MPI_COMM_WORLD);
      MPI_Status status;
      MPI_Wait(&request,&status);
      count = proc_num_recv[phase];
      //printf("Recv Count: %i\n",count);
      if(unpack_buffer.extent(0)<count) {
        unpack_buffer = Kokkos::View<Particle*>("Comm::unpack_buffer",count);
      }
      if(proc_num_recv[phase]>0)
        MPI_Irecv(unpack_buffer.data(),proc_num_recv[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD,&request);
      if(proc_num_send[phase]>0)
        MPI_Send (pack_buffer.data(),proc_num_send[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD);
      system->grow(N_local + N_ghost + count);
      s = *system;
      if(proc_num_recv[phase]>0)
        MPI_Wait(&request,&status);
      Kokkos::parallel_for("CommMPI::exchange_unpack",
                Kokkos::RangePolicy<TagUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
                *this);

    }

    N_ghost += count;
    N_total_recv += proc_num_recv[phase];
    N_total_send += proc_num_send[phase];
  }
  T_INT N_local_start = N_local;
  T_INT N_exchange = N_ghost;
  //printf("System C: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));

  N_local = N_local + N_total_recv - N_total_send;
  N_ghost = N_local_start + N_exchange - N_local;

  if(exchange_dest_list.extent(0)<N_ghost)
    Kokkos::realloc(exchange_dest_list,N_ghost);

  //printf("ExchangeDestList: %i %i %i %i %i\n",exchange_dest_list.extent(0),N_ghost,N_total_recv,N_total_send,N_local);
  //printf("System: %i %i\n",s.N_local,system->N_local);
  Kokkos::parallel_scan("CommMPI::exchange_create_dest_list",
            Kokkos::RangePolicy<TagExchangeCreateDestList, Kokkos::IndexType<T_INT> >(0,N_local),
            *this);
  //printf("System D: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));
  Kokkos::parallel_scan("CommMPI::exchange_compact",
            Kokkos::RangePolicy<TagExchangeCompact, Kokkos::IndexType<T_INT> >(0,N_ghost),
            *this);
  //printf("System E: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));

  system->N_local = N_local;
  system->N_ghost = 0;
  /*for(int i=0;i<N_local;i++)
    if(s.type(i)<0) printf("Huch: %i %i\n",i,N_local);*/

  Kokkos::Profiling::popRegion();
};

void CommMPI::exchange_halo() {

  Kokkos::Profiling::pushRegion("Comm::exchange_halo");

  N_local = system->N_local;
  N_ghost = 0;

  s = *system;

  for(phase = 0; phase < 6; phase ++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    T_INT count = 0;
    Kokkos::deep_copy(pack_count,0);

    if(proc_grid[phase/2]>1) {
      Kokkos::parallel_for("CommMPI::halo_exchange_pack",
                Kokkos::RangePolicy<TagHaloPack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost - ( (phase%2==1) ? proc_num_recv[phase-1]:0)),
                *this);

      Kokkos::deep_copy(count,pack_count);
      if(count > pack_indicies.extent(0)) {
        Kokkos::realloc(pack_buffer,count*1.1);
        Kokkos::resize(pack_indicies_all,6,count*1.1);
        pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
        Kokkos::deep_copy(pack_count,0);
        Kokkos::parallel_for("CommMPI::halo_exchange_pack",
                  Kokkos::RangePolicy<TagHaloPack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost- ( (phase%2==1) ? proc_num_recv[phase-1]:0)),
                  *this);
      }
      proc_num_send[phase] = count;
      if(pack_buffer.extent(0)<count)
        pack_buffer = Kokkos::View<Particle*>("Comm::pack_buffer",count);
      MPI_Request request;
      MPI_Irecv(&proc_num_recv[phase],1,MPI_INT, proc_neighbors_recv[phase],100001,MPI_COMM_WORLD,&request);
      MPI_Send(&proc_num_send[phase],1,MPI_INT, proc_neighbors_send[phase],100001,MPI_COMM_WORLD);
      MPI_Status status;
      MPI_Wait(&request,&status);
      count = proc_num_recv[phase];
      if(unpack_buffer.extent(0)<count) {
        unpack_buffer = Kokkos::View<Particle*>("Comm::unpack_buffer",count);
      }
      MPI_Irecv(unpack_buffer.data(),proc_num_recv[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD,&request);
      MPI_Send (pack_buffer.data(),proc_num_send[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD);
      system->grow(N_local + N_ghost + count);
      s = *system;
      MPI_Wait(&request,&status);
      Kokkos::parallel_for("CommMPI::halo_exchange_unpack",
                Kokkos::RangePolicy<TagUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
                *this);

    } else {
      T_INT nparticles = N_local + N_ghost - ( (phase%2==1) ? proc_num_recv[phase-1]:0 );
      Kokkos::parallel_for("CommMPI::halo_exchange_self",
                Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
                *this);
      Kokkos::deep_copy(count,pack_count);
      bool redo = false;
      if(N_local+N_ghost+count>s.x.extent(0)) {
        system->grow(N_local + N_ghost + count);
        s = *system;
        redo = true;
      }
      if(count > pack_indicies.extent(0)) {
        Kokkos::realloc(pack_buffer,count*1.1);
        Kokkos::resize(pack_indicies_all,6,count*1.1);
        pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
        redo = true;
      }
      if(redo) {
        Kokkos::deep_copy(pack_count,0);
        Kokkos::parallel_for("CommMPI::halo_exchange_self",
                  Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
                  *this);
      }
      //printf("ExchangeHalo: %i %i %i %i\n",phase,count,pack_indicies_all.extent(1),pack_indicies.extent(0));
      proc_num_send[phase] = count;
      proc_num_recv[phase] = count;
    }

    num_ghost[phase] = count;
    N_ghost += count;
  }
  static int step = 0;
  step++;

  system->N_ghost = N_ghost;

  Kokkos::Profiling::popRegion();
};

void CommMPI::update_halo() {

  Kokkos::Profiling::pushRegion("Comm::update_halo");

  N_ghost = 0;
  s=*system;

  pack_buffer_update = t_buffer_update((T_X_FLOAT*)pack_buffer.data(),pack_indicies_all.extent(1));
  unpack_buffer_update = t_buffer_update((T_X_FLOAT*)unpack_buffer.data(),pack_indicies_all.extent(1));

  for(phase = 0; phase<6; phase++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
    if(proc_grid[phase/2]>1) {  
      
      Kokkos::parallel_for("CommMPI::halo_update_pack",
         Kokkos::RangePolicy<TagHaloUpdatePack, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
         *this);
      MPI_Request request;
      MPI_Status status;
      MPI_Irecv(unpack_buffer.data(),proc_num_recv[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD,&request);
      MPI_Send (pack_buffer.data(),proc_num_send[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD);
      s = *system;
      MPI_Wait(&request,&status);
      const int count = proc_num_recv[phase];
      if(unpack_buffer_update.extent(0)<count) {
        unpack_buffer_update = t_buffer_update((T_X_FLOAT*)unpack_buffer.data(),count);
      }
      Kokkos::parallel_for("CommMPI::halo_update_unpack",
                Kokkos::RangePolicy<TagHaloUpdateUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
                *this);

    } else {
      //printf("HaloUpdateCopy: %i %i %i\n",phase,proc_num_send[phase],pack_indicies.extent(0));
      Kokkos::parallel_for("CommMPI::halo_update_self",
        Kokkos::RangePolicy<TagHaloUpdateSelf, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
        *this);
    }
    N_ghost += proc_num_recv[phase];
  }

  Kokkos::Profiling::popRegion();
};

void CommMPI::update_force() {

  Kokkos::Profiling::pushRegion("Comm::update_force");

  N_ghost = 0;
  s=*system;

  ghost_offsets[0] = s.N_local;
  for(phase = 1; phase<6; phase++) {
    ghost_offsets[phase] = ghost_offsets[phase-1] + proc_num_recv[phase-1];
  }

  pack_buffer_update = t_buffer_update((T_X_FLOAT*)pack_buffer.data(),pack_indicies_all.extent(1));
  unpack_buffer_update = t_buffer_update((T_X_FLOAT*)unpack_buffer.data(),pack_indicies_all.extent(1));

  for(phase = 5; phase>=0; phase--) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
    if(proc_grid[phase/2]>1) {

      Kokkos::parallel_for("CommMPI::halo_force_pack",
         Kokkos::RangePolicy<TagHaloForcePack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
         *this);
      MPI_Request request;
      MPI_Status status;
      MPI_Irecv(pack_buffer.data(),proc_num_send[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD,&request);
      MPI_Send (unpack_buffer.data(),proc_num_recv[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD);
      s = *system;
      MPI_Wait(&request,&status);
      Kokkos::parallel_for("CommMPI::halo_force_unpack",
                Kokkos::RangePolicy<TagHaloForceUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
                *this);

    } else {
      //printf("HaloUpdateCopy: %i %i %i\n",phase,proc_num_send[phase],pack_indicies.extent(0));
      Kokkos::parallel_for("CommMPI::halo_force_self",
        Kokkos::RangePolicy<TagHaloForceSelf, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
        *this);
    }
  }

  Kokkos::Profiling::popRegion();
};

const char* CommMPI::name() { return "CommMPI"; }

int CommMPI::process_rank() { return proc_rank; }
int CommMPI::num_processes() { return proc_size; }
void CommMPI::error(const char *errormsg) {
  if(proc_rank==0)
  printf("%s\n",errormsg);
  MPI_Abort(MPI_COMM_WORLD,1);
};
#endif


---

# comm_mpi.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
   if( (strcmp(argv[i+1], "MPI") == 0) )
     comm_type = COMM_MPI;
#endif
#ifdef COMM_MODULES_INSTANTIATION
   else if(input->comm_type == COMM_MPI) {
     comm = new CommMPI(system,input->force_cutoff + input->neighbor_skin);
   }
#endif


#if !defined(MODULES_OPTION_CHECK) && !defined(COMM_MODULES_INSTANTIATION)
#ifndef COMM_MPI_H
#define COMM_MPI_H
#include<comm.h>

#ifndef EXAMINIMD_ENABLE_MPI
#error "Trying to compile CommMPI without MPI"
#endif

#include "mpi.h"

class CommMPI: public Comm {

  // Variables Comm doesn't own but requires for computations

  T_INT N_local;
  T_INT N_ghost;

  System s;

  // Owned Variables

  int phase; // Communication Phase
  int proc_neighbors_recv[6]; // Neighbor for each phase
  int proc_neighbors_send[6]; // Neighbor for each phase
  int proc_num_recv[6];  // Number of received particles in each phase
  int proc_num_send[6];  // Number of send particles in each phase
  int proc_pos[3];       // My process position
  int proc_grid[3];      // Process Grid size
  int proc_rank;         // My Process rank
  int proc_size;         // Number of processes

  T_INT num_ghost[6];
  T_INT ghost_offsets[6];

  T_INT num_packed;
  Kokkos::View<int, Kokkos::MemoryTraits<Kokkos::Atomic> > pack_count;
  Kokkos::View<Particle*> pack_buffer;
  Kokkos::View<Particle*> unpack_buffer;
  typedef Kokkos::View<T_X_FLOAT*[3], Kokkos::LayoutRight, Kokkos::MemoryTraits<Kokkos::Unmanaged>> t_buffer_update;
  t_buffer_update pack_buffer_update;
  t_buffer_update unpack_buffer_update;

  Kokkos::View<T_INT**,Kokkos::LayoutRight> pack_indicies_all;
  Kokkos::View<T_INT*,Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Unmanaged> > pack_indicies;
  Kokkos::View<T_INT*,Kokkos::LayoutRight > exchange_dest_list;

public:

  struct TagUnpack {};

  struct TagExchangeSelf {};
  struct TagExchangePack {};
  struct TagExchangeCreateDestList {};
  struct TagExchangeCompact {};
  
  struct TagHaloSelf {};
  struct TagHaloPack {};
  struct TagHaloUpdateSelf {};
  struct TagHaloUpdatePack {};
  struct TagHaloUpdateUnpack {};

  struct TagHaloForceSelf {};
  struct TagHaloForcePack {};
  struct TagHaloForceUnpack {};

  struct TagPermuteIndexList {};

  CommMPI(System* s, T_X_FLOAT comm_depth_);
  void init();
  void create_domain_decomposition();
  void permute_index_lists(Binning::t_permute_vector& permute_vector);
  void exchange();
  void exchange_halo();
  void update_halo();
  void update_force();
  void scan_int(T_INT* vals, T_INT count);
  void reduce_int(T_INT* vals, T_INT count);
  void reduce_float(T_FLOAT* vals, T_INT count);
  void reduce_max_int(T_INT* vals, T_INT count);
  void reduce_max_float(T_FLOAT* vals, T_INT count);
  void reduce_min_int(T_INT* vals, T_INT count);
  void reduce_min_float(T_FLOAT* vals, T_INT count);

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeSelf, 
                   const T_INT& i) const {
    if(proc_grid[0]==1) {
      const T_X_FLOAT x = s.x(i,0);
      if(x>s.domain_x) s.x(i,0) -= s.domain_x;
      if(x<0)          s.x(i,0) += s.domain_x;
    }
    if(proc_grid[1]==1) {
      const T_X_FLOAT y = s.x(i,1);
      if(y>s.domain_y) s.x(i,1) -= s.domain_y;
      if(y<0)          s.x(i,1) += s.domain_y;
    }
    if(proc_grid[2]==1) {
      const T_X_FLOAT z = s.x(i,2);
      if(z>s.domain_z) s.x(i,2) -= s.domain_z;
      if(z<0)          s.x(i,2) += s.domain_z;
    }   
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangePack, 
                   const T_INT& i) const {
    if(s.type(i)<0) return;
    if( (phase == 0) && (s.x(i,0)>s.sub_domain_hi_x)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i; 
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[0] == proc_grid[0]-1)
          p.x -= s.domain_x;
        pack_buffer(pack_idx) = p;
      }
    }  

    if( (phase == 1) && (s.x(i,0)<s.sub_domain_lo_x)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[0] == 0)
          p.x += s.domain_x;
        pack_buffer(pack_idx) = p;
      }
    }

    if( (phase == 2) && (s.x(i,1)>s.sub_domain_hi_y)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[1] == proc_grid[1]-1)
          p.y -= s.domain_y;
        pack_buffer(pack_idx) = p;
      }
    }
    if( (phase == 3) && (s.x(i,1)<s.sub_domain_lo_y)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[1] == 0)
          p.y += s.domain_y;
        pack_buffer(pack_idx) = p;
      }
    }

    if( (phase == 4) && (s.x(i,2)>s.sub_domain_hi_z)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[2] == proc_grid[2]-1)
          p.z -= s.domain_z;
        pack_buffer(pack_idx) = p;
      }
    }
    if( (phase == 5) && (s.x(i,2)<s.sub_domain_lo_z)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[2] == 0)
          p.z += s.domain_z;
        pack_buffer(pack_idx) = p;
      }
    }
  } 

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeCreateDestList,
                   const T_INT& i, T_INT& c, const bool final) const {
    if(s.type(i)<0) {
      if(final) {
        exchange_dest_list(c) = i;
      }
      c++;
    }
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeCompact,
                   const T_INT& ii, T_INT& c, const bool final) const {
    const T_INT i = N_local+N_ghost-1-ii;
    if(s.type(i)>=0) {
      if(final) {
        s.copy(exchange_dest_list(c),i,0,0,0);
      }
      c++;
    }
  }

  
  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloSelf,
                   const T_INT& i) const {
    if(phase == 0) {
      if( s.x(i,0)>=s.sub_domain_hi_x - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x -= s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 1) {
      if( s.x(i,0)<=s.sub_domain_lo_x + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x += s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 2) {
      if( s.x(i,1)>=s.sub_domain_hi_y - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y -= s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 3) {
      if( s.x(i,1)<=s.sub_domain_lo_y + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y += s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 4) {
      if( s.x(i,2)>=s.sub_domain_hi_z - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z -= s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 5) {
      if( s.x(i,2)<=s.sub_domain_lo_z + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z += s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }

  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloPack,
                   const T_INT& i) const {
    if(phase == 0) {
      if( s.x(i,0)>=s.sub_domain_hi_x - comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[0] == proc_grid[0]-1)
            p.x -= s.domain_x;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 1) {
      if( s.x(i,0)<=s.sub_domain_lo_x + comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[0] == 0)
            p.x += s.domain_x;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 2) {
      if( s.x(i,1)>=s.sub_domain_hi_y - comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[1] == proc_grid[1]-1)
            p.y -= s.domain_y;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 3) {
      if( s.x(i,1)<=s.sub_domain_lo_y + comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[1] == 0)
            p.y += s.domain_y;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 4) {
      if( s.x(i,2)>=s.sub_domain_hi_z - comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[2] == proc_grid[2]-1)
            p.z -= s.domain_z;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 5) {
      if( s.x(i,2)<=s.sub_domain_lo_z + comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[2] == 0)
            p.z += s.domain_z;
          pack_buffer(pack_idx) = p;
        }
      }
    }
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagUnpack,
                   const T_INT& i) const {
    s.set_particle(N_local+N_ghost+i, unpack_buffer(i));
  }


  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdateSelf,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_X_FLOAT x_i = s.x(i,0);
    T_X_FLOAT y_i = s.x(i,1);
    T_X_FLOAT z_i = s.x(i,2);

    switch (phase) {
      case 0: x_i -= s.domain_x; break;
      case 1: x_i += s.domain_x; break;
      case 2: y_i -= s.domain_y; break;
      case 3: y_i += s.domain_y; break;
      case 4: z_i -= s.domain_z; break;
      case 5: z_i += s.domain_z; break;
    }
    s.x(N_local + N_ghost + ii, 0) = x_i;
    s.x(N_local + N_ghost + ii, 1) = y_i;
    s.x(N_local + N_ghost + ii, 2) = z_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdatePack,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_X_FLOAT x_i = s.x(i,0);
    T_X_FLOAT y_i = s.x(i,1);
    T_X_FLOAT z_i = s.x(i,2);

    switch (phase) {
      case 0: if(proc_pos[0] == proc_grid[0]-1) x_i -= s.domain_x; break;
      case 1: if(proc_pos[0] == 0)              x_i += s.domain_x; break;
      case 2: if(proc_pos[1] == proc_grid[1]-1) y_i -= s.domain_y; break;
      case 3: if(proc_pos[1] == 0)              y_i += s.domain_y; break;
      case 4: if(proc_pos[2] == proc_grid[2]-1) z_i -= s.domain_z; break;
      case 5: if(proc_pos[2] == 0)              z_i += s.domain_z; break;
    }
    pack_buffer_update(ii, 0) = x_i;
    pack_buffer_update(ii, 1) = y_i;
    pack_buffer_update(ii, 2) = z_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdateUnpack,
                   const T_INT& ii) const {
    s.x(N_local + N_ghost + ii, 0) = unpack_buffer_update(ii, 0);
    s.x(N_local + N_ghost + ii, 1) = unpack_buffer_update(ii, 1);
    s.x(N_local + N_ghost + ii, 2) = unpack_buffer_update(ii, 2);
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForceSelf,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_F_FLOAT fx_i = s.f(ghost_offsets[phase] + ii,0);
    T_F_FLOAT fy_i = s.f(ghost_offsets[phase] + ii,1);
    T_F_FLOAT fz_i = s.f(ghost_offsets[phase] + ii,2);

    s.f(i, 0) += fx_i;
    s.f(i, 1) += fy_i;
    s.f(i, 2) += fz_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForcePack,
                   const T_INT& ii) const {

    T_F_FLOAT fx_i = s.f(ghost_offsets[phase] + ii,0);
    T_F_FLOAT fy_i = s.f(ghost_offsets[phase] + ii,1);
    T_F_FLOAT fz_i = s.f(ghost_offsets[phase] + ii,2);

    unpack_buffer_update(ii, 0) = fx_i;
    unpack_buffer_update(ii, 1) = fy_i;
    unpack_buffer_update(ii, 2) = fz_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForceUnpack,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);

    s.f(i, 0) += pack_buffer_update(ii, 0);
    s.f(i, 1) += pack_buffer_update(ii, 1);
    s.f(i, 2) += pack_buffer_update(ii, 2);
  }

  const char* name();
  int process_rank();
  int num_processes();
  void error(const char *);
};

#endif
#endif // MODULES_OPTION_CHECK



---

# comm_serial.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<comm_serial.h>

CommSerial::CommSerial(System* s, T_X_FLOAT comm_depth):Comm(s,comm_depth) {
  printf("CommSerial\n");
  pack_count = Kokkos::View<int>("CommSerial::pack_count");
  pack_indicies_all = Kokkos::View<T_INT**,Kokkos::LayoutRight>("CommSerial::pack_indicies_all",6,0);
}

void CommSerial::exchange() {
  s = *system;
  N_local = system->N_local;

  Kokkos::parallel_for("CommSerial::exchange_self",
            Kokkos::RangePolicy<TagExchangeSelf, Kokkos::IndexType<T_INT> >(0,N_local), *this);
};

void CommSerial::exchange_halo() {

  N_local = system->N_local;
  N_ghost = 0;

  s = *system;

  for(phase = 0; phase < 6; phase ++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    T_INT count = 0;
    Kokkos::deep_copy(pack_count,0);

    T_INT nparticles = N_local + N_ghost - ( (phase%2==1) ? num_ghost[phase-1]:0 );
    Kokkos::parallel_for("CommSerial::halo_exchange_self",
              Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
              *this);
    Kokkos::deep_copy(count,pack_count);
    bool redo = false;
    if(N_local+N_ghost+count>s.x.extent(0)) {
      system->grow(N_local + N_ghost + count);
      s = *system;
      redo = true;
    }
    if(count > pack_indicies.extent(0)) {
      Kokkos::resize(pack_indicies_all,6,count*1.1);
      pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
      redo = true;
    }
    if(redo) {
      Kokkos::deep_copy(pack_count,0);
      Kokkos::parallel_for("CommSerial::halo_exchange_self",
                Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
                *this);
    }

    num_ghost[phase] = count;

    N_ghost += count;
  }

  system->N_ghost = N_ghost;
};

void CommSerial::update_halo() {
  N_ghost = 0;
  s=*system;
  for(phase = 0; phase<6; phase++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    Kokkos::parallel_for("CommSerial::halo_update_self",
      Kokkos::RangePolicy<TagHaloUpdateSelf, Kokkos::IndexType<T_INT> >(0,num_ghost[phase]),
      *this);
    N_ghost += num_ghost[phase];
  }
};

void CommSerial::update_force() {
  //printf("Update Force\n");
  s=*system;
  ghost_offsets[0] = s.N_local;
  for(phase = 1; phase<6; phase++) {
    ghost_offsets[phase] = ghost_offsets[phase-1] + num_ghost[phase-1];
  }

  for(phase = 5; phase>=0; phase--) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    Kokkos::parallel_for("CommSerial::halo_force_self",
      Kokkos::RangePolicy<TagHaloForceSelf, Kokkos::IndexType<T_INT> >(0,num_ghost[phase]),
      *this);
  }
};

const char* CommSerial::name() { return "CommSerial"; }


---

# comm_serial.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "SERIAL") == 0) )
        comm_type = COMM_SERIAL;
#endif
#ifdef COMM_MODULES_INSTANTIATION
      else if(input->comm_type == COMM_SERIAL) {
        comm = new CommSerial(system,input->force_cutoff + input->neighbor_skin);
      }
#endif


#if !defined(MODULES_OPTION_CHECK) && !defined(COMM_MODULES_INSTANTIATION)
#ifndef COMM_SERIAL_H
#define COMM_SERIAL_H
#include<comm.h>

class CommSerial: public Comm {

  // Variables Comm doesn't own but requires for computations

  T_INT N_local;
  T_INT N_ghost;

  System s;

  // Owned Variables

  int phase; // Communication Phase
  T_INT num_ghost[6];

  T_INT ghost_offsets[6];

  T_INT num_packed;
  Kokkos::View<int, Kokkos::MemoryTraits<Kokkos::Atomic> > pack_count;

  Kokkos::View<T_INT**,Kokkos::LayoutRight> pack_indicies_all;
  Kokkos::View<T_INT*,Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Unmanaged> > pack_indicies;


public:

  struct TagUnpack {};

  struct TagExchangeSelf {};
  
  struct TagHaloSelf {};
  struct TagHaloUpdateSelf {};
  struct TagHaloForceSelf {};

  CommSerial(System* s, T_X_FLOAT comm_depth_);
  void exchange();
  void exchange_halo();
  void update_halo();
  void update_force();

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeSelf, 
                   const T_INT& i) const {
    const T_X_FLOAT x = s.x(i,0);
    if(x>s.domain_x) s.x(i,0) -= s.domain_x;
    if(x<0)          s.x(i,0) += s.domain_x;

    const T_X_FLOAT y = s.x(i,1);
    if(y>s.domain_y) s.x(i,1) -= s.domain_y;
    if(y<0)          s.x(i,1) += s.domain_y;

    const T_X_FLOAT z = s.x(i,2);
    if(z>s.domain_z) s.x(i,2) -= s.domain_z;
    if(z<0)          s.x(i,2) += s.domain_z;
  }


  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloSelf,
                   const T_INT& i) const {
    if(phase == 0) {
      if( s.x(i,0)>=s.sub_domain_hi_x - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x -= s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 1) {
      if( s.x(i,0)<=s.sub_domain_lo_x + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x += s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 2) {
      if( s.x(i,1)>=s.sub_domain_hi_y - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y -= s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 3) {
      if( s.x(i,1)<=s.sub_domain_lo_y + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y += s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 4) {
      if( s.x(i,2)>=s.sub_domain_hi_z - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z -= s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 5) {
      if( s.x(i,2)<=s.sub_domain_lo_z + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z += s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }

  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdateSelf,
                   const T_INT& i) const {

    Particle p = s.get_particle(pack_indicies(i));
    switch (phase) {
      case 0: p.x -= s.domain_x; break;
      case 1: p.x += s.domain_x; break;
      case 2: p.y -= s.domain_y; break;
      case 3: p.y += s.domain_y; break;
      case 4: p.z -= s.domain_z; break;
      case 5: p.z += s.domain_z; break;
    }
    s.set_particle(N_local + N_ghost + i, p);     
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForceSelf,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_F_FLOAT fx_i = s.f(ghost_offsets[phase] + ii,0);
    T_F_FLOAT fy_i = s.f(ghost_offsets[phase] + ii,1);
    T_F_FLOAT fz_i = s.f(ghost_offsets[phase] + ii,2);

    //printf("FORCESELF %i %i %i %lf %lf\n",i,ghost_offsets[phase] + ii,ghost_offsets[phase],s.f(i,0),fx_i);
    s.f(i, 0) += fx_i;
    s.f(i, 1) += fy_i;
    s.f(i, 2) += fz_i;

  }

  const char* name();
};
#endif
#endif // MODULES_OPTION_CHECK


---

# CMakeLists.txt

SET(HEADERS
  force_lj_cell.h
  force_lj_idial_neigh.h
  force_lj_idial_neigh_impl.h
  force_lj_neigh.h
  force_lj_neigh_impl.h
  force_snap_neigh.h
  force_snap_neigh_impl.h
  sna.h)

SET(SOURCES
  force_lj_cell.cpp
  force_lj_idial_neigh.cpp
  force_lj_neigh.cpp
  force_snap_neigh.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# force_lj_cell.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_cell.h>

ForceLJCell::ForceLJCell(char** args, System* system, bool half_neigh_):Force(args,system,half_neigh) {
  lj1 = t_fparams("ForceLJCell::lj1",system->ntypes,system->ntypes);
  lj2 = t_fparams("ForceLJCell::lj2",system->ntypes,system->ntypes);
  cutsq = t_fparams("ForceLJCell::cutsq",system->ntypes,system->ntypes);
}

void ForceLJCell::init_coeff(int nargs, char** args) {
  int one_based_type = 1;
  int t1 = atoi(args[1])-one_based_type;
  int t2 = atoi(args[2])-one_based_type;
  double eps = atof(args[3]);
  double sigma = atof(args[4]);
  double cut = atof(args[5]);

  lj1(t1,t2) = 48.0 * eps * pow(sigma,12.0);
  lj2(t1,t2) = 24.0 * eps * pow(sigma,6.0);
  lj1(t2,t1) = lj1(t1,t2);
  lj2(t2,t1) = lj2(t1,t2);
  cutsq(t1,t2) = cut*cut;
  cutsq(t2,t1) = cut*cut;
};

void ForceLJCell::compute(System* system, Binning* binning, Neighbor*) {
  x = system->x;
  f = system->f;
  id = system->id;
  type = system->type;
  N_local = system->N_local;


  static int step_i = 0;
  step = step_i;
  bin_count = binning->bincount;
  bin_offsets = binning->binoffsets;
  permute_vector = binning->permute_vector;

  nhalo = binning->nhalo;
  nbinx = binning->nbinx;
  nbiny = binning->nbiny;
  nbinz = binning->nbinz;

  Kokkos::deep_copy(f,0.0);
  T_INT nbins = nbinx*nbiny*nbinz;

  Kokkos::parallel_for("ForceLJCell::computer", t_policy(nbins,1,8), *this);

  step_i++;
  x = t_x();
  type = t_type();
  f = t_f();

}

T_F_FLOAT ForceLJCell::compute_energy(System* system, Binning* binning, Neighbor*) {
  x = system->x;
  id = system->id;
  type = system->type;
  N_local = system->N_local;

  bin_count = binning->bincount;
  bin_offsets = binning->binoffsets;
  permute_vector = binning->permute_vector;

  nhalo = binning->nhalo;
  nbinx = binning->nbinx;
  nbiny = binning->nbiny;
  nbinz = binning->nbinz;

  T_INT nbins = nbinx*nbiny*nbinz;
  T_F_FLOAT PE;
  Kokkos::parallel_reduce("ForceLJCell::compute_energy", t_policy_pe(nbins,1,8), *this, PE);

  x = t_x();
  id = t_id();
  type = t_type();

  return PE;
}

const char* ForceLJCell::name() { return "ForceLJCellFull"; }


---

# force_lj_cell.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "CELL_FULL") == 0) )
        force_iteration_type = FORCE_ITER_CELL_FULL;
#endif
#ifdef MODULES_INSTANTIATION
    else if ((input->force_type == FORCE_LJ) && (input->force_iteration_type == FORCE_ITER_CELL_FULL)){
      force = new ForceLJCell(input->input_data.words[input->force_line],system,false);
    }
#endif


#if !defined(MODULES_OPTION_CHECK) && !defined(MODULES_INSTANTIATION)

#ifndef FORCE_LJ_CELL_H
#define FORCE_LJ_CELL_H
#include<force.h>

class ForceLJCell: public Force {
private:
  t_x x;
  t_f f;
  t_id id;
  t_type type;
  Binning::t_bincount bin_count;
  Binning::t_binoffsets bin_offsets;
  Binning::t_permute_vector permute_vector;
  T_INT nbinx,nbiny,nbinz,nhalo;
  int N_local;
  int step;

  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  t_fparams lj1,lj2,cutsq;

public:
  struct TagCell {};
  struct TagCellPE {};

  typedef Kokkos::TeamPolicy<TagCell, Kokkos::IndexType<T_INT> > t_policy;
  typedef Kokkos::TeamPolicy<TagCellPE, Kokkos::IndexType<T_INT> > t_policy_pe;

  ForceLJCell (char** args, System* system, bool half_neigh);

  void init_coeff(int nargs, char** args);

  void compute(System* system, Binning* binning, Neighbor* );
  T_F_FLOAT compute_energy(System* system, Binning* binning, Neighbor* );

  KOKKOS_INLINE_FUNCTION
    void operator() (TagCell, const typename t_policy::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz);
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny;
    const T_INT bz = team.league_rank() % nbinz;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      t_scalar3<T_F_FLOAT> f_i;
      for(int bx_j = bx>0?bx-1:bx; bx_j < (bx+1<nbinx?bx+2:bx+1); bx_j++)
      for(int by_j = by>0?by-1:by; by_j < (by+1<nbiny?by+2:by+1); by_j++)
      for(int bz_j = bz>0?bz-1:bz; bz_j < (bz+1<nbinz?bz+2:bz+1); bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

        t_scalar3<T_F_FLOAT> f_i_tmp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&]
          (const T_INT bj, t_scalar3<T_F_FLOAT>& lf_i) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
          
          if((rsq < cutsq(type_i,type_j)) && (i!=j)) {
            T_F_FLOAT r2inv = 1.0/rsq;
            T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
            T_F_FLOAT fpair = (r6inv * (lj1(type_i,type_j)*r6inv - lj2(type_i,type_j))) * r2inv;
            lf_i.x += dx*fpair;
            lf_i.y += dy*fpair;
            lf_i.z += dz*fpair;
          }
        },f_i_tmp);
        f_i += f_i_tmp;
      }
      f(i,0) += f_i.x;
      f(i,1) += f_i.y;
      f(i,2) += f_i.z;
    });
  } 

  KOKKOS_INLINE_FUNCTION
  void operator() (TagCellPE, const typename t_policy_pe::member_type& team, T_F_FLOAT& PE_bi) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz);
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny;
    const T_INT bz = team.league_rank() % nbinz;
    const bool shift_flag = true;

    T_F_FLOAT PE_i;
    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_reduce(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&]
      (const int bi, T_F_FLOAT& PE_i) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx>0?bx-1:bx; bx_j < (bx+1<nbinx?bx+2:bx+1); bx_j++)
      for(int by_j = by>0?by-1:by; by_j < (by+1<nbiny?by+2:by+1); by_j++)
      for(int bz_j = bz>0?bz-1:bz; bz_j < (bz+1<nbinz?bz+2:bz+1); bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

        T_F_FLOAT PE_ibj;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&]
          (const T_INT bj, T_F_FLOAT& PE_ibj) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
          
          if((rsq < cutsq(type_i,type_j)) && (i!=j)) {
            T_F_FLOAT r2inv = 1.0/rsq;
            T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
            PE_ibj += 0.5*r6inv * (0.5*lj1(type_i,type_j)*r6inv - lj2(type_i,type_j)) / 6.0; // optimize later
            if (shift_flag) {
              T_F_FLOAT r2invc = 1.0/cutsq(type_i,type_j);
              T_F_FLOAT r6invc = r2invc*r2invc*r2invc;
              PE_ibj -= 0.5*r6invc * (0.5*lj1(type_i,type_j)*r6invc - lj2(type_i,type_j)) / 6.0; // optimize later
            }
          }
        },PE_ibj);
        PE_i += PE_ibj;
      }
      },PE_i);
    PE_bi += PE_i;
  }

  const char* name();
};
#endif
#endif


---

# force_lj_idial_neigh.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_idial_neigh_impl.h>
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJIDialNeigh<NeighType>
#define FORCE_MODULES_TEMPLATE
#include<modules_neighbor.h>
#undef FORCE_MODULES_TEMPLATE


---

# force_lj_idial_neigh.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "NEIGH_FULL") == 0) )
        force_iteration_type = FORCE_ITER_NEIGH_FULL;
      if( (strcmp(argv[i+1], "NEIGH_HALF") == 0) ) {
        force_iteration_type = FORCE_ITER_NEIGH_HALF;
      }
#endif
#ifdef FORCE_MODULES_INSTANTIATION
    else if (input->force_type == FORCE_LJ_IDIAL) {
      bool half_neigh = input->force_iteration_type == FORCE_ITER_NEIGH_HALF;
      switch ( input->neighbor_type ) {
        #define FORCETYPE_ALLOCATION_MACRO(NeighType)  ForceLJIDialNeigh<NeighType>(input->input_data.words[input->force_line],system,half_neigh)
        #include <modules_neighbor.h>
        #undef FORCETYPE_ALLOCATION_MACRO
      }
    }
#endif


#if !defined(MODULES_OPTION_CHECK) && \
    !defined(FORCE_MODULES_INSTANTIATION)

#ifndef FORCE_LJ_IDIAL_NEIGH_H
#define FORCE_LJ_IDIAL_NEIGH_H
#include<force.h>

template<class NeighborClass>
class ForceLJIDialNeigh: public Force {
private:
  int N_local;
  t_x_const_rnd x;
  t_f f;
  t_f_atomic f_a;
  t_id id;
  t_type_const_rnd type;
  Binning::t_bincount bin_count;
  Binning::t_binoffsets bin_offsets;
  T_INT nbinx,nbiny,nbinz,nhalo;
  int step;

  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  typedef Kokkos::View<const T_F_FLOAT**,
      Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_fparams_rnd;
  t_fparams lj1,lj2,cutsq,intensity;
  t_fparams_rnd rnd_lj1,rnd_lj2,rnd_cutsq,rnd_intensity;

  typedef typename NeighborClass::t_neigh_list t_neigh_list;
  t_neigh_list neigh_list;

public:
  struct TagFullNeigh {};
  struct TagHalfNeigh {};

  typedef Kokkos::RangePolicy<TagFullNeigh,Kokkos::IndexType<T_INT> > t_policy_full_neigh;
  typedef Kokkos::RangePolicy<TagHalfNeigh,Kokkos::IndexType<T_INT> > t_policy_half_neigh;

  ForceLJIDialNeigh (char** args, System* system, bool half_neigh_);

  void init_coeff(int nargs, char** args);

  void compute(System* system, Binning* binning, Neighbor* neighbor );

  KOKKOS_INLINE_FUNCTION
  void operator() (TagFullNeigh, const T_INT& i) const;

  KOKKOS_INLINE_FUNCTION
  void operator() (TagHalfNeigh, const T_INT& i) const;

  const char* name();
};

#define FORCE_MODULES_EXTERNAL_TEMPLATE
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJIDialNeigh<NeighType>
#include<modules_neighbor.h>
#undef FORCETYPE_DECLARE_TEMPLATE_MACRO
#undef FORCE_MODULES_EXTERNAL_TEMPLATE
#endif
#endif


---

# force_lj_idial_neigh_impl.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_idial_neigh.h>

template<class NeighborClass>
ForceLJIDialNeigh<NeighborClass>::ForceLJIDialNeigh(char** args, System* system, bool half_neigh_):Force(args,system,half_neigh_) {
  lj1 = t_fparams("ForceLJIDialNeigh::lj1",system->ntypes,system->ntypes);
  lj2 = t_fparams("ForceLJIDialNeigh::lj2",system->ntypes,system->ntypes);
  cutsq = t_fparams("ForceLJIDialNeigh::cutsq",system->ntypes,system->ntypes);
  intensity = t_fparams("ForceLJIDialNeigh::intensity",system->ntypes,system->ntypes);
}

template<class NeighborClass>
void ForceLJIDialNeigh<NeighborClass>::init_coeff(int nargs, char** args) {
  int one_based_type = 1;
  int t1 = atoi(args[1])-one_based_type;
  int t2 = atoi(args[2])-one_based_type;
  double eps = atof(args[3]);
  double sigma = atof(args[4]);
  double cut = atof(args[5]);
  int nrepeat = atoi(args[6]);

  t_fparams::HostMirror h_lj1 = Kokkos::create_mirror_view(lj1);
  t_fparams::HostMirror h_lj2 = Kokkos::create_mirror_view(lj2);
  t_fparams::HostMirror h_cutsq = Kokkos::create_mirror_view(cutsq);
  t_fparams::HostMirror h_intensity = Kokkos::create_mirror_view(intensity);
  Kokkos::deep_copy(h_lj1,lj1);
  Kokkos::deep_copy(h_lj2,lj2);
  Kokkos::deep_copy(h_cutsq,cutsq);
  Kokkos::deep_copy(h_intensity,intensity);

  h_lj1(t1,t2) = 48.0 * eps * pow(sigma,12.0);
  h_lj2(t1,t2) = 24.0 * eps * pow(sigma,6.0);
  h_lj1(t2,t1) = h_lj1(t1,t2);
  h_lj2(t2,t1) = h_lj2(t1,t2);
  h_cutsq(t1,t2) = cut*cut;
  h_cutsq(t2,t1) = cut*cut;
  h_intensity(t1,t2) = nrepeat;
  h_intensity(t2,t1) = nrepeat;

  Kokkos::deep_copy(lj1,h_lj1);
  Kokkos::deep_copy(lj2,h_lj2);
  Kokkos::deep_copy(cutsq,h_cutsq);
  Kokkos::deep_copy(intensity,h_intensity);

  rnd_lj1 = lj1;
  rnd_lj2 = lj2;
  rnd_cutsq = cutsq;
  rnd_intensity = intensity;
  step = 0;
};

template<class NeighborClass>
void ForceLJIDialNeigh<NeighborClass>::compute(System* system, Binning* binning, Neighbor* neighbor_ ) {
  // Set internal data handles
  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();

  N_local = system->N_local;
  x = system->x;
  f = system->f;
  f_a = system->f;
  type = system->type;
  if(half_neigh)
    Kokkos::parallel_for("ForceLJIDialNeigh::computer", t_policy_half_neigh(0, system->N_local), *this);
  else
    Kokkos::parallel_for("ForceLJIDialNeigh::computer", t_policy_full_neigh(0, system->N_local), *this);
  Kokkos::fence();

  // Reset internal data handles so we don't keep a reference count
  /*x = t_x();
  type = t_type();
  f = t_f();
  neigh_list = NeighborCSR<t_neigh_mem_space>::t_neigh_list();*/
  step++;
}

template<class NeighborClass>
const char* ForceLJIDialNeigh<NeighborClass>::name() { return half_neigh?"ForceLJIDialNeighHalf":"ForceLJIDialNeighFull"; }

template<class NeighborClass>
KOKKOS_INLINE_FUNCTION
void ForceLJIDialNeigh<NeighborClass>::operator() (TagFullNeigh, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;

//    printf("NUMNEIGHS: %i %i\n",i,num_neighs);
  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    if( rsq < rnd_cutsq(type_i,type_j) ) {
      //-----------------
      // This 'for' loop increases the computational intensity of the LJ force evaluation.
      // intensity(type_i,type_j) acts as an intensity dial.
      // Could/should we implement this as a 'kokkos:parallel_for' loop?
      //-----------------
      T_F_FLOAT fpair = 0;
      for(int repeat = 0; repeat < intensity(type_i,type_j); repeat++) {
        T_F_FLOAT r2inv = 1.0/rsq;
        T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
        fpair += (r6inv * (rnd_lj1(type_i,type_j)*r6inv
                - rnd_lj2(type_i,type_j))) * r2inv/intensity(type_i,type_j);
      }
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
    }
  }
  f(i,0) += fxi;
  f(i,1) += fyi;
  f(i,2) += fzi;

}

template<class NeighborClass>
KOKKOS_INLINE_FUNCTION
void ForceLJIDialNeigh<NeighborClass>::operator() (TagHalfNeigh, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;
//printf("NUMNEIGHS: %i %i\n",i,num_neighs);
  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    if( rsq < rnd_cutsq(type_i,type_j) ) {
      //-----------------
      // This 'for' loop increases the computational intensity of the LJ force evaluation.
      // intensity(type_i,type_j) acts as an intensity dial.
      // Could/should we implement this as a 'kokkos:parallel_for' loop?
      //-----------------
      T_F_FLOAT fpair = 0;
      for(int repeat = 0; repeat < intensity(type_i,type_j); repeat++) {
        T_F_FLOAT r2inv = 1.0/rsq;
        T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
        fpair += (r6inv * (rnd_lj1(type_i,type_j)*r6inv
                  - rnd_lj2(type_i,type_j))) * r2inv/intensity(type_i,type_j);
      }
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
      if(j<N_local) {
        f_a(j,0) -= dx*fpair;
        f_a(j,1) -= dy*fpair;
        f_a(j,2) -= dz*fpair;
      }
    }
  }
  f_a(i,0) += fxi;
  f_a(i,1) += fyi;
  f_a(i,2) += fzi;

}


---

# force_lj_neigh.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_neigh_impl.h>
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJNeigh<NeighType>
#define FORCE_MODULES_TEMPLATE
#include<modules_neighbor.h>
#undef FORCE_MODULES_TEMPLATE


---

# force_lj_neigh.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "NEIGH_FULL") == 0) )
        force_iteration_type = FORCE_ITER_NEIGH_FULL;
      if( (strcmp(argv[i+1], "NEIGH_HALF") == 0) ) {
        force_iteration_type = FORCE_ITER_NEIGH_HALF;
      }
#endif
#ifdef FORCE_MODULES_INSTANTIATION
    else if (input->force_type == FORCE_LJ) {
      bool half_neigh = input->force_iteration_type == FORCE_ITER_NEIGH_HALF;
      switch ( input->neighbor_type ) {
        #define FORCETYPE_ALLOCATION_MACRO(NeighType)  ForceLJNeigh<NeighType>(input->input_data.words[input->force_line],system,half_neigh)
        #include <modules_neighbor.h>
        #undef FORCETYPE_ALLOCATION_MACRO
      }
    }
#endif


#if !defined(MODULES_OPTION_CHECK) && \
    !defined(FORCE_MODULES_INSTANTIATION)

#ifndef FORCE_LJ_NEIGH_H
#define FORCE_LJ_NEIGH_H
#include<force.h>

template<class NeighborClass>
class ForceLJNeigh: public Force {
private:
  int N_local,ntypes;
  t_x_const_rnd x;
  t_f f;
  t_f_atomic f_a;
  t_id id;
  t_type_const_rnd type;
  Binning::t_bincount bin_count;
  Binning::t_binoffsets bin_offsets;
  T_INT nbinx,nbiny,nbinz,nhalo;
  int step;
  bool use_stackparams;

  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  typedef Kokkos::View<const T_F_FLOAT**,
      Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_fparams_rnd;
  t_fparams lj1,lj2,cutsq;
  t_fparams_rnd rnd_lj1,rnd_lj2,rnd_cutsq;

  T_F_FLOAT stack_lj1[MAX_TYPES_STACKPARAMS+1][MAX_TYPES_STACKPARAMS+1]; // hardwired space for 12 atom types
  T_F_FLOAT stack_lj2[MAX_TYPES_STACKPARAMS+1][MAX_TYPES_STACKPARAMS+1];
  T_F_FLOAT stack_cutsq[MAX_TYPES_STACKPARAMS+1][MAX_TYPES_STACKPARAMS+1];

  typedef typename NeighborClass::t_neigh_list t_neigh_list;
  t_neigh_list neigh_list;

public:
  typedef T_V_FLOAT value_type;

  template<bool STACKPARAMS>
  struct TagFullNeigh {};

  template<bool STACKPARAMS>
  struct TagHalfNeigh {};

  template<bool STACKPARAMS>
  struct TagFullNeighPE {};

  template<bool STACKPARAMS>
  struct TagHalfNeighPE {};

  typedef Kokkos::RangePolicy<TagFullNeigh<false>,Kokkos::IndexType<T_INT> > t_policy_full_neigh;
  typedef Kokkos::RangePolicy<TagHalfNeigh<false>,Kokkos::IndexType<T_INT> > t_policy_half_neigh;
  typedef Kokkos::RangePolicy<TagFullNeighPE<false>,Kokkos::IndexType<T_INT> > t_policy_full_neigh_pe;
  typedef Kokkos::RangePolicy<TagHalfNeighPE<false>,Kokkos::IndexType<T_INT> > t_policy_half_neigh_pe;

  typedef Kokkos::RangePolicy<TagFullNeigh<true>,Kokkos::IndexType<T_INT> > t_policy_full_neigh_stackparams;
  typedef Kokkos::RangePolicy<TagHalfNeigh<true>,Kokkos::IndexType<T_INT> > t_policy_half_neigh_stackparams;
  typedef Kokkos::RangePolicy<TagFullNeighPE<true>,Kokkos::IndexType<T_INT> > t_policy_full_neigh_pe_stackparams;
  typedef Kokkos::RangePolicy<TagHalfNeighPE<true>,Kokkos::IndexType<T_INT> > t_policy_half_neigh_pe_stackparams;

  ForceLJNeigh (char** args, System* system, bool half_neigh_);

  void init_coeff(int nargs, char** args);

  void compute(System* system, Binning* binning, Neighbor* neighbor );
  T_F_FLOAT compute_energy(System* system, Binning* binning, Neighbor* neighbor);

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagFullNeigh<STACKPARAMS>, const T_INT& i) const;

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagHalfNeigh<STACKPARAMS>, const T_INT& i) const;

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagFullNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const;

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagHalfNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const;

  const char* name();
};

#define FORCE_MODULES_EXTERNAL_TEMPLATE
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJNeigh<NeighType>
#include<modules_neighbor.h>
#undef FORCETYPE_DECLARE_TEMPLATE_MACRO
#undef FORCE_MODULES_EXTERNAL_TEMPLATE
#endif
#endif


---

# force_lj_neigh_impl.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_neigh.h>

template<class NeighborClass>
ForceLJNeigh<NeighborClass>::ForceLJNeigh(char** args, System* system, bool half_neigh_):Force(args,system,half_neigh_) {
  ntypes = system->ntypes;
  use_stackparams = (ntypes <= MAX_TYPES_STACKPARAMS);
  if (!use_stackparams) {
    lj1 = t_fparams("ForceLJNeigh::lj1",ntypes,ntypes);
    lj2 = t_fparams("ForceLJNeigh::lj2",ntypes,ntypes);
    cutsq = t_fparams("ForceLJNeigh::cutsq",ntypes,ntypes);
  }
  nbinx = nbiny = nbinz = 0;
  N_local = 0;
  nhalo = 0;
  step = 0;
}

template<class NeighborClass>
void ForceLJNeigh<NeighborClass>::init_coeff(int nargs, char** args) {
  step = 0;

  int one_based_type = 1;
  int t1 = atoi(args[1])-one_based_type;
  int t2 = atoi(args[2])-one_based_type;
  double eps = atof(args[3]);
  double sigma = atof(args[4]);
  double cut = atof(args[5]);

  if (use_stackparams) {
    for (int i = 0; i < ntypes; i++) {
      for (int j = 0; j < ntypes; j++) {
        stack_lj1[i][j] = 48.0 * eps * pow(sigma,12.0);
        stack_lj2[i][j] = 24.0 * eps * pow(sigma,6.0);
        stack_cutsq[i][j] = cut*cut;
      }
    }
  } else {
    t_fparams::HostMirror h_lj1 = Kokkos::create_mirror_view(lj1);
    t_fparams::HostMirror h_lj2 = Kokkos::create_mirror_view(lj2);
    t_fparams::HostMirror h_cutsq = Kokkos::create_mirror_view(cutsq);
    Kokkos::deep_copy(h_lj1,lj1);
    Kokkos::deep_copy(h_lj2,lj2);
    Kokkos::deep_copy(h_cutsq,cutsq);

    h_lj1(t1,t2) = 48.0 * eps * pow(sigma,12.0);
    h_lj2(t1,t2) = 24.0 * eps * pow(sigma,6.0);
    h_lj1(t2,t1) = h_lj1(t1,t2);
    h_lj2(t2,t1) = h_lj2(t1,t2);
    h_cutsq(t1,t2) = cut*cut;
    h_cutsq(t2,t1) = cut*cut;

    Kokkos::deep_copy(lj1,h_lj1);
    Kokkos::deep_copy(lj2,h_lj2);
    Kokkos::deep_copy(cutsq,h_cutsq);

    rnd_lj1 = lj1;
    rnd_lj2 = lj2;
    rnd_cutsq = cutsq;
  }
};

template<class NeighborClass>
void ForceLJNeigh<NeighborClass>::compute(System* system, Binning* binning, Neighbor* neighbor_ ) {
  // Set internal data handles
  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();

  N_local = system->N_local;
  x = system->x;
  f = system->f;
  f_a = system->f;
  type = system->type;
  id = system->id;
  if (use_stackparams) {
    if(half_neigh)
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_half_neigh_stackparams(0, system->N_local), *this);
    else
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_full_neigh_stackparams(0, system->N_local), *this);
  } else {
    if(half_neigh)
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_half_neigh(0, system->N_local), *this);
    else
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_full_neigh(0, system->N_local), *this);
  }
  Kokkos::fence();

  step++;
}

template<class NeighborClass>
T_V_FLOAT ForceLJNeigh<NeighborClass>::compute_energy(System* system, Binning* binning, Neighbor* neighbor_ ) {
  // Set internal data handles
  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();

  N_local = system->N_local;
  x = system->x;
  f = system->f;
  f_a = system->f;
  type = system->type;
  id = system->id;
  T_V_FLOAT energy;
  if (use_stackparams) {
    if(half_neigh)
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_half_neigh_pe_stackparams(0, system->N_local), *this, energy);
    else
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_full_neigh_pe_stackparams(0, system->N_local), *this, energy);
  } else {
    if(half_neigh)
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_half_neigh_pe(0, system->N_local), *this, energy);
    else
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_full_neigh_pe(0, system->N_local), *this, energy);
  }
  Kokkos::fence();

  step++;
  return energy;
}

template<class NeighborClass>
const char* ForceLJNeigh<NeighborClass>::name() { return half_neigh?"ForceLJNeighHalf":"ForceLJNeighFull"; }

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagFullNeigh<STACKPARAMS>, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;

  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      T_F_FLOAT fpair = (r6inv * (lj1_ij*r6inv - lj2_ij)) * r2inv;
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
    }
  }

  f(i,0) += fxi;
  f(i,1) += fyi;
  f(i,2) += fzi;

}

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagHalfNeigh<STACKPARAMS>, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;
  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      T_F_FLOAT fpair = (r6inv * (lj1_ij*r6inv - lj2_ij)) * r2inv;
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
      f_a(j,0) -= dx*fpair;
      f_a(j,1) -= dy*fpair;
      f_a(j,2) -= dz*fpair;
    }
  }
  f_a(i,0) += fxi;
  f_a(i,1) += fyi;
  f_a(i,2) += fzi;

}

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagFullNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);
  const bool shift_flag = true;

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      PE += 0.5*r6inv * (0.5*lj1_ij*r6inv - lj2_ij) / 6.0; // optimize later

      if (shift_flag) {
        T_F_FLOAT r2invc = 1.0/cutsq_ij;
        T_F_FLOAT r6invc = r2invc*r2invc*r2invc;
        PE -= 0.5*r6invc * (0.5*lj1_ij*r6invc - lj2_ij) / 6.0; // optimize later
      }
    }
  }
}

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagHalfNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);
  const bool shift_flag = true;

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      T_F_FLOAT fac;
      if(j<N_local) fac = 1.0;
      else fac = 0.5;

      PE += fac * r6inv * (0.5*lj1_ij*r6inv - lj2_ij) / 6.0;  // optimize later

      if (shift_flag) {
        T_F_FLOAT r2invc = 1.0/cutsq_ij;
        T_F_FLOAT r6invc = r2invc*r2invc*r2invc;
        PE -= fac * r6invc * (0.5*lj1_ij*r6invc - lj2_ij) / 6.0;  // optimize later
      }
    }
  }

}


---

# force_snap_neigh.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<Kokkos_Macros.hpp>
#ifndef KOKKOS_ENABLE_OPENMPTARGET
#include<force_snap_neigh_impl.h>
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceSNAP<NeighType>
#define FORCE_MODULES_TEMPLATE
#include<modules_neighbor.h>
#undef FORCE_MODULES_TEMPLATE
#endif


---

# force_snap_neigh.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

/* -*- c++ -*- ----------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "NEIGH_FULL") == 0) )
        force_iteration_type = FORCE_ITER_NEIGH_FULL;
#endif
#ifdef FORCE_MODULES_INSTANTIATION
    else if (input->force_type == FORCE_SNAP) {
      bool half_neigh = input->force_iteration_type == FORCE_ITER_NEIGH_HALF;
      if(half_neigh) Kokkos::abort("ForceSNAP does not support half neighborlist");
      switch ( input->neighbor_type ) {
        #define FORCETYPE_ALLOCATION_MACRO(NeighType)  ForceSNAP<NeighType>(input->input_data.words[input->force_line],system,half_neigh)
        #include <modules_neighbor.h>
        #undef FORCETYPE_ALLOCATION_MACRO
      }
    }

#endif


#if !defined(MODULES_OPTION_CHECK) && \
    !defined(FORCE_MODULES_INSTANTIATION)

#ifndef FORCE_SNAP_NEIGH_H
#define FORCE_SNAP_NEIGH_H
#include<force.h>
#include<sna.h>

template<class NeighborClass>
class ForceSNAP : public Force {
public:
  ForceSNAP(char** args, System* system, bool half_neigh_);
  ~ForceSNAP();
  
  void init_coeff(int nargs, char** args);
  void compute(System* system, Binning* binning, Neighbor* neighbor );

  const char* name() {return "ForceSNAP";}

protected:
  System* system;

  typedef typename NeighborClass::t_neigh_list t_neigh_list;
  t_neigh_list neigh_list;

  int ncoeff, ncoeffq, ncoeffall;
  typedef Kokkos::View<T_F_FLOAT**> t_bvec;
  t_bvec bvec;
  typedef Kokkos::View<T_F_FLOAT***> t_dbvec;
  t_dbvec dbvec;
  SNA sna;

  int nmax;

  // How much parallelism to use within an interaction
  int vector_length;
  // How many interactions can be run concurrently
  int concurrent_interactions;

  void allocate();
  void read_files(char *, char *);
  /*inline int equal(double* x,double* y);
  inline double dist2(double* x,double* y);
  double extra_cutoff();
  void load_balance();
  void set_sna_to_shared(int snaid,int i);
  void build_per_atom_arrays();*/

  int schedule_user;
  double schedule_time_guided;
  double schedule_time_dynamic;

  int ncalls_neigh;
  int do_load_balance;
  int ilistmask_max;
  Kokkos::View<T_INT*> ilistmast;
  int ghostinum;
  int ghostilist_max;
  Kokkos::View<T_INT*> ghostilist;
  int ghostnumneigh_max;
  Kokkos::View<T_INT*> ghostnumneigh;
  Kokkos::View<T_INT*> ghostneighs;
  Kokkos::View<T_INT*> ghostfirstneigh;
  int ghostneighs_total;
  int ghostneighs_max;

  int use_optimized;
  int use_shared_arrays;

  int i_max;
  int i_neighmax;
  int i_numpairs;
  Kokkos::View<T_INT**, Kokkos::LayoutRight> i_pairs;
  Kokkos::View<T_INT***, Kokkos::LayoutRight> i_rij;
  Kokkos::View<T_INT**, Kokkos::LayoutRight> i_inside;
  Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight> i_wj;
  Kokkos::View<T_F_FLOAT***, Kokkos::LayoutRight>i_rcutij;
  Kokkos::View<T_INT*> i_ninside;
  Kokkos::View<T_F_FLOAT****, Kokkos::LayoutRight> i_uarraytot_r, i_uarraytot_i;
  Kokkos::View<T_F_FLOAT******, Kokkos::LayoutRight> i_zarray_r, i_zarray_i;

#ifdef TIMING_INFO
  //  timespec starttime, endtime;
  double timers[4];
#endif

  double rcutmax;               // max cutoff for all elements
  int nelements;                // # of unique elements
  char **elements;              // names of unique elements
  Kokkos::View<T_F_FLOAT*> radelem;              // element radii
  Kokkos::View<T_F_FLOAT*> wjelem;               // elements weights
  Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight> coeffelem;           // element bispectrum coefficients
  Kokkos::View<T_INT*> map;                     // mapping from atom types to elements
  int twojmax, diagonalstyle, switchflag, bzeroflag, quadraticflag;
  double rcutfac, rfac0, rmin0, wj1, wj2;
  int rcutfacflag, twojmaxflag; // flags for required parameters
  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  t_fparams cutsq;
  typedef Kokkos::View<const T_F_FLOAT**,
      Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_fparams_rnd;
  t_fparams_rnd rnd_cutsq;


  t_x x;
  t_f_atomic f;
  t_type type;

public:

  KOKKOS_INLINE_FUNCTION
  void operator() (const Kokkos::TeamPolicy<>::member_type& team) const;

};

#define FORCE_MODULES_EXTERNAL_TEMPLATE
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceSNAP<NeighType>
#include<modules_neighbor.h>
#undef FORCETYPE_DECLARE_TEMPLATE_MACRO
#undef FORCE_MODULES_EXTERNAL_TEMPLATE

#endif
#endif


---

# force_snap_neigh_impl.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "force_snap_neigh.h"

#define MAXLINE 1024
#define MAXWORD 3

// Outstanding issues with quadratic term
// 1. there seems to a problem with compute_optimized energy calc
// it does not match compute_regular, even when quadratic coeffs = 0

//static double t1 = 0.0;
//static double t2 = 0.0;
//static double t3 = 0.0;
//static double t4 = 0.0;
//static double t5 = 0.0;
//static double t6 = 0.0;
//static double t7 = 0.0;
/* ---------------------------------------------------------------------- */

template<class NeighborClass>
ForceSNAP<NeighborClass>::ForceSNAP(char** args, System* system_, bool half_neigh_):Force(args,system_,half_neigh_)
{

  system = system_;
  nelements = 0;

  nmax = 0;

  vector_length = 8;
  concurrent_interactions =
#if defined(KOKKOS_ENABLE_CUDA)
      std::is_same<Kokkos::DefaultExecutionSpace,Kokkos::Cuda>::value ?
          Kokkos::DefaultExecutionSpace::concurrency()/vector_length :
#elif defined(KOKKOS_ENABLE_HIP)
      std::is_same<Kokkos::DefaultExecutionSpace,Kokkos::Experimental::HIP>::value ?
          Kokkos::DefaultExecutionSpace::concurrency()/vector_length :
#elif defined(KOKKOS_ENABLE_SYCL)
      std::is_same<Kokkos::DefaultExecutionSpace,Kokkos::Experimental::SYCL>::value ?
          Kokkos::DefaultExecutionSpace::concurrency()/vector_length :
#else
          Kokkos::DefaultExecutionSpace::concurrency();
#endif

  schedule_user = 0;
  schedule_time_guided = -1;
  schedule_time_dynamic = -1;
  ncalls_neigh =-1;

  ilistmask_max = 0;
  ghostinum = 0;
  ghostilist_max = 0;
  ghostnumneigh_max = 0;
  ghostneighs_total = 0;
  ghostneighs_max = 0;

  i_max = 0;
  i_neighmax = 0;
  i_numpairs = 0;

  use_shared_arrays = 0;

#ifdef TIMING_INFO
  timers[0] = 0;
  timers[1] = 0;
  timers[2] = 0;
  timers[3] = 0;
#endif

  // Need to set this because restart not handled by ForceHybrid

  cutsq = t_fparams("ForceSNAP::cutsq",system->ntypes,system->ntypes);
}

/* ---------------------------------------------------------------------- */

template<class NeighborClass>
ForceSNAP<NeighborClass>::~ForceSNAP()
{
  // Need to set this because restart not handled by ForceHybrid

  /*if (sna) {
    for (int tid = 0; tid<concurrent_interactions; tid++)
      delete sna[tid];
    delete [] sna;

  }*/
}

template<class NeighList>
struct FindMaxNumNeighs {
  NeighList neigh_list;

  FindMaxNumNeighs(NeighList& nl): neigh_list(nl) {}

  KOKKOS_INLINE_FUNCTION
  void operator() (const int& i, int& max_neighs) const {
    typename NeighList::t_neighs neighs_i = neigh_list.get_neighs(i);
    const int num_neighs = neighs_i.get_num_neighs();
    if(max_neighs<num_neighs) max_neighs = num_neighs;
  }
};
/* ----------------------------------------------------------------------
   This version is a straightforward implementation
   ---------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::compute(System* system, Binning* binning, Neighbor* neighbor_)
{

  if(comm_newton == false)
    Kokkos::abort("ForceSNAP requires 'newton on'");
  x = system->x;
  f = system->f;
  type = system->type;
  int nlocal = system->N_local;

  //class SNA* snaptr = sna[0];

  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();
  int max_neighs = 0;
  /*
  for (int i = 0; i < nlocal; i++) {
    typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);
    const int num_neighs = neighs_i.get_num_neighs();
    if(max_neighs<num_neighs) max_neighs = num_neighs;
  }*/
  Kokkos::parallel_reduce("ForceSNAP::find_max_neighs",nlocal, FindMaxNumNeighs<t_neigh_list>(neigh_list), Kokkos::Max<int>(max_neighs));

  sna.nmax = max_neighs;

  T_INT team_scratch_size = sna.size_team_scratch_arrays();
  T_INT thread_scratch_size = sna.size_thread_scratch_arrays();

  //printf("Sizes: %i %i\n",team_scratch_size/1024,thread_scratch_size/1024);
  int vector_length = 8;
  int team_size_max = Kokkos::TeamPolicy<>(nlocal,Kokkos::AUTO).team_size_max(*this,Kokkos::ParallelForTag());
#ifdef EMD_ENABLE_GPU
  int team_size = 20;//max_neighs;
  if(team_size*vector_length > team_size_max)
    team_size = team_size_max/vector_length;
#else
  int team_size = 1;
#endif
  Kokkos::TeamPolicy<> policy(nlocal,team_size,vector_length);

  Kokkos::parallel_for("ForceSNAP::compute",policy
      .set_scratch_size(1,Kokkos::PerThread(thread_scratch_size))
      .set_scratch_size(1,Kokkos::PerTeam(team_scratch_size))
    ,*this);
//static int step =0;
//step++;
//if(step%10==0)
//        printf(" %e %e %e %e %e (%e %e): %e\n",t1,t2,t3,t4,t5,t6,t7,t1+t2+t3+t4+t5);
}



/* ----------------------------------------------------------------------
   allocate all arrays
------------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::allocate()
{
  map = Kokkos::View<T_INT*>("ForceSNAP::map",nelements+1);
}


/* ----------------------------------------------------------------------
   set coeffs for one or more type pairs
------------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::init_coeff(int narg, char **arg)
{
  // read SNAP element names between 2 filenames
  // nelements = # of SNAP elements
  // elements = list of unique element names

  if (narg < 7) Kokkos::abort("SNAP 1: Incorrect args for pair coefficients");
  allocate();

  if (nelements) {
    for (int i = 0; i < nelements; i++)
      delete[] elements[i];
    delete[] elements;
    radelem = Kokkos::View<T_F_FLOAT*>();
    wjelem = Kokkos::View<T_F_FLOAT*>();
    coeffelem = Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight>();
  }

  nelements = narg - 5 - system->ntypes;
  if (nelements < 1) Kokkos::abort("SNAP 2: Incorrect args for pair coefficients");

  map = Kokkos::View<T_INT*>("ForceSNAP::map",nelements+1);

  char* type1 = arg[1];
  char* type2 = arg[2];
  char* coefffilename = arg[3];
  char** elemlist = &arg[4];
  char* paramfilename = arg[4+nelements];
  char** elemtypes = &arg[5+nelements];

  // insure I,J args are * *
  if (strcmp(type1,"*") != 0 || strcmp(type2,"*") != 0)
    Kokkos::abort("A Incorrect args for pair coefficients");

  elements = new char*[nelements];

  for (int i = 0; i < nelements; i++) {
    char* elemname = elemlist[i];
    int n = strlen(elemname) + 1;
    elements[i] = new char[n];
    strcpy(elements[i],elemname);
  }

  // read snapcoeff and snapparam files

  read_files(coefffilename,paramfilename);

  if (!quadraticflag)
    ncoeff = ncoeffall - 1;
  else {

    // ncoeffall should be (ncoeff+2)*(ncoeff+1)/2
    // so, ncoeff = floor(sqrt(2*ncoeffall))-1

    ncoeff = sqrt(2*ncoeffall)-1;
    ncoeffq = (ncoeff*(ncoeff+1))/2;
    int ntmp = 1+ncoeff+ncoeffq;
    if (ntmp != ncoeffall) {
      printf("ncoeffall = %d ntmp = %d ncoeff = %d \n",ncoeffall,ntmp,ncoeff);
      Kokkos::abort("Incorrect SNAP coeff file");
    }
  }

  // read args that map atom types to SNAP elements
  // map[i] = which element the Ith atom type is, -1 if not mapped
  // map[0] is not used

  auto h_map = Kokkos::create_mirror_view(map);
  for (int i = 1; i <= system->ntypes; i++) {
    char* elemname = elemtypes[i-1];
    int jelem;
    for (jelem = 0; jelem < nelements; jelem++)
      if (strcmp(elemname,elements[jelem]) == 0)
	break;

    if (jelem < nelements)
      h_map[i] = jelem;
    else if (strcmp(elemname,"NULL") == 0) h_map[i] = -1;
    else Kokkos::abort("Incorrect args for pair coefficients");
  }

  Kokkos::deep_copy(map,h_map);
  // allocate memory for per OpenMP thread data which
  // is wrapped into the sna class


  sna = SNA(rfac0,twojmax,
            diagonalstyle,use_shared_arrays,
		        rmin0,switchflag,bzeroflag);
    //if (!use_shared_arrays)
  sna.grow_rij(nmax);
  sna.init();

  //printf("ncoeff = %d snancoeff = %d \n",ncoeff,sna[0]->ncoeff);
  if (ncoeff != sna.ncoeff) {
    printf("ncoeff = %d snancoeff = %d \n",ncoeff,sna.ncoeff);
    Kokkos::abort("Incorrect SNAP parameter file");
  }

  // Calculate maximum cutoff for all elements
  auto h_radelem = Kokkos::create_mirror_view(radelem);
  Kokkos::deep_copy(h_radelem,radelem);
  rcutmax = 0.0;
  for (int ielem = 0; ielem < nelements; ielem++) {
    rcutmax = MAX(2.0*h_radelem[ielem]*rcutfac,rcutmax);
  }
  Kokkos::deep_copy(cutsq,rcutmax*rcutmax);
  rnd_cutsq = cutsq;
}

/* ---------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::read_files(char *coefffilename, char *paramfilename)
{

  // open SNAP coefficient file on proc 0

  FILE *fpcoeff;
  //if (comm->me == 0) {
    fpcoeff = fopen(coefffilename,"r");
    if (fpcoeff == NULL) {
      char str[128];
      sprintf(str,"Cannot open SNAP coefficient file %s",coefffilename);
      //error->one(FLERR,str);
    }
  //}

  char line[MAXLINE],*ptr;
  int eof = 0;

  int n;
  int nwords = 0;
  while (nwords == 0) {
    //if (comm->me == 0) {
      ptr = fgets(line,MAXLINE,fpcoeff);
      if (ptr == NULL) {
        eof = 1;
        fclose(fpcoeff);
      } else n = strlen(line) + 1;
    // }
    //MPI_Bcast(&eof,1,MPI_INT,0,world);
    if (eof) break;
    //MPI_Bcast(&n,1,MPI_INT,0,world);
    //MPI_Bcast(line,n,MPI_CHAR,0,world);

    // strip comment, skip line if blank

    if ((ptr = strchr(line,'#'))) {*ptr = '\0';}
    else if(line[0]!=10) {nwords = 2;}
    //nwords = atom->count_words(line);
  }
  if (nwords != 2)
    Kokkos::abort("Incorrect format in SNAP coefficient file");

  // words = ptrs to all words in line
  // strip single and double quotes from words
  char* words[MAXWORD];
  int iword = 0;
  words[iword] = strtok(line,"' \t\n\r\f");
  iword = 1;
  words[iword] = strtok(NULL,"' \t\n\r\f");

  int nelemfile = atoi(words[0]);
  ncoeffall = atoi(words[1]);

  // Set up element lists

  radelem = Kokkos::View<T_F_FLOAT*>("pair:radelem",nelements);
  wjelem = Kokkos::View<T_F_FLOAT*>("pair:wjelem",nelements);
  coeffelem = Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight>("pair:coeffelem",nelements,ncoeffall);

  int *found = new int[nelements];
  for (int ielem = 0; ielem < nelements; ielem++)
    found[ielem] = 0;

  // Loop over elements in the SNAP coefficient file

  for (int ielemfile = 0; ielemfile < nelemfile; ielemfile++) {

    //if (comm->me == 0) {
      ptr = fgets(line,MAXLINE,fpcoeff);
      if (ptr == NULL) {
	eof = 1;
	fclose(fpcoeff);
      } else n = strlen(line) + 1;
    //}
    //MPI_Bcast(&eof,1,MPI_INT,0,world);
    if (eof)
      Kokkos::abort("Incorrect format in SNAP coefficient file");
    //MPI_Bcast(&n,1,MPI_INT,0,world);
    //MPI_Bcast(line,n,MPI_CHAR,0,world);

    //nwords = atom->count_words(line);
    //if (nwords != 3)
    //  Kokkos::abort("Incorrect format in SNAP coefficient file");

    iword = 0;
    words[iword] = strtok(line,"' \t\n\r\f");
    iword = 1;
    words[iword] = strtok(NULL,"' \t\n\r\f");
    iword = 2;
    words[iword] = strtok(NULL,"' \t\n\r\f");

    char* elemtmp = words[0];
    double radtmp = atof(words[1]);
    double wjtmp = atof(words[2]);

    // skip if element name isn't in element list

    int ielem;
    for (ielem = 0; ielem < nelements; ielem++)
      if (strcmp(elemtmp,elements[ielem]) == 0) break;
    if (ielem == nelements) {
      //if (comm->me == 0)
	for (int icoeff = 0; icoeff < ncoeffall; icoeff++)
	  ptr = fgets(line,MAXLINE,fpcoeff);
      continue;
    }

    // skip if element already appeared

    if (found[ielem]) {
    //  if (comm->me == 0)
	for (int icoeff = 0; icoeff < ncoeffall; icoeff++)
	  ptr = fgets(line,MAXLINE,fpcoeff);
      continue;
    }

    found[ielem] = 1;
    auto radelem_i = Kokkos::subview(radelem,ielem);
    Kokkos::deep_copy(radelem,radtmp);
    auto wjelem_i = Kokkos::subview(wjelem,ielem);
    Kokkos::deep_copy(wjelem,wjtmp);
//    radelem[ielem] = radtmp;
//    wjelem[ielem] = wjtmp;


    //if (comm->me == 0) {
      //if (logfile) fprintf(logfile,"SNAP Element = %s, Radius %g, Weight %g \n",
			//  elements[ielem], radelem[ielem], wjelem[ielem]);
    //}

    for (int icoeff = 0; icoeff < ncoeffall; icoeff++) {
      //if (comm->me == 0) {
	ptr = fgets(line,MAXLINE,fpcoeff);
	if (ptr == NULL) {
	  eof = 1;
	  fclose(fpcoeff);
	} else n = strlen(line) + 1;
      //}

      //MPI_Bcast(&eof,1,MPI_INT,0,world);
      if (eof)
	Kokkos::abort("Incorrect format in SNAP coefficient file");
      //MPI_Bcast(&n,1,MPI_INT,0,world);
      //MPI_Bcast(line,n,MPI_CHAR,0,world);

      //nwords = atom->count_words(line);
      //if (nwords != 1)
	//Kokkos::abort("Incorrect format in SNAP coefficient file");

      iword = 0;
      words[iword] = strtok(line,"' \t\n\r\f");

      //coeffelem(ielem,icoeff) = atof(words[0]);
      auto coeffelem_ii = Kokkos::subview(coeffelem,ielem,icoeff);
      Kokkos::deep_copy(coeffelem_ii,atof(words[0]));

    }
  }

  // set flags for required keywords

  rcutfacflag = 0;
  twojmaxflag = 0;

  // Set defaults for optional keywords

  rfac0 = 0.99363;
  rmin0 = 0.0;
  diagonalstyle = 3;
  switchflag = 1;
  bzeroflag = 1;
  quadraticflag = 0;

  // open SNAP parameter file on proc 0

  FILE *fpparam;
  //if (comm->me == 0) {
    fpparam = fopen(paramfilename,"r");
    if (fpparam == NULL) {
      char str[128];
      sprintf(str,"Cannot open SNAP parameter file %s",paramfilename);
      //error->one(FLERR,str);
    }
  //}

  eof = 0;
  while (1) {
    //if (comm->me == 0) {
      ptr = fgets(line,MAXLINE,fpparam);
      if (ptr == NULL) {
        eof = 1;
        fclose(fpparam);
      } else n = strlen(line) + 1;
    //}
    //MPI_Bcast(&eof,1,MPI_INT,0,world);
    if (eof) break;
    //MPI_Bcast(&n,1,MPI_INT,0,world);
    //MPI_Bcast(line,n,MPI_CHAR,0,world);

    // strip comment, skip line if blank

    if ((ptr = strchr(line,'#'))) {*ptr = '\0'; continue;}
    //nwords = atom->count_words(line);
    if(line[0]!=10) nwords = 2; else nwords = 0;
    if (nwords == 0) continue;

    if (nwords != 2)
      Kokkos::abort("Incorrect format in SNAP parameter file");

    // words = ptrs to all words in line
    // strip single and double quotes from words

    char* keywd = strtok(line,"' \t\n\r\f");
    char* keyval = strtok(NULL,"' \t\n\r\f");

    //if (comm->me == 0) {
      //if (screen)
      //if (logfile) fprintf(logfile,"SNAP keyword %s %s \n",keywd,keyval);
    //}

    if (strcmp(keywd,"rcutfac") == 0) {
      rcutfac = atof(keyval);
      rcutfacflag = 1;
    } else if (strcmp(keywd,"twojmax") == 0) {
      twojmax = atoi(keyval);
      twojmaxflag = 1;
    } else if (strcmp(keywd,"rfac0") == 0)
      rfac0 = atof(keyval);
    else if (strcmp(keywd,"rmin0") == 0)
      rmin0 = atof(keyval);
    else if (strcmp(keywd,"diagonalstyle") == 0)
      diagonalstyle = atoi(keyval);
    else if (strcmp(keywd,"switchflag") == 0)
      switchflag = atoi(keyval);
    else if (strcmp(keywd,"bzeroflag") == 0)
      bzeroflag = atoi(keyval);
    else if (strcmp(keywd,"quadraticflag") == 0)
      quadraticflag = atoi(keyval);
    else
      Kokkos::abort("Incorrect SNAP parameter file");
  }

  if (rcutfacflag == 0 || twojmaxflag == 0)
    Kokkos::abort("Incorrect SNAP parameter file");

  delete[] found;
}

template<class NeighborClass>
KOKKOS_INLINE_FUNCTION
void ForceSNAP<NeighborClass>::operator() (const Kokkos::TeamPolicy<>::member_type& team) const {
  const int i = team.league_rank();
  SNA my_sna(sna,team);
  const double x_i = x(i,0);
  const double y_i = x(i,1);
  const double z_i = x(i,2);
  const int type_i = type[i];
  const int elem_i = map[type_i];
  const double radi = radelem[elem_i];

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  // rij[][3] = displacements between atom I and those neighbors
  // inside = indices of neighbors of I within cutoff
  // wj = weights for neighbors of I within cutoff
  // rcutij = cutoffs for neighbors of I within cutoff
  // note Rij sign convention => dU/dRij = dU/dRj = -dU/dRi

  //Kokkos::Timer timer;
  int ninside = 0;
  Kokkos::parallel_reduce(Kokkos::TeamThreadRange(team,num_neighs),
      [&] (const int jj, int& count) {
    Kokkos::single(Kokkos::PerThread(team), [&] (){
      T_INT j = neighs_i(jj);
      const T_F_FLOAT dx = x(j,0) - x_i;
      const T_F_FLOAT dy = x(j,1) - y_i;
      const T_F_FLOAT dz = x(j,2) - z_i;

      const int type_j = type(j);
      const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
      const int elem_j = map[type_j];

      if( rsq < rnd_cutsq(type_i,type_j) )
       count++;
    });
  },ninside);

  //t1 += timer.seconds(); timer.reset();

  if(team.team_rank() == 0)
  Kokkos::parallel_scan(Kokkos::ThreadVectorRange(team,num_neighs),
      [&] (const int jj, int& offset, bool final){
  //for (int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x(j,0) - x_i;
    const T_F_FLOAT dy = x(j,1) - y_i;
    const T_F_FLOAT dz = x(j,2) - z_i;

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
    const int elem_j = map[type_j];

    if( rsq < rnd_cutsq(type_i,type_j) ) {
      if(final) {
        my_sna.rij(offset,0) = dx;
        my_sna.rij(offset,1) = dy;
        my_sna.rij(offset,2) = dz;
        my_sna.inside[offset] = j;
        my_sna.wj[offset] = wjelem[elem_j];
        my_sna.rcutij[offset] = (radi + radelem[elem_j])*rcutfac;
      }
      offset++;
    }
  });

  //t2 += timer.seconds(); timer.reset();

  team.team_barrier();
  // compute Ui, Zi, and Bi for atom I
  my_sna.compute_ui(team,ninside);
  //t3 += timer.seconds(); timer.reset();
  team.team_barrier();
  my_sna.compute_zi(team);
  //t4 += timer.seconds(); timer.reset();
  team.team_barrier();

  // for neighbors of I within cutoff:
  // compute dUi/drj and dBi/drj
  // Fij = dEi/dRj = -dEi/dRi => add to Fi, subtract from Fj

  Kokkos::View<double*,Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Unmanaged>>
    coeffi(coeffelem,elem_i,Kokkos::ALL);

  Kokkos::parallel_for(Kokkos::TeamThreadRange(team,ninside),
      [&] (const int jj) {
  //for (int jj = 0; jj < ninside; jj++) {
    int j = my_sna.inside[jj];
    //Kokkos::Timer timer2;
    my_sna.compute_duidrj(team,&my_sna.rij(jj,0),
                           my_sna.wj[jj],my_sna.rcutij[jj]);
    //t6 += timer2.seconds(); timer2.reset();
    my_sna.compute_dbidrj(team);
    //t7 += timer2.seconds(); timer2.reset();
    my_sna.copy_dbi2dbvec(team);


    Kokkos::single(Kokkos::PerThread(team), [&] (){
    T_F_FLOAT fij[3];

    fij[0] = 0.0;
    fij[1] = 0.0;
    fij[2] = 0.0;

    // linear contributions

    for (int k = 1; k <= ncoeff; k++) {
      double bgb = coeffi[k];
      fij[0] += bgb*my_sna.dbvec(k-1,0);
      fij[1] += bgb*my_sna.dbvec(k-1,1);
      fij[2] += bgb*my_sna.dbvec(k-1,2);
    }

    const double dx = my_sna.rij(jj,0);
    const double dy = my_sna.rij(jj,1);
    const double dz = my_sna.rij(jj,2);
    const double fdivr = -1.5e6/pow(dx*dx + dy*dy + dz*dz,7.0);
    fij[0] += dx*fdivr;
    fij[1] += dy*fdivr;
    fij[2] += dz*fdivr;

    //OK
    //printf("%lf %lf %lf %lf %lf %lf %lf %lf %lf SNAP-COMPARE: FIJ\n"
    //    ,x(i,0),x(i,1),x(i,2),x(j,0),x(j,1),x(j,2),fij[0],fij[1],fij[2] );
    f(i,0) += fij[0];
    f(i,1) += fij[1];
    f(i,2) += fij[2];
    f(j,0) -= fij[0];
    f(j,1) -= fij[1];
    f(j,2) -= fij[2];
    });
  });
  //t5 += timer.seconds(); timer.reset();
}


---

# sna.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

/* -*- c++ -*- -------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
   Contributing authors: Aidan Thompson, Christian Trott, SNL
------------------------------------------------------------------------- */

#ifndef LMP_SNA_H
#define LMP_SNA_H

#include <complex>
#include <ctime>
#include <Kokkos_Core.hpp>
#include <types.h>

struct SNA_LOOPINDICES {
  int j1, j2, j;
};

class SNA {

public:
  typedef Kokkos::View<int*> t_sna_1i;
  typedef Kokkos::View<double*> t_sna_1d;
  typedef Kokkos::View<double**, Kokkos::LayoutRight> t_sna_2d;
  typedef Kokkos::View<double***, Kokkos::LayoutRight> t_sna_3d;
  typedef Kokkos::View<double***, Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Atomic> > t_sna_3d_atomic;
  typedef Kokkos::View<double***[3], Kokkos::LayoutRight> t_sna_4d;
  typedef Kokkos::View<double**[3], Kokkos::LayoutRight> t_sna_3d3;
  typedef Kokkos::View<double*****, Kokkos::LayoutRight> t_sna_5d;
  inline
  SNA() {};
  KOKKOS_INLINE_FUNCTION
  SNA(const SNA& sna, const Kokkos::TeamPolicy<>::member_type& team);
  inline
  SNA(double, int, int, int, double, int, int);

  KOKKOS_INLINE_FUNCTION
  ~SNA();
  inline
  void build_indexlist(); // SNA()
  inline
  void init();            //
  inline
  T_INT size_team_scratch_arrays();
  inline
  T_INT size_thread_scratch_arrays();

  int ncoeff;

  // functions for bispectrum coefficients

  KOKKOS_INLINE_FUNCTION
  void compute_ui(const Kokkos::TeamPolicy<>::member_type& team, int); // ForceSNAP
  KOKKOS_INLINE_FUNCTION
  void compute_zi(const Kokkos::TeamPolicy<>::member_type& team);    // ForceSNAP

  // functions for derivatives

  KOKKOS_INLINE_FUNCTION
  void compute_duidrj(const Kokkos::TeamPolicy<>::member_type& team, double*, double, double); //ForceSNAP
  KOKKOS_INLINE_FUNCTION
  void compute_dbidrj(const Kokkos::TeamPolicy<>::member_type& team); //ForceSNAP
  KOKKOS_INLINE_FUNCTION
  void copy_dbi2dbvec(const Kokkos::TeamPolicy<>::member_type& team); //ForceSNAP
  KOKKOS_INLINE_FUNCTION
  double compute_sfac(double, double); // add_uarraytot, compute_duarray
  KOKKOS_INLINE_FUNCTION
  double compute_dsfac(double, double); // compute_duarray

#ifdef TIMING_INFO
  double* timers;
  timespec starttime, endtime;
  int print;
  int counter;
#endif

  //per sna class instance for OMP use


  // Per InFlight Particle
  t_sna_2d rij;
  t_sna_1i inside;
  t_sna_1d wj;
  t_sna_1d rcutij;
  int nmax;

  void grow_rij(int);

  int twojmax, diagonalstyle;
  // Per InFlight Particle
  t_sna_3d uarraytot_r, uarraytot_i;
  t_sna_3d_atomic uarraytot_r_a, uarraytot_i_a;
  t_sna_5d zarray_r, zarray_i;

  // Per InFlight Interaction
  t_sna_3d uarray_r, uarray_i;

  // derivatives of data
  Kokkos::View<double*[3], Kokkos::LayoutRight> dbvec;
  t_sna_4d duarray_r, duarray_i;
  t_sna_4d dbarray;

private:
  double rmin0, rfac0;

  //use indexlist instead of loops, constructor generates these
  // Same accross all SNA
  Kokkos::View<SNA_LOOPINDICES*> idxj,idxj_full;
  int idxj_max,idxj_full_max;
  // data for bispectrum coefficients

  // Same accross all SNA
  t_sna_5d cgarray;
  t_sna_2d rootpqarray;


  static const int nmaxfactorial = 167;
  KOKKOS_INLINE_FUNCTION
  double factorial(int);

  KOKKOS_INLINE_FUNCTION
  void create_team_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team); // SNA()
  KOKKOS_INLINE_FUNCTION
  void create_thread_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team); // SNA()
  inline
  void init_clebsch_gordan(); // init()
  inline
  void init_rootpqarray();    // init()
  KOKKOS_INLINE_FUNCTION
  void zero_uarraytot(const Kokkos::TeamPolicy<>::member_type& team);      // compute_ui
  KOKKOS_INLINE_FUNCTION
  void addself_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double); // compute_ui
  KOKKOS_INLINE_FUNCTION
  void add_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double, double, double); // compute_ui

  KOKKOS_INLINE_FUNCTION
  void compute_uarray(const Kokkos::TeamPolicy<>::member_type& team,
                      double, double, double,
                      double, double); // compute_ui
  KOKKOS_INLINE_FUNCTION
  double deltacg(int, int, int);  // init_clebsch_gordan
  inline
  int compute_ncoeff();           // SNA()
  KOKKOS_INLINE_FUNCTION
  void compute_duarray(const Kokkos::TeamPolicy<>::member_type& team,
                       double, double, double, // compute_duidrj
                       double, double, double, double, double);

  // if number of atoms are small use per atom arrays
  // for twojmax arrays, rij, inside, bvec
  // this will increase the memory footprint considerably,
  // but allows parallel filling and reuse of these arrays
  int use_shared_arrays;

  // Sets the style for the switching function
  // 0 = none
  // 1 = cosine
  int switch_flag;

  // Self-weight
  double wself;
};

#include<sna_impl.hpp>
#endif

/* ERROR/WARNING messages:

E: Invalid argument to factorial %d

N must be >= 0 and <= 167, otherwise the factorial result is too
large.

*/


---

# sna_impl.hpp

/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
   Contributing authors: Aidan Thompson, Christian Trott, SNL
------------------------------------------------------------------------- */

#include "sna.h"
#include <math.h>
#include <string.h>
#include <stdlib.h>

static const double MY_PI  = 3.14159265358979323846; // pi

inline
SNA::SNA(double rfac0_in,
         int twojmax_in, int diagonalstyle_in, int use_shared_arrays_in,
         double rmin0_in, int switch_flag_in, int bzero_flag_in) 
{
  wself = 1.0;
  
  use_shared_arrays = use_shared_arrays_in;
  rfac0 = rfac0_in;
  rmin0 = rmin0_in;
  switch_flag = switch_flag_in;

  twojmax = twojmax_in;
  diagonalstyle = diagonalstyle_in;

  ncoeff = compute_ncoeff();

  //create_twojmax_arrays();

  nmax = 0;
  
  build_indexlist();

  int jdim = twojmax + 1;

  cgarray = t_sna_5d("SNA::cgarray",jdim,jdim,jdim,jdim,jdim);
  rootpqarray = t_sna_2d("SNA::rootpqarray",jdim+1,jdim+1);

}

KOKKOS_INLINE_FUNCTION
SNA::SNA(const SNA& sna, const Kokkos::TeamPolicy<>::member_type& team) {
  wself = sna.wself;

  use_shared_arrays = sna.use_shared_arrays;
  rfac0 = sna.rfac0;
  rmin0 = sna.rmin0;
  switch_flag = sna.switch_flag;

  twojmax = sna.twojmax;
  diagonalstyle = sna.diagonalstyle;

  ncoeff = sna.ncoeff;
  nmax = sna.nmax;
  idxj = sna.idxj;
  idxj_max = sna.idxj_max;
  idxj_full = sna.idxj_full;
  idxj_full_max = sna.idxj_full_max;
  cgarray = sna.cgarray;
  rootpqarray = sna.rootpqarray;
  create_team_scratch_arrays(team);
  create_thread_scratch_arrays(team);
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
SNA::~SNA()
{
}

inline
void SNA::build_indexlist()
{
  if(diagonalstyle == 3) {
    int idxj_count = 0;
    int idxj_full_count = 0;

    for(int j1 = 0; j1 <= twojmax; j1++)
      for(int j2 = 0; j2 <= j1; j2++)
        for(int j = abs(j1 - j2); j <= MIN(twojmax, j1 + j2); j += 2) {
          if (j >= j1) idxj_count++;
          idxj_full_count++;
        }

    // indexList can be changed here

    idxj = Kokkos::View<SNA_LOOPINDICES*>("SNA::idxj",idxj_count);
    idxj_full = Kokkos::View<SNA_LOOPINDICES*>("SNA::idxj_full",idxj_full_count);
    auto h_idxj = Kokkos::create_mirror_view(idxj);
    auto h_idxj_full = Kokkos::create_mirror_view(idxj_full);

    idxj_max = idxj_count;
    idxj_full_max = idxj_full_count;

    idxj_count = 0;
    idxj_full_count = 0;

    for(int j1 = 0; j1 <= twojmax; j1++)
      for(int j2 = 0; j2 <= j1; j2++)
        for(int j = abs(j1 - j2); j <= MIN(twojmax, j1 + j2); j += 2) {
          if (j >= j1) {
            h_idxj[idxj_count].j1 = j1;
            h_idxj[idxj_count].j2 = j2;
            h_idxj[idxj_count].j = j;
            idxj_count++;
          }
          h_idxj_full[idxj_full_count].j1 = j1;
          h_idxj_full[idxj_full_count].j2 = j2;
          h_idxj_full[idxj_full_count].j = j;
          idxj_full_count++;
        }
    Kokkos::deep_copy(idxj,h_idxj);
    Kokkos::deep_copy(idxj_full,h_idxj_full);

  }

}
/* ---------------------------------------------------------------------- */

inline
void SNA::init()
{
  init_clebsch_gordan();
  init_rootpqarray();
}

inline
void SNA::grow_rij(int newnmax)
{
  if(newnmax <= nmax) return;
  nmax = newnmax;
}
/* ----------------------------------------------------------------------
   compute Ui by summing over neighbors j
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_ui(const Kokkos::TeamPolicy<>::member_type& team, int jnum)
{
  double rsq, r, x, y, z, z0, theta0;

  // utot(j,ma,mb) = 0 for all j,ma,ma
  // utot(j,ma,ma) = 1 for all j,ma
  // for j in neighbors of i:
  //   compute r0 = (x,y,z,z0)
  //   utot(j,ma,mb) += u(r0;j,ma,mb) for all j,ma,mb

  if(team.team_rank() == 0) {
    zero_uarraytot(team);
    //Kokkos::single(Kokkos::PerThread(team), [&] (){
    addself_uarraytot(team,wself);
    //});
  }
  team.team_barrier();

  Kokkos::parallel_for(Kokkos::TeamThreadRange(team,jnum),
      [&] (const int& j) {
  //for(int j = 0; j < jnum; j++) {
    x = rij(j,0);
    y = rij(j,1);
    z = rij(j,2);
    rsq = x * x + y * y + z * z;
    r = sqrt(rsq);

    theta0 = (r - rmin0) * rfac0 * MY_PI / (rcutij[j] - rmin0);
    //    theta0 = (r - rmin0) * rscale0;
    z0 = r / tan(theta0);

    compute_uarray(team,x, y, z, z0, r);
    //Kokkos::single(Kokkos::PerThread(team), [&] (){
    add_uarraytot(team,r, wj[j], rcutij[j]);
    //});
  });

}

/* ----------------------------------------------------------------------
   compute Zi by summing over products of Ui
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_zi(const Kokkos::TeamPolicy<>::member_type& team)
{
  // for j1 = 0,...,twojmax
  //   for j2 = 0,twojmax
  //     for j = |j1-j2|,Min(twojmax,j1+j2),2
  //        for ma = 0,...,j
  //          for mb = 0,...,jmid
  //            z(j1,j2,j,ma,mb) = 0
  //            for ma1 = Max(0,ma+(j1-j2-j)/2),Min(j1,ma+(j1+j2-j)/2)
  //              sumb1 = 0
  //              ma2 = ma-ma1+(j1+j2-j)/2;
  //              for mb1 = Max(0,mb+(j1-j2-j)/2),Min(j1,mb+(j1+j2-j)/2)
  //                mb2 = mb-mb1+(j1+j2-j)/2;
  //                sumb1 += cg(j1,mb1,j2,mb2,j) *
  //                  u(j1,ma1,mb1) * u(j2,ma2,mb2)
  //              z(j1,j2,j,ma,mb) += sumb1*cg(j1,ma1,j2,ma2,j)

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &starttime);
#endif

  // compute_dbidrj() requires full j1/j2/j chunk of z elements
  // use zarray j1/j2 symmetry

  Kokkos::parallel_for(Kokkos::TeamThreadRange(team,idxj_full_max),
      [&] (const int& idx) {
    const int j1 = idxj_full(idx).j1;
    const int j2 = idxj_full(idx).j2;
    const int j =  idxj_full(idx).j;

    const int bound = (j+2)/2;
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+1)*bound),
        [&] (const int mbma ) {
	//for(int mb = 0; 2*mb <= j; mb++)
	  //for(int ma = 0; ma <= j; ma++) {
      const int ma = mbma%(j+1);
      const int mb = mbma/(j+1);
	    //zarray_r(j1,j2,j,ma,mb) = 0.0;
	    //zarray_i(j1,j2,j,ma,mb) = 0.0;
      double z_r = 0.0;
      double z_i = 0.0;

	    for(int ma1 = MAX(0, (2 * ma - j - j2 + j1) / 2);
		ma1 <= MIN(j1, (2 * ma - j + j2 + j1) / 2); ma1++) {
	      double sumb1_r = 0.0;
	      double sumb1_i = 0.0;

	      const int ma2 = (2 * ma - j - (2 * ma1 - j1) + j2) / 2;

	      for(int mb1  = MAX( 0, (2 * mb - j - j2 + j1) / 2);
                mb1 <= MIN(j1, (2 * mb - j + j2 + j1) / 2); mb1++) {

		const int mb2 = (2 * mb - j - (2 * mb1 - j1) + j2) / 2;
    const double cga = cgarray(j1,j2,j,mb1,mb2);
    const double uat1_r = uarraytot_r(j1,ma1,mb1);
    const double uat1_i = uarraytot_i(j1,ma1,mb1);
    const double uat2_r = uarraytot_r(j2,ma2,mb2);
    const double uat2_i = uarraytot_i(j2,ma2,mb2);
    sumb1_r += cga * (uat1_r * uat2_r - uat1_i * uat2_i);
    sumb1_i += cga * (uat1_r * uat2_i + uat1_i * uat2_r);
		/*sumb1_r += cgarray(j1,j2,j,mb1,mb2) *
		  (uarraytot_r(j1,ma1,mb1) * uarraytot_r(j2,ma2,mb2) -
		   uarraytot_i(j1,ma1,mb1) * uarraytot_i(j2,ma2,mb2));
		sumb1_i += cgarray(j1,j2,j,mb1,mb2) *
		  (uarraytot_r(j1,ma1,mb1) * uarraytot_i(j2,ma2,mb2) +
		   uarraytot_i(j1,ma1,mb1) * uarraytot_r(j2,ma2,mb2));*/
	      } // end loop over mb1

        const double cga = cgarray(j1,j2,j,ma1,ma2);
	      z_r += sumb1_r * cga;//rray(j1,j2,j,ma1,ma2);
	      z_i += sumb1_i * cga;//rray(j1,j2,j,ma1,ma2);
	    } // end loop over ma1
      zarray_r(j1,j2,j,mb,ma) = z_r;
	    zarray_i(j1,j2,j,mb,ma) = z_i;
	  }); // end loop over ma, mb
    //  }
    //}
  });
      //} // end loop over j
    //} // end loop over j1, j2

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &endtime);
  timers[1] += (endtime.tv_sec - starttime.tv_sec + 1.0 *
                (endtime.tv_nsec - starttime.tv_nsec) / 1000000000);
#endif
}


/* ----------------------------------------------------------------------
   calculate derivative of Ui w.r.t. atom j
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_duidrj(const Kokkos::TeamPolicy<>::member_type& team,
                         double* rij, double wj, double rcut)
{
  double rsq, r, x, y, z, z0, theta0, cs, sn;
  double dz0dr;

  x = rij[0];
  y = rij[1];
  z = rij[2];
  rsq = x * x + y * y + z * z;
  r = sqrt(rsq);
  double rscale0 = rfac0 * MY_PI / (rcut - rmin0);
  theta0 = (r - rmin0) * rscale0;
  cs = cos(theta0);
  sn = sin(theta0);
  z0 = r * cs / sn;
  dz0dr = z0 / r - (r*rscale0) * (rsq + z0 * z0) / rsq;

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &starttime);
#endif

  compute_duarray(team, x, y, z, z0, r, dz0dr, wj, rcut);

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &endtime);
  timers[3] += (endtime.tv_sec - starttime.tv_sec + 1.0 *
                (endtime.tv_nsec - starttime.tv_nsec) / 1000000000);
#endif

}

/* ----------------------------------------------------------------------
   calculate derivative of Bi w.r.t. atom j
   variant using indexlist for j1,j2,j
   variant using symmetry relation
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_dbidrj(const Kokkos::TeamPolicy<>::member_type& team)
{
  // for j1 = 0,...,twojmax
  //   for j2 = 0,twojmax
  //     for j = |j1-j2|,Min(twojmax,j1+j2),2
  //        zdb = 0
  //        for mb = 0,...,jmid
  //          for ma = 0,...,j
  //            zdb +=
  //              Conj(dudr(j,ma,mb))*z(j1,j2,j,ma,mb)
  //        dbdr(j1,j2,j) += 2*zdb
  //        zdb = 0
  //        for mb1 = 0,...,j1mid
  //          for ma1 = 0,...,j1
  //            zdb +=
  //              Conj(dudr(j1,ma1,mb1))*z(j,j2,j1,ma1,mb1)
  //        dbdr(j1,j2,j) += 2*zdb*(j+1)/(j1+1)
  //        zdb = 0
  //        for mb2 = 0,...,j2mid
  //          for ma2 = 0,...,j2
  //            zdb +=
  //              Conj(dudr(j2,ma2,mb2))*z(j1,j,j2,ma2,mb2)
  //        dbdr(j1,j2,j) += 2*zdb*(j+1)/(j2+1)

  double* dudr_r, *dudr_i;
  double jjjmambzarray_r;
  double jjjmambzarray_i;

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &starttime);
#endif
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,idxj_max),
          [&] (const int& JJ) {
  //for(int JJ = 0; JJ < idxj_max; JJ++) {
    const int j1 = idxj[JJ].j1;
    const int j2 = idxj[JJ].j2;
    const int j = idxj[JJ].j;

//    dbdr = &dbarray(j1,j2,j,0);
//    dbdr[0] = 0.0;
//    dbdr[1] = 0.0;
//    dbdr[2] = 0.0;

    t_scalar3<double> dbdr,sumzdu_r;
    // Sum terms Conj(dudr(j,ma,mb))*z(j1,j2,j,ma,mb)

    // use zarray j1/j2 symmetry (optional)

    int j_,j1_,j2_;
    if (j1 >= j2) {
      //jjjzarray_r = &zarray_r(j1,j2,j);
      //jjjzarray_i = &zarray_i(j1,j2,j);
      j1_ = j1;
      j2_ = j2;
      j_ = j;
    } else {
      j1_ = j2;
      j2_ = j1;
      j_ = j;
      //jjjzarray_r = &zarray_r(j2,j1,j);
      //jjjzarray_i = &zarray_i(j2,j1,j);
    }

    for(int mb = 0; 2*mb < j; mb++)
      for(int ma = 0; ma <= j; ma++) {

        dudr_r = &duarray_r(j,mb,ma,0);
        dudr_i = &duarray_i(j,mb,ma,0);
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb,ma);
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb,ma);
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);

      } //end loop over ma mb

    // For j even, handle middle column

    if (j%2 == 0) {
      int mb = j/2;
      for(int ma = 0; ma <= mb; ma++) {
        dudr_r = &duarray_r(j,mb,ma,0);
        dudr_i = &duarray_i(j,mb,ma,0);
        const double factor = ma==mb?0.5:1.0;
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb,ma) * factor;
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb,ma) * factor;
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      }
    } // end if jeven

      dbdr += 2.0*sumzdu_r;

    // Sum over Conj(dudr(j1,ma1,mb1))*z(j,j2,j1,ma1,mb1)

    double j1fac = (j+1)/(j1+1.0);

    sumzdu_r.x = 0.0; sumzdu_r.y = 0.0; sumzdu_r.z = 0.0;

    // use zarray j1/j2 symmetry (optional)

    if (j >= j2) {
      j1_ = j;
      j2_ = j2;
      j_ = j1;

      //jjjzarray_r = zarray_r(j,j2,j1);
      //jjjzarray_i = zarray_i(j,j2,j1);
    } else {
      j1_ = j2;
      j2_ = j;
      j_ = j1;
      //jjjzarray_r = zarray_r(j2,j,j1);
      //jjjzarray_i = zarray_i(j2,j,j1);
    }

    for(int mb1 = 0; 2*mb1 < j1; mb1++)
      for(int ma1 = 0; ma1 <= j1; ma1++) {

        dudr_r = &duarray_r(j1,mb1,ma1,0);
        dudr_i = &duarray_i(j1,mb1,ma1,0);
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb1,ma1);
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb1,ma1);
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      } //end loop over ma1 mb1

    // For j1 even, handle middle column

    if (j1%2 == 0) {
      const int mb1 = j1/2;
      for(int ma1 = 0; ma1 <= mb1; ma1++) {
        dudr_r = &duarray_r(j1,mb1,ma1,0);
        dudr_i = &duarray_i(j1,mb1,ma1,0);
        const double factor = ma1==mb1?0.5:1.0;
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb1,ma1) * factor;
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb1,ma1) * factor;
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      }
    } // end if j1even

      dbdr += 2.0*sumzdu_r*j1fac;

    // Sum over Conj(dudr(j2,ma2,mb2))*z(j1,j,j2,ma2,mb2)

    double j2fac = (j+1)/(j2+1.0);

    sumzdu_r.x = 0.0; sumzdu_r.y = 0.0; sumzdu_r.z = 0.0;

    // use zarray j1/j2 symmetry (optional)

    if (j1 >= j) {
      j1_ = j1;
      j2_ = j;
      j_ = j2;
      //jjjzarray_r = zarray_r(j1,j,j2);
      //jjjzarray_i = zarray_i(j1,j,j2);
    } else {
      j1_ = j;
      j2_ = j1;
      j_ = j2;
      //jjjzarray_r = zarray_r(j,j1,j2);
      //jjjzarray_i = zarray_i(j,j1,j2);
    }

    for(int mb2 = 0; 2*mb2 < j2; mb2++)
      for(int ma2 = 0; ma2 <= j2; ma2++) {

        dudr_r = &duarray_r(j2,mb2,ma2,0);
        dudr_i = &duarray_i(j2,mb2,ma2,0);
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb2,ma2);
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb2,ma2);
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      } //end loop over ma2 mb2

    // For j2 even, handle middle column

    if (j2%2 == 0) {
      const int mb2 = j2/2;
      for(int ma2 = 0; ma2 <= mb2; ma2++) {
        dudr_r = &duarray_r(j2,mb2,ma2,0);
        dudr_i = &duarray_i(j2,mb2,ma2,0);
        const double factor = ma2==mb2?0.5:1.0;
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb2,ma2) * factor;
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb2,ma2) * factor;
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      }
    } // end if j2even

    dbdr += 2.0*sumzdu_r*j2fac;
    dbarray(j1,j2,j,0) = dbdr.x;
    dbarray(j1,j2,j,1) = dbdr.y;
    dbarray(j1,j2,j,2) = dbdr.z;
  }); //end loop over j1 j2 j

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &endtime);
  timers[4] += (endtime.tv_sec - starttime.tv_sec + 1.0 *
                (endtime.tv_nsec - starttime.tv_nsec) / 1000000000);
#endif

}

/* ----------------------------------------------------------------------
   copy Bi derivatives into a vector
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::copy_dbi2dbvec(const Kokkos::TeamPolicy<>::member_type& team)
{
 /* int ncount, j1, j2, j;

  ncount = 0;

  for(j1 = 0; j1 <= twojmax; j1++) {
      for(j2 = 0; j2 <= j1; j2++)
        for(j = abs(j1 - j2);
            j <= MIN(twojmax, j1 + j2); j += 2)
	  if (j >= j1) {*/
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,idxj_max),
          [&] (const int& JJ) {
  //for(int JJ = 0; JJ < idxj_max; JJ++) {
    const int j1 = idxj[JJ].j1;
    const int j2 = idxj[JJ].j2;
    const int j = idxj[JJ].j;

	    dbvec(JJ,0) = dbarray(j1,j2,j,0);
	    dbvec(JJ,1) = dbarray(j1,j2,j,1);
	    dbvec(JJ,2) = dbarray(j1,j2,j,2);
	    //ncount++;
	  //});
  });
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::zero_uarraytot(const Kokkos::TeamPolicy<>::member_type& team)
{
  {
    double* const ptr = uarraytot_r.data();
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,uarraytot_r.span()),
        [&] (const int& i) {
      ptr[i] = 0.0;
    });
  }
  {
    double* const ptr = uarraytot_i.data();
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,uarraytot_r.span()),
        [&] (const int& i) {
      ptr[i] = 0.0;
    });
  }
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::addself_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double wself_in)
{
  //for (int j = 0; j <= twojmax; j++)
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,twojmax+1),
    [&] (const int& j) {
    for (int ma = 0; ma <= j; ma++) {
      uarraytot_r(j,ma,ma) = wself_in;
      uarraytot_i(j,ma,ma) = 0.0;
    }
  });
}

/* ----------------------------------------------------------------------
   add Wigner U-functions for one neighbor to the total
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::add_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double r, double wj, double rcut)
{
  const double sfac = compute_sfac(r, rcut) * wj;

/*
  for (int j = 0; j <= twojmax; j++)
    for (int ma = 0; ma <= j; ma++)
      for (int mb = 0; mb <= j; mb++) {
        uarraytot_r_a(j,ma,mb) +=
          sfac * uarray_r(j,ma,mb);
        uarraytot_i_a(j,ma,mb) +=
          sfac * uarray_i(j,ma,mb);
      }*/
  const double* const ptr_r = uarray_r.data();
  const double* const ptr_i = uarray_i.data();
  double* const ptrtot_r = uarraytot_r.data();
  double* const ptrtot_i = uarraytot_i.data();
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,uarraytot_r.span()),
      [&] (const int& i) {
    Kokkos::atomic_add(ptrtot_r+i, sfac * ptr_r[i]);
    Kokkos::atomic_add(ptrtot_i+i, sfac * ptr_i[i]);
  });
}

/* ----------------------------------------------------------------------
   compute Wigner U-functions for one neighbor
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_uarray(const Kokkos::TeamPolicy<>::member_type& team,
                         double x, double y, double z,
                         double z0, double r)
{
  double r0inv;
  double a_r, b_r, a_i, b_i;
  double rootpq;

  // compute Cayley-Klein parameters for unit quaternion

  r0inv = 1.0 / sqrt(r * r + z0 * z0);
  a_r = r0inv * z0;
  a_i = -r0inv * z;
  b_r = r0inv * y;
  b_i = -r0inv * x;

  // VMK Section 4.8.2

  uarray_r(0,0,0) = 1.0;
  uarray_i(0,0,0) = 0.0;

  for (int j = 1; j <= twojmax; j++) {

    // fill in left side of matrix layer from previous layer

    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {
      //const int mb = 2*mb_2;
    //for (int mb = 0; 2*mb <= j; mb++) {
      uarray_r(j,0,mb) = 0.0;
      uarray_i(j,0,mb) = 0.0;

      for (int ma = 0; ma < j; ma++) {
	rootpq = rootpqarray(j - ma,j - mb);
        uarray_r(j,ma,mb) +=
          rootpq *
          (a_r * uarray_r(j - 1,ma,mb) +
	   a_i * uarray_i(j - 1,ma,mb));
        uarray_i(j,ma,mb) +=
          rootpq *
          (a_r * uarray_i(j - 1,ma,mb) -
	   a_i * uarray_r(j - 1,ma,mb));

	rootpq = rootpqarray(ma + 1,j - mb);
        uarray_r(j,ma + 1,mb) =
          -rootpq *
          (b_r * uarray_r(j - 1,ma,mb) +
	   b_i * uarray_i(j - 1,ma,mb));
        uarray_i(j,ma + 1,mb) =
          -rootpq *
          (b_r * uarray_i(j - 1,ma,mb) -
	   b_i * uarray_r(j - 1,ma,mb));
      }
    });

    // copy left side to right side with inversion symmetry VMK 4.4(2)
    // u[ma-j,mb-j] = (-1)^(ma-mb)*Conj([u[ma,mb))

    //int mbpar = -1;
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {
//    for (int mb = 0; 2*mb <= j; mb++) {
      int mbpar = (mb)%2==0?1:-1;
      int mapar = -mbpar;
      for (int ma = 0; ma <= j; ma++) {
    	mapar = -mapar;
    	if (mapar == 1) {
    	  uarray_r(j,j-ma,j-mb) = uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = -uarray_i(j,ma,mb);
    	} else {
    	  uarray_r(j,j-ma,j-mb) = -uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = uarray_i(j,ma,mb);
    	}
    	//OK
    	//printf("%lf %lf %lf %lf %lf %lf %lf SNAP-COMPARE: UARRAY\n",x,y,z,z0,r,uarray_r(j,ma,mb),uarray_i(j,ma,mb));
      }
    });
  }
}


/* ----------------------------------------------------------------------
   compute derivatives of Wigner U-functions for one neighbor
   see comments in compute_uarray()
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_duarray(const Kokkos::TeamPolicy<>::member_type& team,
                          double x, double y, double z,
                          double z0, double r, double dz0dr,
			  double wj, double rcut)
{
  double r0inv;
  double a_r, a_i, b_r, b_i;
  double da_r[3], da_i[3], db_r[3], db_i[3];
  double dz0[3], dr0inv[3], dr0invdr;
  double rootpq;

  double rinv = 1.0 / r;
  double ux = x * rinv;
  double uy = y * rinv;
  double uz = z * rinv;

  r0inv = 1.0 / sqrt(r * r + z0 * z0);
  a_r = z0 * r0inv;
  a_i = -z * r0inv;
  b_r = y * r0inv;
  b_i = -x * r0inv;

  dr0invdr = -pow(r0inv, 3.0) * (r + z0 * dz0dr);

  dr0inv[0] = dr0invdr * ux;
  dr0inv[1] = dr0invdr * uy;
  dr0inv[2] = dr0invdr * uz;

  dz0[0] = dz0dr * ux;
  dz0[1] = dz0dr * uy;
  dz0[2] = dz0dr * uz;

  for (int k = 0; k < 3; k++) {
    da_r[k] = dz0[k] * r0inv + z0 * dr0inv[k];
    da_i[k] = -z * dr0inv[k];
  }

  da_i[2] += -r0inv;

  for (int k = 0; k < 3; k++) {
    db_r[k] = y * dr0inv[k];
    db_i[k] = -x * dr0inv[k];
  }

  db_i[0] += -r0inv;
  db_r[1] += r0inv;

  uarray_r(0,0,0) = 1.0;
  duarray_r(0,0,0,0) = 0.0;
  duarray_r(0,0,0,1) = 0.0;
  duarray_r(0,0,0,2) = 0.0;
  uarray_i(0,0,0) = 0.0;
  duarray_i(0,0,0,0) = 0.0;
  duarray_i(0,0,0,1) = 0.0;
  duarray_i(0,0,0,2) = 0.0;

  for (int j = 1; j <= twojmax; j++) {
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {

    //for (int mb = 0; 2*mb <= j; mb++) {
      uarray_r(j,0,mb) = 0.0;
      duarray_r(j,mb,0,0) = 0.0;
      duarray_r(j,mb,0,1) = 0.0;
      duarray_r(j,mb,0,2) = 0.0;
      uarray_i(j,0,mb) = 0.0;
      duarray_i(j,mb,0,0) = 0.0;
      duarray_i(j,mb,0,1) = 0.0;
      duarray_i(j,mb,0,2) = 0.0;

      for (int ma = 0; ma < j; ma++) {
        rootpq = rootpqarray(j - ma,j - mb);
        uarray_r(j,ma,mb) += rootpq *
                               (a_r *  uarray_r(j - 1,ma,mb) +
                                a_i *  uarray_i(j - 1,ma,mb));
        uarray_i(j,ma,mb) += rootpq *
                               (a_r *  uarray_i(j - 1,ma,mb) -
                                a_i *  uarray_r(j - 1,ma,mb));

        for (int k = 0; k < 3; k++) {
          duarray_r(j,mb,ma,k) +=
            rootpq * (da_r[k] * uarray_r(j - 1,ma,mb) +
                      da_i[k] * uarray_i(j - 1,ma,mb) +
                      a_r * duarray_r(j - 1,mb,ma,k) +
                      a_i * duarray_i(j - 1,mb,ma,k));
          duarray_i(j,mb,ma,k) +=
            rootpq * (da_r[k] * uarray_i(j - 1,ma,mb) -
                      da_i[k] * uarray_r(j - 1,ma,mb) +
                      a_r * duarray_i(j - 1,mb,ma,k) -
                      a_i * duarray_r(j - 1,mb,ma,k));
        }

	rootpq = rootpqarray(ma + 1,j - mb);
        uarray_r(j,ma + 1,mb) =
          -rootpq * (b_r *  uarray_r(j - 1,ma,mb) +
                     b_i *  uarray_i(j - 1,ma,mb));
        uarray_i(j,ma + 1,mb) =
          -rootpq * (b_r *  uarray_i(j - 1,ma,mb) -
                     b_i *  uarray_r(j - 1,ma,mb));

        for (int k = 0; k < 3; k++) {
          duarray_r(j,mb,ma + 1,k) =
            -rootpq * (db_r[k] * uarray_r(j - 1,ma,mb) +
                       db_i[k] * uarray_i(j - 1,ma,mb) +
                       b_r * duarray_r(j - 1,mb,ma,k) +
                       b_i * duarray_i(j - 1,mb,ma,k));
          duarray_i(j,mb,ma + 1,k) =
            -rootpq * (db_r[k] * uarray_i(j - 1,ma,mb) -
                       db_i[k] * uarray_r(j - 1,ma,mb) +
                       b_r * duarray_i(j - 1,mb,ma,k) -
                       b_i * duarray_r(j - 1,mb,ma,k));
        }
      }
    });

    //int mbpar = -1;
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {
//    for (int mb = 0; 2*mb <= j; mb++) {
      int mbpar = (mb)%2==0?1:-1;
      int mapar = -mbpar;
      for (int ma = 0; ma <= j; ma++) {
    	mapar = -mapar;
    	if (mapar == 1) {
    	  uarray_r(j,j-ma,j-mb) = uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = -uarray_i(j,ma,mb);
    	  for (int k = 0; k < 3; k++) {
    	    duarray_r(j,j-mb,j-ma,k) = duarray_r(j,mb,ma,k);
    	    duarray_i(j,j-mb,j-ma,k) = -duarray_i(j,mb,ma,k);
    	  }
    	} else {
    	  uarray_r(j,j-ma,j-mb) = -uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = uarray_i(j,ma,mb);
    	  for (int k = 0; k < 3; k++) {
    	    duarray_r(j,j-mb,j-ma,k) = -duarray_r(j,mb,ma,k);
    	    duarray_i(j,j-mb,j-ma,k) = duarray_i(j,mb,ma,k);
    	  }
    	}
      }
    });
  }

  double sfac = compute_sfac(r, rcut);
  double dsfac = compute_dsfac(r, rcut);

  sfac *= wj;
  dsfac *= wj;

  for (int j = 0; j <= twojmax; j++)
    for (int mb = 0; mb <= j; mb++) 
      for (int ma = 0; ma <= j; ma++) {
        duarray_r(j,mb,ma,0) = dsfac * uarray_r(j,ma,mb) * ux +
                                  sfac * duarray_r(j,mb,ma,0);
        duarray_i(j,mb,ma,0) = dsfac * uarray_i(j,ma,mb) * ux +
                                  sfac * duarray_i(j,mb,ma,0);
        duarray_r(j,mb,ma,1) = dsfac * uarray_r(j,ma,mb) * uy +
                                  sfac * duarray_r(j,mb,ma,1);
        duarray_i(j,mb,ma,1) = dsfac * uarray_i(j,ma,mb) * uy +
                                  sfac * duarray_i(j,mb,ma,1);
        duarray_r(j,mb,ma,2) = dsfac * uarray_r(j,ma,mb) * uz +
                                  sfac * duarray_r(j,mb,ma,2);
        duarray_i(j,mb,ma,2) = dsfac * uarray_i(j,ma,mb) * uz +
                                  sfac * duarray_i(j,mb,ma,2);
      }
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::create_team_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team)
{
  int jdim = twojmax + 1;
  uarraytot_r_a = uarraytot_r = t_sna_3d(team.team_scratch(1),jdim,jdim,jdim);
  uarraytot_i_a = uarraytot_i = t_sna_3d(team.team_scratch(1),jdim,jdim,jdim);
  zarray_r = t_sna_5d(team.team_scratch(1),jdim,jdim,jdim,jdim,jdim);
  zarray_i = t_sna_5d(team.team_scratch(1),jdim,jdim,jdim,jdim,jdim);

  rij = t_sna_2d(team.team_scratch(1),nmax,3);
  rcutij = t_sna_1d(team.team_scratch(1),nmax);
  wj = t_sna_1d(team.team_scratch(1),nmax);
  inside = t_sna_1i(team.team_scratch(1),nmax);
}


inline
T_INT SNA::size_team_scratch_arrays() {
  T_INT size = 0;
  int jdim = twojmax + 1;

  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_5d::shmem_size(jdim,jdim,jdim,jdim,jdim);
  size += t_sna_5d::shmem_size(jdim,jdim,jdim,jdim,jdim);

  size += t_sna_2d::shmem_size(nmax,3);
  size += t_sna_1d::shmem_size(nmax);
  size += t_sna_1d::shmem_size(nmax);
  size += t_sna_1i::shmem_size(nmax);

  return size;
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::create_thread_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team)
{
  int jdim = twojmax + 1;
  dbvec = Kokkos::View<double*[3], Kokkos::LayoutRight>(team.thread_scratch(1),ncoeff);
  dbarray = t_sna_4d(team.thread_scratch(1),jdim,jdim,jdim);

  uarray_r = t_sna_3d(team.thread_scratch(1),jdim,jdim,jdim);
  uarray_i = t_sna_3d(team.thread_scratch(1),jdim,jdim,jdim);
  duarray_r = t_sna_4d(team.thread_scratch(1),jdim,jdim,jdim);
  duarray_i = t_sna_4d(team.thread_scratch(1),jdim,jdim,jdim);
}

inline
T_INT SNA::size_thread_scratch_arrays() {
  T_INT size = 0;
  int jdim = twojmax + 1;
  size += Kokkos::View<double*[3], Kokkos::LayoutRight>::shmem_size(ncoeff);
  size += t_sna_4d::shmem_size(jdim,jdim,jdim);

  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_4d::shmem_size(jdim,jdim,jdim);
  size += t_sna_4d::shmem_size(jdim,jdim,jdim);
  return size;
}

/* ----------------------------------------------------------------------
   factorial n
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::factorial(int n)
{
  double result = 1.0;
  for(int i=1; i<=n; i++)
    result *= 1.0*i;
  return result;
}

/* ----------------------------------------------------------------------
   the function delta given by VMK Eq. 8.2(1)
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::deltacg(int j1, int j2, int j)
{
  double sfaccg = factorial((j1 + j2 + j) / 2 + 1);
  return sqrt(factorial((j1 + j2 - j) / 2) *
              factorial((j1 - j2 + j) / 2) *
              factorial((-j1 + j2 + j) / 2) / sfaccg);
}

/* ----------------------------------------------------------------------
   assign Clebsch-Gordan coefficients using
   the quasi-binomial formula VMK 8.2.1(3)
------------------------------------------------------------------------- */

inline
void SNA::init_clebsch_gordan()
{
  double sum,dcg,sfaccg;
  int m, aa2, bb2, cc2;
  int ifac;
  auto h_cgarray = Kokkos::create_mirror_view(cgarray);

  for (int j1 = 0; j1 <= twojmax; j1++)
    for (int j2 = 0; j2 <= twojmax; j2++)
      for (int j = abs(j1 - j2); j <= MIN(twojmax, j1 + j2); j += 2)
        for (int m1 = 0; m1 <= j1; m1 += 1) {
          aa2 = 2 * m1 - j1;

          for (int m2 = 0; m2 <= j2; m2 += 1) {

            // -c <= cc <= c

            bb2 = 2 * m2 - j2;
            m = (aa2 + bb2 + j) / 2;

            if(m < 0 || m > j) continue;

	    sum = 0.0;

	    for (int z = MAX(0, MAX(-(j - j2 + aa2)
				   / 2, -(j - j1 - bb2) / 2));
		z <= MIN((j1 + j2 - j) / 2,
			 MIN((j1 - aa2) / 2, (j2 + bb2) / 2));
		z++) {
	      ifac = z % 2 ? -1 : 1;
	      sum += ifac /
		(factorial(z) *
		 factorial((j1 + j2 - j) / 2 - z) *
		 factorial((j1 - aa2) / 2 - z) *
		 factorial((j2 + bb2) / 2 - z) *
		 factorial((j - j2 + aa2) / 2 + z) *
		 factorial((j - j1 - bb2) / 2 + z));
	    }

	    cc2 = 2 * m - j;
	    dcg = deltacg(j1, j2, j);
	    sfaccg = sqrt(factorial((j1 + aa2) / 2) *
			factorial((j1 - aa2) / 2) *
			factorial((j2 + bb2) / 2) *
			factorial((j2 - bb2) / 2) *
			factorial((j  + cc2) / 2) *
			factorial((j  - cc2) / 2) *
			(j + 1));

	    h_cgarray(j1,j2,j,m1,m2) = sum * dcg * sfaccg;
	    //printf("SNAP-COMPARE: CG: %i %i %i %i %i %e\n",j1,j2,j,m1,m2,cgarray(j1,j2,j,m1,m2));
	  }
	}
  Kokkos::deep_copy(cgarray,h_cgarray);
}

/* ----------------------------------------------------------------------
   pre-compute table of sqrt[p/m2], p, q = 1,twojmax
   the p = 0, q = 0 entries are allocated and skipped for convenience.
------------------------------------------------------------------------- */

inline
void SNA::init_rootpqarray()
{
  auto h_rootpqarray = Kokkos::create_mirror_view(rootpqarray);
  for (int p = 1; p <= twojmax; p++)
    for (int q = 1; q <= twojmax; q++)
      h_rootpqarray(p,q) = sqrt(static_cast<double>(p)/q);
  Kokkos::deep_copy(rootpqarray,h_rootpqarray);
}


/* ---------------------------------------------------------------------- */
inline
int SNA::compute_ncoeff()
{
  int ncount;

  ncount = 0;

  for (int j1 = 0; j1 <= twojmax; j1++)
    if(diagonalstyle == 0) {
      for (int j2 = 0; j2 <= j1; j2++)
        for (int j = abs(j1 - j2);
            j <= MIN(twojmax, j1 + j2); j += 2)
          ncount++;
    } else if(diagonalstyle == 1) {
      int j2 = j1;

      for (int j = abs(j1 - j2);
          j <= MIN(twojmax, j1 + j2); j += 2)
        ncount++;
    } else if(diagonalstyle == 2) {
      ncount++;
    } else if(diagonalstyle == 3) {
      for (int j2 = 0; j2 <= j1; j2++)
        for (int j = abs(j1 - j2);
            j <= MIN(twojmax, j1 + j2); j += 2)
          if (j >= j1) ncount++;
    }

  return ncount;
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::compute_sfac(double r, double rcut)
{
  if (switch_flag == 0) return 1.0;
  if (switch_flag == 1) {
    if(r <= rmin0) return 1.0;
    else if(r > rcut) return 0.0;
    else {
      double rcutfac = MY_PI / (rcut - rmin0);
      return 0.5 * (cos((r - rmin0) * rcutfac) + 1.0);
    }
  }
  return 0.0;
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::compute_dsfac(double r, double rcut)
{
  if (switch_flag == 0) return 0.0;
  if (switch_flag == 1) {
    if(r <= rmin0) return 0.0;
    else if(r > rcut) return 0.0;
    else {
      double rcutfac = MY_PI / (rcut - rmin0);
      return -0.5 * sin((r - rmin0) * rcutfac) * rcutfac;
    }
  }
  return 0.0;
}



---

# CMakeLists.txt

SET(HEADERS
  neighbor_2d.h
  neighbor_csr.h
  neighbor_csr_map_constr.h)

SET(SOURCES
  neighbor_2d.cpp
  neighbor_csr.cpp
  neighbor_csr_map_constr.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# neighbor_2d.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <neighbor_2d.h>

#ifdef EMD_ENABLE_GPU
template struct Neighbor2D<t_neigh_mem_space>;
#endif
template struct Neighbor2D<Kokkos::HostSpace>;



---

# neighbor_2d.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Runtime Check for this Neighbor Class
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "2D") == 0) )
        neighbor_type = NEIGH_2D;
#endif

// Instantiation and Init of this class
#ifdef NEIGHBOR_MODULES_INSTANTIATION
    else if (input->neighbor_type == NEIGH_2D) {
      neighbor = new Neighbor2D<t_neigh_mem_space>();
      neighbor->init(input->force_cutoff + input->neighbor_skin);
    }
#endif

// Add Force Instantiation case
#if defined(FORCE_MODULES_INSTANTIATION)
      case NEIGH_2D: force = new FORCETYPE_ALLOCATION_MACRO(Neighbor2D<t_neigh_mem_space>); break;
#endif

// Add Force declaration line
#if defined(FORCE_MODULES_EXTERNAL_TEMPLATE)
      extern template class FORCETYPE_DECLARE_TEMPLATE_MACRO(Neighbor2D<t_neigh_mem_space>);
#endif

// Add Force Template Instantiation line
#if defined(FORCE_MODULES_TEMPLATE)
      template class FORCETYPE_DECLARE_TEMPLATE_MACRO(Neighbor2D<t_neigh_mem_space>);
#endif

// Making sure we are not just instantiating some Option
#if !defined(MODULES_OPTION_CHECK) && \
    !defined(NEIGHBOR_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_EXTERNAL_TEMPLATE) && \
    !defined(FORCE_MODULES_TEMPLATE)
#include <neighbor.h>
#ifndef NEIGHBOR_2D_H
#define NEIGHBOR_2D_H
#include <system.h>
#include <binning.h>

template<class MemorySpace>
struct NeighList2D {
  struct NeighView2D {
    private:
      T_INT* const ptr;
      const T_INT num_neighs;
      const T_INT stride;

    public:
      KOKKOS_INLINE_FUNCTION
      NeighView2D (T_INT* const ptr_, const T_INT& num_neighs_, const T_INT& stride_):
        ptr(ptr_),num_neighs(num_neighs_),stride(stride_) {}

      KOKKOS_INLINE_FUNCTION
      T_INT& operator() (const T_INT& i) const { return ptr[i*stride]; }

      KOKKOS_INLINE_FUNCTION
      T_INT get_num_neighs() const { return num_neighs; }
  };

  typedef NeighView2D t_neighs;

  NeighList2D() {
    maxneighs = 16;
  }

  KOKKOS_INLINE_FUNCTION
  T_INT get_num_neighs(const T_INT& i) const {
    return this->num_neighs(i);
  }

  KOKKOS_INLINE_FUNCTION
  t_neighs get_neighs(const T_INT& i) const {
    return t_neighs(&this->neighs(i,0),this->num_neighs(i),&this->neighs(i,1)-&this->neighs(i,0));
  }

  T_INT maxneighs;

  Kokkos::View<T_INT*, MemorySpace> num_neighs;
  Kokkos::View<T_INT**, MemorySpace> neighs;
};

template<class MemorySpace>
class Neighbor2D: public Neighbor {

protected:
  T_X_FLOAT neigh_cut;
  t_x x;
  t_type type;
  t_id id;

  T_INT nbinx,nbiny,nbinz,nhalo;
  T_INT N_local;

  bool skip_num_neigh_count, half_neigh;

  typename Binning::t_binoffsets bin_offsets;
  typename Binning::t_bincount bin_count;
  typename Binning::t_permute_vector permute_vector;

  Kokkos::View<T_INT, MemorySpace> resize,new_maxneighs;
  typename Kokkos::View<T_INT, MemorySpace>::HostMirror h_resize,h_new_maxneighs;


public:
  struct TagFillNeighListFull {};
  struct TagFillNeighListHalf {};

  typedef Kokkos::TeamPolicy<TagFillNeighListFull, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlf;
  typedef Kokkos::TeamPolicy<TagFillNeighListHalf, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlh;

  typedef NeighList2D<MemorySpace> t_neigh_list;

  t_neigh_list neigh_list;


  Neighbor2D():neigh_cut(0.0) {
    neigh_type = NEIGH_2D;

    resize = Kokkos::View<T_INT, MemorySpace> ("Neighbor2D::resize");
    new_maxneighs = Kokkos::View<T_INT, MemorySpace> ("Neighbor2D::new_maxneighs");

    h_resize = Kokkos::create_mirror_view(resize);
    h_new_maxneighs = Kokkos::create_mirror_view(new_maxneighs);
  };
  ~Neighbor2D() {};

  void init(T_X_FLOAT neigh_cut_) {
    neigh_cut = neigh_cut_;

    // Create actual 2D NeighList
    neigh_list = t_neigh_list();
  };

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillNeighListFull&, const typename t_policy_fnlf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
          T_INT j = permute_vector(j_offset + bj);

          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            T_INT n = Kokkos::atomic_fetch_add(&neigh_list.num_neighs(i),1); // n is non-incremented (old) value, could use parallel_scan instead
            if (n < neigh_list.maxneighs)
              neighs_i(n) = j;
          }
        });
      }
       Kokkos::single(Kokkos::PerThread(team), [&] () {
         const T_INT num_neighs_i = neigh_list.num_neighs(i);
         if (num_neighs_i > neigh_list.maxneighs) {
           resize() = 1;
           new_maxneighs() = num_neighs_i; // may resize more times than necessary, but probably less expensive than using an atomic max
         }
       });
    });
  }

  KOKKOS_INLINE_FUNCTION
   void operator() (const TagFillNeighListHalf&, const typename t_policy_fnlh::member_type& team) const {
     const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
     const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
     const T_INT bz = team.league_rank() % nbinz + nhalo;


     const T_INT i_offset = bin_offsets(bx,by,bz);
     Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
       const T_INT i = permute_vector(i_offset + bi);
       if(i>=N_local) return;
       const typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);
       const T_F_FLOAT x_i = x(i,0);
       const T_F_FLOAT y_i = x(i,1);
       const T_F_FLOAT z_i = x(i,2);
       const int type_i = type(i);

       for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
       for(int by_j = by-1; by_j<by+2; by_j++)
       for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

       /*  if( ( (bx_j<bx) || ((bx_j == bx) && ( (by_j>by) ||  ((by_j==by) && (bz_j>bz) )))) &&    
             (bx_j>=nhalo) && (bx_j<nbinx+nhalo-1) &&    
             (by_j>=nhalo) && (by_j<nbiny+nhalo-1) &&
             (bz_j>=nhalo) && (bz_j<nbinz+nhalo-1)    
           ) continue;
*/
         const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
           Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
             T_INT j = permute_vector(j_offset + bj);
             const T_F_FLOAT x_j = x(j,0);
             const T_F_FLOAT y_j = x(j,1);
             const T_F_FLOAT z_j = x(j,2);
             if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
               return;
             const T_F_FLOAT dx = x_i - x_j;
             const T_F_FLOAT dy = y_i - y_j;
             const T_F_FLOAT dz = z_i - z_j;

             const int type_j = type(j);
             const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

             if((rsq <= neigh_cut*neigh_cut)) {
               T_INT n = Kokkos::atomic_fetch_add(&neigh_list.num_neighs(i),1); // n is non-incremented (old) value, could use parallel_scan instead
               if (n < neigh_list.maxneighs)
                 neighs_i(n) = j;
             }
           });
       }
       Kokkos::single(Kokkos::PerThread(team), [&] () {
         const T_INT num_neighs_i = neigh_list.num_neighs(i);
         if (num_neighs_i > neigh_list.maxneighs) {
           resize() = 1;
           new_maxneighs() = num_neighs_i; // may resize more times than necessary, but probably less expensive than using an atomic max
         }
       });
     });
   }

  void create_neigh_list(System* system, Binning* binning, bool half_neigh_, bool) {
    // Get some data handles
    N_local = system->N_local;
    x = system->x;
    type = system->type;
    id = system->id;
    half_neigh = half_neigh_;

    // Reset the neighbor count array
    if( neigh_list.num_neighs.extent(0) < N_local + 1 )
      neigh_list.num_neighs = Kokkos::View<T_INT*, MemorySpace>("Neighbors2D::num_neighs", N_local + 1);

    // Create the pair list
    nhalo = binning->nhalo;
    nbinx = binning->nbinx - 2*nhalo;
    nbiny = binning->nbiny - 2*nhalo;
    nbinz = binning->nbinz - 2*nhalo;

    T_INT nbins = nbinx*nbiny*nbinz;

    bin_offsets = binning->binoffsets;
    bin_count = binning->bincount;
    permute_vector = binning->permute_vector;

    do {

      // Resize NeighborList
      if( neigh_list.neighs.extent(0) < N_local + 1 || neigh_list.neighs.extent(1) < neigh_list.maxneighs )
        neigh_list.neighs = Kokkos::View<T_INT**, MemorySpace> ("Neighbor2D::neighs", N_local + 1, neigh_list.maxneighs);


      // Fill the NeighborList
      Kokkos::deep_copy(neigh_list.num_neighs,0);
      Kokkos::deep_copy(resize,0);

      if(half_neigh)
        Kokkos::parallel_for("Neighbor2D::fill_neigh_list_half",t_policy_fnlh(nbins,Kokkos::AUTO,8),*this);
      else
        Kokkos::parallel_for("Neighbor2D::fill_neigh_list_full",t_policy_fnlf(nbins,Kokkos::AUTO,8),*this);


      Kokkos::fence();

      Kokkos::deep_copy(h_resize,resize);

      if (h_resize()) {
        Kokkos::deep_copy(h_new_maxneighs, new_maxneighs);
        neigh_list.maxneighs = h_new_maxneighs() * 1.2;
      }
    }
    while (h_resize());
  }

  t_neigh_list get_neigh_list() { return neigh_list; }
  const char* name() {return "Neighbor2D";}
};

template<>
struct NeighborAdaptor<NEIGH_2D> {
  typedef Neighbor2D<t_neigh_mem_space> type;
};

extern template struct Neighbor2D<t_neigh_mem_space>;
#endif // #define NEIGHBOR_2D_H
#endif // MODULES_OPTION_CHECK / MODULES_INSTANTIATION


---

# neighbor_csr.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <neighbor_csr.h>

#ifdef EMD_ENABLE_GPU
template struct NeighborCSR<t_neigh_mem_space>;
#endif
template struct NeighborCSR<Kokkos::HostSpace>;



---

# neighbor_csr.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Runtime Check for this Neighbor Class
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "CSR") == 0) )
        neighbor_type = NEIGH_CSR;
#endif

// Instantiation and Init of this class
#ifdef NEIGHBOR_MODULES_INSTANTIATION
    else if (input->neighbor_type == NEIGH_CSR) {
      neighbor = new NeighborCSR<t_neigh_mem_space>();
      neighbor->init(input->force_cutoff + input->neighbor_skin);
    }
#endif

// Add Force Instantiation case
#if defined(FORCE_MODULES_INSTANTIATION)
      case NEIGH_CSR: force = new FORCETYPE_ALLOCATION_MACRO(NeighborCSR<t_neigh_mem_space>); break;
#endif

// Add Force declaration line
#if defined(FORCE_MODULES_EXTERNAL_TEMPLATE)
      extern template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSR<t_neigh_mem_space>);
#endif

// Add Force Template Instantiation line
#if defined(FORCE_MODULES_TEMPLATE)
      template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSR<t_neigh_mem_space>);
#endif

// Making sure we are not just instantiating some Option
#if !defined(MODULES_OPTION_CHECK) && \
    !defined(NEIGHBOR_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_EXTERNAL_TEMPLATE) && \
    !defined(FORCE_MODULES_TEMPLATE)
#include <neighbor.h>
#ifndef NEIGHBOR_CSR_H
#define NEIGHBOR_CSR_H
#include <Kokkos_StaticCrsGraph.hpp>
#include <system.h>
#include <binning.h>

template<class MemorySpace>
struct NeighListCSR : public Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT> {
  struct NeighViewCSR {
    private:
      const T_INT* const ptr;
      const T_INT num_neighs;

    public:
      KOKKOS_INLINE_FUNCTION
      NeighViewCSR (const T_INT* const ptr_, const T_INT& num_neighs_):
        ptr(ptr_),num_neighs(num_neighs_) {}

      KOKKOS_INLINE_FUNCTION
      T_INT operator() (const T_INT& i) const { return ptr[i]; }

      KOKKOS_INLINE_FUNCTION
      T_INT get_num_neighs() const { return num_neighs; }
  };

  typedef NeighViewCSR t_neighs;

  NeighListCSR() :
    Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT>() {}
  NeighListCSR (const NeighListCSR& rhs) :
    Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT>(rhs) {
  }

  template<class EntriesType, class RowMapType>
  NeighListCSR (const EntriesType& entries_,const RowMapType& row_map_) :
    Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT>( entries_, row_map_) {}


  KOKKOS_INLINE_FUNCTION
  T_INT get_num_neighs(const T_INT& i) const {
    return this->row_map(i+1) - this->row_map(i);
  }

  KOKKOS_INLINE_FUNCTION
  t_neighs get_neighs(const T_INT& i) const {
    const T_INT start = this->row_map(i);
    const T_INT end = this->row_map(i+1);
    return t_neighs(&this->entries(start),end-start);
  }
};

template<class MemorySpace>
class NeighborCSR: public Neighbor {

protected:
  T_X_FLOAT neigh_cut;
  t_x x;
  t_type type;
  t_id id;

  T_INT nbinx,nbiny,nbinz,nhalo;
  T_INT N_local;

  Kokkos::View<T_INT*, MemorySpace> num_neighs;
  Kokkos::View<T_INT*, MemorySpace, Kokkos::MemoryTraits<Kokkos::Atomic> > num_neighs_atomic;
  Kokkos::View<T_INT*, MemorySpace> neigh_offsets;
  Kokkos::View<T_INT*, MemorySpace> neighs;
  bool skip_num_neigh_count, half_neigh;

  typename Binning::t_binoffsets bin_offsets;
  typename Binning::t_bincount bin_count;
  typename Binning::t_permute_vector permute_vector;



public:
  struct TagCreateOffsets {};
  struct TagCountNeighsFull {};
  struct TagFillNeighListFull {};
  struct TagCountNeighsHalf {};
  struct TagFillNeighListHalf {};

  typedef Kokkos::RangePolicy<TagCreateOffsets, Kokkos::IndexType<T_INT> > t_policy_co;
  typedef Kokkos::TeamPolicy<TagCountNeighsFull, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_cnf;
  typedef Kokkos::TeamPolicy<TagFillNeighListFull, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlf;
  typedef Kokkos::TeamPolicy<TagCountNeighsHalf, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_cnh;
  typedef Kokkos::TeamPolicy<TagFillNeighListHalf, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlh;

  typedef NeighListCSR<MemorySpace> t_neigh_list;

  t_neigh_list neigh_list;


  NeighborCSR():neigh_cut(0.0) {
    neigh_type = NEIGH_CSR;
  };
  ~NeighborCSR() {};

  void init(T_X_FLOAT neigh_cut_) { neigh_cut = neigh_cut_; };

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCountNeighsFull&, const typename t_policy_cnf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      int neigh_count = 0;
      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        int neigh_count_temp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
          T_INT j = permute_vector(j_offset + bj);

          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            count++;
          }
        },neigh_count_temp);
        neigh_count+=neigh_count_temp;
      }
      Kokkos::single(Kokkos::PerThread(team), [&] () {
        num_neighs(i) = neigh_count;
      });
    });
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillNeighListFull&, const typename t_policy_fnlf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

        Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);

          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            T_INT offset = Kokkos::atomic_fetch_add(&num_neighs(i),1) + neigh_offsets(i);
            neighs(offset) = j;
          }
        });
      }
    });
  }

  KOKKOS_INLINE_FUNCTION
   void operator() (const TagCountNeighsHalf&, const typename t_policy_cnh::member_type& team) const {
     const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
     const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
     const T_INT bz = team.league_rank() % nbinz + nhalo;

     const T_INT i_offset = bin_offsets(bx,by,bz);
     Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
       const T_INT i = permute_vector(i_offset + bi);
       if(i>=N_local) return;
       const T_F_FLOAT x_i = x(i,0);
       const T_F_FLOAT y_i = x(i,1);
       const T_F_FLOAT z_i = x(i,2);
       const int type_i = type(i);

       int neigh_count = 0;
       for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
       for(int by_j = by-1; by_j<by+2; by_j++)
       for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

       /*  if( ( (bx_j<bx) || ((bx_j == bx) && ( (by_j>by) ||  ((by_j==by) && (bz_j>bz) )))) &&
             (bx_j>=nhalo) && (bx_j<nbinx+nhalo-1) &&
             (by_j>=nhalo) && (by_j<nbiny+nhalo-1) &&
             (bz_j>=nhalo) && (bz_j<nbinz+nhalo-1)
           ) continue;
*/
         const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
         int neigh_count_temp;
           Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
             T_INT j = permute_vector(j_offset + bj);
             const T_F_FLOAT x_j = x(j,0);
             const T_F_FLOAT y_j = x(j,1);
             const T_F_FLOAT z_j = x(j,2);
             if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
               return;
             const T_F_FLOAT dx = x_i - x_j;
             const T_F_FLOAT dy = y_i - y_j;
             const T_F_FLOAT dz = z_i - z_j;

             const int type_j = type(j);
             const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

             if((rsq <= neigh_cut*neigh_cut)) {
               count++;
             }
           },neigh_count_temp);
         neigh_count+=neigh_count_temp;
       }
       Kokkos::single(Kokkos::PerThread(team), [&] () {
         num_neighs(i) = neigh_count;
       });
     });
   }

   KOKKOS_INLINE_FUNCTION
   void operator() (const TagFillNeighListHalf&, const typename t_policy_fnlh::member_type& team) const {
     const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
     const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
     const T_INT bz = team.league_rank() % nbinz + nhalo;

     const T_INT i_offset = bin_offsets(bx,by,bz);
     Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
       const T_INT i = permute_vector(i_offset + bi);
       if(i>=N_local) return;
       const T_F_FLOAT x_i = x(i,0);
       const T_F_FLOAT y_i = x(i,1);
       const T_F_FLOAT z_i = x(i,2);
       const int type_i = type(i);

       for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
       for(int by_j = by-1; by_j<by+2; by_j++)
       for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {
/*
         if( ( (bx_j<bx) || ((bx_j == bx) && ( (by_j>by) ||  ((by_j==by) && (bz_j>bz) )))) &&
             (bx_j>nhalo) && (bx_j<nbinx+nhalo-2) &&
             (by_j>nhalo) && (by_j<nbiny+nhalo-2) &&
             (bz_j>nhalo) && (bz_j<nbinz+nhalo-2)
           ) continue;*/
         const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

           Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
             T_INT j = permute_vector(j_offset + bj);
             const T_F_FLOAT x_j = x(j,0);
             const T_F_FLOAT y_j = x(j,1);
             const T_F_FLOAT z_j = x(j,2);
             if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
               return;
             const T_F_FLOAT dx = x_i - x_j;
             const T_F_FLOAT dy = y_i - y_j;
             const T_F_FLOAT dz = z_i - z_j;

             const int type_j = type(j);
             const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

             if((rsq <= neigh_cut*neigh_cut)) {
               T_INT offset = Kokkos::atomic_fetch_add(&num_neighs(i),1) + neigh_offsets(i);
               neighs(offset) = j;
             }
           });
       }
     });
   }
  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCreateOffsets&, const T_INT& i, T_INT& offset, const bool final) const {
    const T_INT count_i = num_neighs(i);
    if(final) {
      neigh_offsets(i) = offset;
      if(i==N_local-1)
        neigh_offsets(i+1) = offset+count_i;
    }
    offset += count_i;
  }

  void create_neigh_list(System* system, Binning* binning, bool half_neigh_, bool) {
    // Get some data handles
    N_local = system->N_local;
    x = system->x;
    type = system->type;
    id = system->id;
    half_neigh = half_neigh_;

    T_INT total_num_neighs;


    // Reset the neighbor count array
    if( num_neighs.extent(0) < N_local + 1 ) {
      num_neighs = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSR::num_neighs", N_local + 1);
      neigh_offsets = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSR::neigh_offsets", N_local + 1);
    } else
      Kokkos::deep_copy(num_neighs,0);
    num_neighs_atomic = num_neighs;


    // Create the pair list
    nhalo = binning->nhalo;
    nbinx = binning->nbinx - 2*nhalo;
    nbiny = binning->nbiny - 2*nhalo;
    nbinz = binning->nbinz - 2*nhalo;

    T_INT nbins = nbinx*nbiny*nbinz;

    bin_offsets = binning->binoffsets;
    bin_count = binning->bincount;
    permute_vector = binning->permute_vector;

    if(half_neigh)
      Kokkos::parallel_for("NeighborCSR::count_neighbors_half", t_policy_cnh(nbins,Kokkos::AUTO,8),*this);
    else
      Kokkos::parallel_for("NeighborCSR::count_neighbors_full", t_policy_cnf(nbins,Kokkos::AUTO,8),*this);
    Kokkos::fence();

    // Create the Offset list for neighbors of atoms
    Kokkos::parallel_scan("NeighborCSR::create_offsets", t_policy_co(0, N_local), *this);
    Kokkos::fence();

    // Get the total neighbor count
    Kokkos::View<T_INT,MemorySpace> d_total_num_neighs(neigh_offsets,N_local);
    Kokkos::deep_copy(total_num_neighs,d_total_num_neighs);

    // Resize NeighborList
    if( neighs.extent(0) < total_num_neighs )
      neighs = Kokkos::View<T_INT*, MemorySpace> ("NeighborCSR::neighs", total_num_neighs);

    // Copy entries from the PairList to the actual NeighborList
    Kokkos::deep_copy(num_neighs,0);

    if(half_neigh)
      Kokkos::parallel_for("NeighborCSR::fill_neigh_list_half",t_policy_fnlh(nbins,Kokkos::AUTO,8),*this);
    else
      Kokkos::parallel_for("NeighborCSR::fill_neigh_list_full",t_policy_fnlf(nbins,Kokkos::AUTO,8),*this);

    Kokkos::fence();

    // Create actual CSR NeighList
    neigh_list = t_neigh_list(
        Kokkos::View<T_INT*, MemorySpace>( neighs,     Kokkos::pair<T_INT,T_INT>(0,total_num_neighs)),
        Kokkos::View<T_INT*, MemorySpace>( neigh_offsets, Kokkos::pair<T_INT,T_INT>(0,N_local+1)));

  }

  t_neigh_list get_neigh_list() { return neigh_list; }
  const char* name() {return "NeighborCSR";}
};

template<>
struct NeighborAdaptor<NEIGH_CSR> {
  typedef NeighborCSR<t_neigh_mem_space> type;
};

extern template struct NeighborCSR<t_neigh_mem_space>;
#endif // #define NEIGHBOR_CSR_H
#endif // MODULES_OPTION_CHECK / MODULES_INSTANTIATION


---

# neighbor_csr_map_constr.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <neighbor_csr_map_constr.h>

#ifdef EMD_ENABLE_GPU
template struct NeighborCSRMapConstr<t_neigh_mem_space>;
#endif
template struct NeighborCSRMapConstr<Kokkos::HostSpace>;



---

# neighbor_csr_map_constr.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Runtime Check for this Neighbor Class
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "CSR_MAPCONSTR") == 0) )
        neighbor_type = NEIGH_CSR_MAPCONSTR;
#endif

// Instantiation and Init of this class
#ifdef NEIGHBOR_MODULES_INSTANTIATION
    else if (input->neighbor_type == NEIGH_CSR_MAPCONSTR) {
      neighbor = new NeighborCSRMapConstr<t_neigh_mem_space>();
      neighbor->init(input->force_cutoff + input->neighbor_skin);
    }
#endif

// Add Force Instantiation case
#if defined(FORCE_MODULES_INSTANTIATION)
      case NEIGH_CSR_MAPCONSTR: force = new FORCETYPE_ALLOCATION_MACRO(NeighborCSRMapConstr<t_neigh_mem_space>); break;
#endif

// Add Force declaration line
#if defined(FORCE_MODULES_EXTERNAL_TEMPLATE)
      extern template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSRMapConstr<t_neigh_mem_space>);
#endif

// Add Force Template Instantiation line
#if defined(FORCE_MODULES_TEMPLATE)
      template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSRMapConstr<t_neigh_mem_space>);
#endif

// Making sure we are not just instantiating some Option
#if !defined(MODULES_OPTION_CHECK) && \
    !defined(NEIGHBOR_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_EXTERNAL_TEMPLATE) && \
    !defined(FORCE_MODULES_TEMPLATE)
#ifndef NEIGHBOR_CSR_MAPCONSTR_H
#define NEIGHBOR_CSR_MAPCONSTR_H
#include <neighbor_csr.h>
#include <Kokkos_UnorderedMap.hpp>

template<class MemorySpace>
class NeighborCSRMapConstr: public Neighbor {

protected:
  T_X_FLOAT neigh_cut;
  t_x x;
  t_type type;
  t_id id;

  T_INT nbinx,nbiny,nbinz,nhalo;
  T_INT N_local;

  Kokkos::View<T_INT*, MemorySpace> num_neighs;
  Kokkos::View<T_INT*, MemorySpace, Kokkos::MemoryTraits<Kokkos::Atomic> > num_neighs_atomic;
  Kokkos::View<T_INT*, MemorySpace> neigh_offsets;
  Kokkos::View<T_INT*, MemorySpace> neighs;
  bool skip_num_neigh_count, half_neigh;

  typename Binning::t_binoffsets bin_offsets;
  typename Binning::t_bincount bin_count;
  typename Binning::t_permute_vector permute_vector;

  typedef Kokkos::UnorderedMap<Kokkos::pair<T_INT,T_INT>, void, MemorySpace> t_set;
  t_set pair_list;

public:
  struct TagFillPairListFull {};
  struct TagFillPairListHalf {};
  struct TagCopyNeighList {};
  struct TagCreateOffsets {};

  typedef Kokkos::TeamPolicy<TagFillPairListFull, Kokkos::IndexType<T_INT> > t_policy_fplf;
  typedef Kokkos::TeamPolicy<TagFillPairListHalf, Kokkos::IndexType<T_INT> > t_policy_fplh;
  typedef Kokkos::RangePolicy<TagCopyNeighList, Kokkos::IndexType<T_INT> > t_policy_cnl;
  typedef Kokkos::RangePolicy<TagCreateOffsets, Kokkos::IndexType<T_INT> > t_policy_co;

  typedef NeighListCSR<MemorySpace> t_neigh_list;

  t_neigh_list neigh_list;


  NeighborCSRMapConstr():neigh_cut(0.0) {
    neigh_type = NEIGH_CSR_MAPCONSTR;
  };
  ~NeighborCSRMapConstr() {};

  void init(T_X_FLOAT neigh_cut_) { neigh_cut = neigh_cut_; };

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillPairListFull&, const typename t_policy_fplf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        int neigh_count_temp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);

          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            pair_list.insert(Kokkos::pair<T_INT,T_INT>(i,j));
            count++;
          }
        },neigh_count_temp);
        Kokkos::single(Kokkos::PerThread(team), [&] () {
          if(!skip_num_neigh_count)
            num_neighs_atomic(i)+=neigh_count_temp;
        });
      }
    });
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillPairListHalf&, const typename t_policy_fplh::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        int neigh_count_temp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT x_j = x(j,0);
          const T_F_FLOAT y_j = x(j,1);
          const T_F_FLOAT z_j = x(j,2);
          if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
            return;
          const T_F_FLOAT dx = x_i - x_j;
          const T_F_FLOAT dy = y_i - y_j;
          const T_F_FLOAT dz = z_i - z_j;

          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            pair_list.insert(Kokkos::pair<T_INT,T_INT>(i,j));
            count++;
          }
        },neigh_count_temp);
        Kokkos::single(Kokkos::PerThread(team), [&] () {
          if(!skip_num_neigh_count)
            num_neighs_atomic(i)+=neigh_count_temp;
        });
      }
    });
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCopyNeighList&, const T_INT& i) const {
    if(pair_list.valid_at(i)) {
      Kokkos::pair<T_INT,T_INT> pair_i = pair_list.key_at(i);
      T_INT offset = Kokkos::atomic_fetch_add(&num_neighs(pair_i.first),1) + neigh_offsets(pair_i.first);
      neighs(offset) = pair_i.second;
    }
  }


  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCreateOffsets&, const T_INT& i, T_INT& offset, const bool final) const {
    const T_INT count_i = num_neighs(i);
    if(final)
      neigh_offsets(i) = offset;
    offset += count_i;
  }

  void create_neigh_list(System* system, Binning* binning, bool half_neigh_, bool) {
    // Get some data handles
    N_local = system->N_local;
    x = system->x;
    type = system->type;
    id = system->id;
    half_neigh = half_neigh_;

    T_INT total_num_neighs;

    // Compute number of expected neighbors
    T_X_FLOAT volume = system->domain_x * system->domain_y * system->domain_z;
    T_X_FLOAT particle_density =  1.0 * N_local / volume;
    T_INT num_neighs_estimate = particle_density *  (3.0/4.0 * 3.15 * neigh_cut * neigh_cut * neigh_cut);

    // Clear the PairList
    pair_list.clear();

    // Resize the PairList if necessary (make it a bit larger than needed for performance)
    if(pair_list.capacity() < T_INT(1.3 * num_neighs_estimate * N_local))
      pair_list.rehash( T_INT(1.3 * num_neighs_estimate * N_local) );

    // Reset the neighbor count array
    if( num_neighs.extent(0) < N_local + 1 ) {
      num_neighs = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSRMapConstr::num_neighs", N_local + 1);
      neigh_offsets = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSRMapConstr::neigh_offsets", N_local + 1);
    } else
      Kokkos::deep_copy(num_neighs,0);
    num_neighs_atomic = num_neighs;

    // Create the pair list
    nhalo = binning->nhalo;
    nbinx = binning->nbinx - 2*nhalo;
    nbiny = binning->nbiny - 2*nhalo;
    nbinz = binning->nbinz - 2*nhalo;

    T_INT nbins = nbinx*nbiny*nbinz;

    bin_offsets = binning->binoffsets;
    bin_count = binning->bincount;
    permute_vector = binning->permute_vector;

    skip_num_neigh_count = false;

    if(half_neigh)
      Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_half", t_policy_fplh(nbins,Kokkos::AUTO,8),*this);
    else
      Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_full", t_policy_fplf(nbins,Kokkos::AUTO,8),*this);
    Kokkos::fence();

    // Create the Offset list for neighbors of atoms
    Kokkos::parallel_scan("NeighborCSRMapConstr::create_offsets", t_policy_co(0, N_local+1), *this);
    Kokkos::fence();

    // Get the total neighbor count
    Kokkos::View<T_INT,MemorySpace> d_total_num_neighs(neigh_offsets,N_local);
    Kokkos::deep_copy(total_num_neighs,d_total_num_neighs);

    // If inserts failed because the PairList was to small resize and recreate the PairList
    // Don't need to count this time around
    if(pair_list.failed_insert()) {
      pair_list.rehash(total_num_neighs*1.2);
      skip_num_neigh_count = true;
      if(half_neigh)
        Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_half", t_policy_fplh(nbins,Kokkos::AUTO,8),*this);
      else
        Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_full", t_policy_fplf(nbins,Kokkos::AUTO,8),*this);
      Kokkos::fence();
    }

    // Resize NeighborList
    if( neighs.extent(0) < total_num_neighs )
      neighs = Kokkos::View<T_INT*, MemorySpace> ("NeighborCSRMapConstr::neighs", total_num_neighs);

    // Copy entries from the PairList to the actual NeighborList
    Kokkos::deep_copy(num_neighs,0);

    Kokkos::parallel_for("NeighborCSRMapConstr::copy_to_neigh_list",t_policy_cnl(0,pair_list.capacity()),*this);
    Kokkos::fence();

    // Create actual CSR NeighList
    neigh_list = t_neigh_list(
        Kokkos::View<T_INT*, MemorySpace>( neighs,     Kokkos::pair<T_INT,T_INT>(0,total_num_neighs)),
        Kokkos::View<T_INT*, MemorySpace>( neigh_offsets, Kokkos::pair<T_INT,T_INT>(0,N_local+1)));

  }

  t_neigh_list get_neigh_list() { return neigh_list; }

  const char* name() {return "NeighborCSRMapConstr";}
};

extern template struct NeighborCSRMapConstr<t_neigh_mem_space>;
#endif // #define NEIGHBOR_CSR_MAPCONSTR_H
#endif // MODULES_OPTION_CHECK / MODULES_INSTANTIATION


---

# binning_kksort.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<binning_kksort.h>

BinningKKSort::BinningKKSort(System* s): Binning(s) {}

namespace {
  //This needs to be multi dimensional Range Policy later
  template<class BinCount1D, class BinOffsets1D, class BinCount3D, class BinOffsets3D>
  struct BinningKKSort_AssignOffsets {
    BinCount1D bin_count_1d;
    BinOffsets1D bin_offsets_1d;
    BinCount3D bin_count_3d;
    BinOffsets3D bin_offsets_3d;

    T_INT nbinx,nbiny,nbinz;
    BinningKKSort_AssignOffsets(BinCount1D bc1d, BinOffsets1D bo1d, 
                                BinCount3D bc3d, BinOffsets3D bo3d,
                                T_INT nx, T_INT ny, T_INT nz):
            bin_count_1d(bc1d),bin_offsets_1d(bo1d),bin_count_3d(bc3d),bin_offsets_3d(bo3d),
            nbinx(nx),nbiny(ny),nbinz(nz) {}

    KOKKOS_INLINE_FUNCTION
    void operator() (const T_INT& i) const {
      T_INT ix = i/(nbiny*nbinz);
      T_INT iy = (i/nbinz)%nbiny;
      T_INT iz = i%nbinz;

      bin_offsets_3d(ix,iy,iz) = bin_offsets_1d(i);
      bin_count_3d(ix,iy,iz) = bin_count_1d(i);
    }
  };
}

void BinningKKSort::create_binning(T_X_FLOAT dx_in, T_X_FLOAT dy_in, T_X_FLOAT dz_in, int halo_depth, bool do_local, bool do_ghost, bool sort) {
  if(do_local||do_ghost) {
    nhalo = halo_depth;
    std::pair<T_INT,T_INT> range(do_local?0:system->N_local,
                                 do_ghost?system->N_local+system->N_ghost:system->N_local);

    nbinx = T_INT(system->sub_domain_x/dx_in);
    nbiny = T_INT(system->sub_domain_y/dy_in);
    nbinz = T_INT(system->sub_domain_z/dz_in);

    if(nbinx == 0) nbinx = 1;
    if(nbiny == 0) nbiny = 1;
    if(nbinz == 0) nbinz = 1;

    T_X_FLOAT dx = system->sub_domain_x/nbinx;
    T_X_FLOAT dy = system->sub_domain_y/nbiny;
    T_X_FLOAT dz = system->sub_domain_z/nbinz;

    nbinx += 2*halo_depth;
    nbiny += 2*halo_depth;
    nbinz += 2*halo_depth;

    T_X_FLOAT eps = dx/1000;
    minx = -dx * halo_depth - eps + system->sub_domain_lo_x;
    maxx =  dx * halo_depth + eps + system->sub_domain_hi_x;
    miny = -dy * halo_depth - eps + system->sub_domain_lo_y;
    maxy =  dy * halo_depth + eps + system->sub_domain_hi_y;
    minz = -dz * halo_depth - eps + system->sub_domain_lo_z;
    maxz =  dz * halo_depth + eps + system->sub_domain_hi_z;

    T_INT nbin[3] = {nbinx,nbiny,nbinz};
    T_X_FLOAT min[3] = {minx,miny,minz};
    T_X_FLOAT max[3] = {maxx,maxy,maxz};

    t_binop binop(nbin,min,max);

    auto x = Kokkos::subview(system->x,range,Kokkos::ALL);

    sorter = t_sorter(x,binop);

    sorter.create_permute_vector();

    permute_vector = sorter.get_permute_vector();

    typename t_sorter::bin_count_type bin_count_1d = sorter.get_bin_count();
    typename t_sorter::offset_type bin_offsets_1d = sorter.get_bin_offsets();

    bincount = t_bincount("Binning::bincount",nbinx,nbiny,nbinz);
    binoffsets = t_binoffsets("Binning::binoffsets",nbinx,nbiny,nbinz);

    Kokkos::parallel_for("Binning::AssignOffsets",nbinx*nbiny*nbinz,
                    BinningKKSort_AssignOffsets<t_sorter::bin_count_type,t_sorter::offset_type,
                                                t_bincount, t_binoffsets>(bin_count_1d,bin_offsets_1d,
                                                                          bincount,binoffsets,
                                                                          nbinx,nbiny,nbinz));
    if(sort) {
      sorter.sort(x);
      auto v = Kokkos::subview(system->v,range,Kokkos::ALL);
      sorter.sort(v);
      auto f = Kokkos::subview(system->f,range,Kokkos::ALL);
      sorter.sort(f);
      t_type type(system->type,range);
      sorter.sort(type);
      t_id id(system->id,range);
      sorter.sort(id);
      t_q q(system->q,range);
      sorter.sort(q);
    }
  }
}

const char* BinningKKSort::name() { return "BinningKKSort"; }



---

# binning_kksort.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifndef BINNING_KKSORT_H
#define BINNING_KKSORT_H
#include<binning.h>
#include<Kokkos_Sort.hpp>

class BinningKKSort: public Binning {
  typedef Kokkos::BinOp3D<t_x_const> t_binop;
  typedef Kokkos::BinSort<t_x_const,t_binop,Kokkos::DefaultExecutionSpace,T_INT> t_sorter;
  t_sorter sorter;

public:
  BinningKKSort(System* s);
  void create_binning(T_X_FLOAT dx, T_X_FLOAT dy, T_X_FLOAT dz, int halo_depth, bool do_local, bool do_ghost, bool sort);
  const char* name();
};
#endif


---

# CMakeLists.txt

SET(HEADERS
  binning_kksort.h)

SET(SOURCES
  binning_kksort.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# CMakeLists.txt

SET(HEADERS
  comm_mpi.h
  comm_serial.h)

SET(SOURCES
  comm_mpi.cpp
  comm_serial.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# comm_mpi.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef EXAMINIMD_ENABLE_MPI
#include<comm_mpi.h>

CommMPI::CommMPI(System* s, T_X_FLOAT comm_depth):Comm(s,comm_depth) {
  pack_count = Kokkos::View<int>("CommMPI::pack_count");
  pack_buffer = Kokkos::View<Particle*>("CommMPI::pack_buffer",200);
  unpack_buffer = Kokkos::View<Particle*>("CommMPI::pack_buffer",200);
  pack_indicies_all = Kokkos::View<T_INT**,Kokkos::LayoutRight>("CommMPI::pack_indicies_all",6,200);
  exchange_dest_list = Kokkos::View<T_INT*,Kokkos::LayoutRight >("CommMPI::exchange_dest_list",200);
}

void CommMPI::init() {};

void CommMPI::create_domain_decomposition() {

  //printf("Domain b: %p %lf %lf %lf\n",system,system->domain_x ,system->domain_y ,system->domain_z);

  MPI_Comm_size(MPI_COMM_WORLD, &proc_size);
  MPI_Comm_rank(MPI_COMM_WORLD, &proc_rank);
  int ipx = 1;

  double area_xy = system->domain_x * system->domain_y;
  double area_xz = system->domain_x * system->domain_z;
  double area_yz = system->domain_y * system->domain_z;

  double smallest_surface = 2.0 * (area_xy + area_xz + area_yz);

  while(ipx <= proc_size) {
    if(proc_size % ipx == 0) {
      int nremain = proc_size / ipx;
      int ipy = 1;

      while(ipy <= nremain) {
        if(nremain % ipy == 0) {
          int ipz = nremain / ipy;
          double surface = area_xy / ipx / ipy + area_xz / ipx / ipz + area_yz / ipy / ipz;

          if(surface < smallest_surface) {
            smallest_surface = surface;
            proc_grid[0] = ipx;
            proc_grid[1] = ipy;
            proc_grid[2] = ipz;
          }
        }

        ipy++;
      }
    }

    ipx++;
  }
  proc_pos[2] = proc_rank / (proc_grid[0] * proc_grid[1]);
  proc_pos[1] = (proc_rank % (proc_grid[0] * proc_grid[1])) / proc_grid[0];
  proc_pos[0] = proc_rank % proc_grid[0];

  if(proc_grid[0]>1) {
    proc_neighbors_send[1] = ( proc_pos[0] > 0 )                ? proc_rank - 1 :
                                                                proc_rank + (proc_grid[0]-1);
    proc_neighbors_send[0] = ( proc_pos[0] < (proc_grid[0]-1) ) ? proc_rank + 1 :
                                                                proc_rank - (proc_grid[0]-1);

  } else {
    proc_neighbors_send[0] = -1;
    proc_neighbors_send[1] = -1;
  }

  if(proc_grid[1]>1) {
    proc_neighbors_send[3] = ( proc_pos[1] > 0 )                ? proc_rank - proc_grid[0] :
                                                                proc_rank + proc_grid[0]*(proc_grid[1]-1);
    proc_neighbors_send[2] = ( proc_pos[1] < (proc_grid[1]-1) ) ? proc_rank + proc_grid[0] :
                                                                proc_rank - proc_grid[0]*(proc_grid[1]-1);
  } else {
    proc_neighbors_send[2] = -1;
    proc_neighbors_send[3] = -1;
  }

  if(proc_grid[2]>1) {
    proc_neighbors_send[5] = ( proc_pos[2] > 0 )                ? proc_rank - proc_grid[0]*proc_grid[1] :
                                                                proc_rank + proc_grid[0]*proc_grid[1]*(proc_grid[2]-1);
    proc_neighbors_send[4] = ( proc_pos[2] < (proc_grid[2]-1) ) ? proc_rank + proc_grid[0]*proc_grid[1] :
                                                                proc_rank - proc_grid[0]*proc_grid[1]*(proc_grid[2]-1);
  } else {
    proc_neighbors_send[4] = -1;
    proc_neighbors_send[5] = -1;
  }

  proc_neighbors_recv[0] = proc_neighbors_send[1];
  proc_neighbors_recv[1] = proc_neighbors_send[0];
  proc_neighbors_recv[2] = proc_neighbors_send[3];
  proc_neighbors_recv[3] = proc_neighbors_send[2];
  proc_neighbors_recv[4] = proc_neighbors_send[5];
  proc_neighbors_recv[5] = proc_neighbors_send[4];

  system->sub_domain_x = system->domain_x / proc_grid[0];
  system->sub_domain_y = system->domain_y / proc_grid[1];
  system->sub_domain_z = system->domain_z / proc_grid[2];
  system->sub_domain_lo_x = proc_pos[0] * system->sub_domain_x;
  system->sub_domain_lo_y = proc_pos[1] * system->sub_domain_y;
  system->sub_domain_lo_z = proc_pos[2] * system->sub_domain_z;
  system->sub_domain_hi_x = ( proc_pos[0] + 1 ) * system->sub_domain_x;
  system->sub_domain_hi_y = ( proc_pos[1] + 1 ) * system->sub_domain_y;
  system->sub_domain_hi_z = ( proc_pos[2] + 1 ) * system->sub_domain_z;

  /*printf("MyRank: %i MyPos: %i %i %i Grid: %i %i %i Neighbors: %i %i , %i %i , %i %i\n",proc_rank,proc_pos[0],
      proc_pos[1],proc_pos[2],proc_grid[0],proc_grid[1],proc_grid[2],
      proc_neighbors_send[0],proc_neighbors_send[1],
      proc_neighbors_send[2],proc_neighbors_send[3],
      proc_neighbors_send[4],proc_neighbors_send[5]);*/
}


void CommMPI::scan_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Scan(MPI_IN_PLACE,vals,count,MPI_INT,MPI_SUM,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_INT,MPI_SUM,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_float(T_FLOAT* vals, T_INT count) {
  if(std::is_same<T_FLOAT,double>::value) {
    // This generates MPI_ERR_BUFFER for count>1
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_max_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_INT,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_max_float(T_FLOAT* vals, T_INT count) {
  if(std::is_same<T_FLOAT,double>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_DOUBLE,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_min_int(T_INT* vals, T_INT count) {
  if(std::is_same<T_INT,int>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_INT,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::reduce_min_float(T_FLOAT* vals, T_INT count) {
  if(std::is_same<T_FLOAT,double>::value) {
    MPI_Allreduce(MPI_IN_PLACE,vals,count,MPI_DOUBLE,MPI_MAX,MPI_COMM_WORLD);
  }
}

void CommMPI::exchange() {

  Kokkos::Profiling::pushRegion("Comm::exchange");

  s = *system;
  N_local = system->N_local;
  N_ghost = 0;
  //printf("System A: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));
  Kokkos::parallel_for("CommMPI::exchange_self",
            Kokkos::RangePolicy<TagExchangeSelf, Kokkos::IndexType<T_INT> >(0,N_local), *this);

  T_INT N_total_recv = 0;
  T_INT N_total_send = 0;

  //printf("System B: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));
  for(phase = 0; phase < 6; phase ++) {
    proc_num_send[phase] = 0;
    proc_num_recv[phase] = 0;
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    T_INT count = 0;
    Kokkos::deep_copy(pack_count,0);

    if(proc_grid[phase/2]>1) {
      Kokkos::parallel_for("CommMPI::exchange_pack",
                Kokkos::RangePolicy<TagExchangePack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost),
                *this);

      Kokkos::deep_copy(count,pack_count);
      if(count > pack_indicies.extent(0)) {
        Kokkos::realloc(pack_buffer,count*1.1);
        Kokkos::realloc(pack_indicies_all,6,count*1.1);
        pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
        Kokkos::deep_copy(pack_count,0);
        Kokkos::parallel_for("CommMPI::exchange_pack",
                  Kokkos::RangePolicy<TagExchangePack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost),
                  *this);
      }
      proc_num_send[phase] = count;
      if(pack_buffer.extent(0)<count)
        pack_buffer = Kokkos::View<Particle*>("Comm::pack_buffer",count);
      MPI_Request request;
      MPI_Irecv(&proc_num_recv[phase],1,MPI_INT, proc_neighbors_recv[phase],100001,MPI_COMM_WORLD,&request);
      MPI_Send(&proc_num_send[phase],1,MPI_INT, proc_neighbors_send[phase],100001,MPI_COMM_WORLD);
      MPI_Status status;
      MPI_Wait(&request,&status);
      count = proc_num_recv[phase];
      //printf("Recv Count: %i\n",count);
      if(unpack_buffer.extent(0)<count) {
        unpack_buffer = Kokkos::View<Particle*>("Comm::unpack_buffer",count);
      }
      if(proc_num_recv[phase]>0)
        MPI_Irecv(unpack_buffer.data(),proc_num_recv[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD,&request);
      if(proc_num_send[phase]>0)
        MPI_Send (pack_buffer.data(),proc_num_send[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD);
      system->grow(N_local + N_ghost + count);
      s = *system;
      if(proc_num_recv[phase]>0)
        MPI_Wait(&request,&status);
      Kokkos::parallel_for("CommMPI::exchange_unpack",
                Kokkos::RangePolicy<TagUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
                *this);

    }

    N_ghost += count;
    N_total_recv += proc_num_recv[phase];
    N_total_send += proc_num_send[phase];
  }
  T_INT N_local_start = N_local;
  T_INT N_exchange = N_ghost;
  //printf("System C: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));

  N_local = N_local + N_total_recv - N_total_send;
  N_ghost = N_local_start + N_exchange - N_local;

  if(exchange_dest_list.extent(0)<N_ghost)
    Kokkos::realloc(exchange_dest_list,N_ghost);

  //printf("ExchangeDestList: %i %i %i %i %i\n",exchange_dest_list.extent(0),N_ghost,N_total_recv,N_total_send,N_local);
  //printf("System: %i %i\n",s.N_local,system->N_local);
  Kokkos::parallel_scan("CommMPI::exchange_create_dest_list",
            Kokkos::RangePolicy<TagExchangeCreateDestList, Kokkos::IndexType<T_INT> >(0,N_local),
            *this);
  //printf("System D: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));
  Kokkos::parallel_scan("CommMPI::exchange_compact",
            Kokkos::RangePolicy<TagExchangeCompact, Kokkos::IndexType<T_INT> >(0,N_ghost),
            *this);
  //printf("System E: %i %lf %lf %lf %i\n",s.N_local,s.x(21,0),s.x(21,1),s.x(21,2),s.type(21));

  system->N_local = N_local;
  system->N_ghost = 0;
  /*for(int i=0;i<N_local;i++)
    if(s.type(i)<0) printf("Huch: %i %i\n",i,N_local);*/

  Kokkos::Profiling::popRegion();
};

void CommMPI::exchange_halo() {

  Kokkos::Profiling::pushRegion("Comm::exchange_halo");

  N_local = system->N_local;
  N_ghost = 0;

  s = *system;

  for(phase = 0; phase < 6; phase ++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    T_INT count = 0;
    Kokkos::deep_copy(pack_count,0);

    if(proc_grid[phase/2]>1) {
      Kokkos::parallel_for("CommMPI::halo_exchange_pack",
                Kokkos::RangePolicy<TagHaloPack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost - ( (phase%2==1) ? proc_num_recv[phase-1]:0)),
                *this);

      Kokkos::deep_copy(count,pack_count);
      if(count > pack_indicies.extent(0)) {
        Kokkos::realloc(pack_buffer,count*1.1);
        Kokkos::resize(pack_indicies_all,6,count*1.1);
        pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
        Kokkos::deep_copy(pack_count,0);
        Kokkos::parallel_for("CommMPI::halo_exchange_pack",
                  Kokkos::RangePolicy<TagHaloPack, Kokkos::IndexType<T_INT> >(0,N_local+N_ghost- ( (phase%2==1) ? proc_num_recv[phase-1]:0)),
                  *this);
      }
      proc_num_send[phase] = count;
      if(pack_buffer.extent(0)<count)
        pack_buffer = Kokkos::View<Particle*>("Comm::pack_buffer",count);
      MPI_Request request;
      MPI_Irecv(&proc_num_recv[phase],1,MPI_INT, proc_neighbors_recv[phase],100001,MPI_COMM_WORLD,&request);
      MPI_Send(&proc_num_send[phase],1,MPI_INT, proc_neighbors_send[phase],100001,MPI_COMM_WORLD);
      MPI_Status status;
      MPI_Wait(&request,&status);
      count = proc_num_recv[phase];
      if(unpack_buffer.extent(0)<count) {
        unpack_buffer = Kokkos::View<Particle*>("Comm::unpack_buffer",count);
      }
      MPI_Irecv(unpack_buffer.data(),proc_num_recv[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD,&request);
      MPI_Send (pack_buffer.data(),proc_num_send[phase]*sizeof(Particle)/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD);
      system->grow(N_local + N_ghost + count);
      s = *system;
      MPI_Wait(&request,&status);
      Kokkos::parallel_for("CommMPI::halo_exchange_unpack",
                Kokkos::RangePolicy<TagUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
                *this);

    } else {
      T_INT nparticles = N_local + N_ghost - ( (phase%2==1) ? proc_num_recv[phase-1]:0 );
      Kokkos::parallel_for("CommMPI::halo_exchange_self",
                Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
                *this);
      Kokkos::deep_copy(count,pack_count);
      bool redo = false;
      if(N_local+N_ghost+count>s.x.extent(0)) {
        system->grow(N_local + N_ghost + count);
        s = *system;
        redo = true;
      }
      if(count > pack_indicies.extent(0)) {
        Kokkos::realloc(pack_buffer,count*1.1);
        Kokkos::resize(pack_indicies_all,6,count*1.1);
        pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
        redo = true;
      }
      if(redo) {
        Kokkos::deep_copy(pack_count,0);
        Kokkos::parallel_for("CommMPI::halo_exchange_self",
                  Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
                  *this);
      }
      //printf("ExchangeHalo: %i %i %i %i\n",phase,count,pack_indicies_all.extent(1),pack_indicies.extent(0));
      proc_num_send[phase] = count;
      proc_num_recv[phase] = count;
    }

    num_ghost[phase] = count;
    N_ghost += count;
  }
  static int step = 0;
  step++;

  system->N_ghost = N_ghost;

  Kokkos::Profiling::popRegion();
};

void CommMPI::update_halo() {

  Kokkos::Profiling::pushRegion("Comm::update_halo");

  N_ghost = 0;
  s=*system;

  pack_buffer_update = t_buffer_update((T_X_FLOAT*)pack_buffer.data(),pack_indicies_all.extent(1));
  unpack_buffer_update = t_buffer_update((T_X_FLOAT*)unpack_buffer.data(),pack_indicies_all.extent(1));

  for(phase = 0; phase<6; phase++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
    if(proc_grid[phase/2]>1) {  
      
      Kokkos::parallel_for("CommMPI::halo_update_pack",
         Kokkos::RangePolicy<TagHaloUpdatePack, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
         *this);
      MPI_Request request;
      MPI_Status status;
      MPI_Irecv(unpack_buffer.data(),proc_num_recv[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD,&request);
      MPI_Send (pack_buffer.data(),proc_num_send[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD);
      s = *system;
      MPI_Wait(&request,&status);
      const int count = proc_num_recv[phase];
      if(unpack_buffer_update.extent(0)<count) {
        unpack_buffer_update = t_buffer_update((T_X_FLOAT*)unpack_buffer.data(),count);
      }
      Kokkos::parallel_for("CommMPI::halo_update_unpack",
                Kokkos::RangePolicy<TagHaloUpdateUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
                *this);

    } else {
      //printf("HaloUpdateCopy: %i %i %i\n",phase,proc_num_send[phase],pack_indicies.extent(0));
      Kokkos::parallel_for("CommMPI::halo_update_self",
        Kokkos::RangePolicy<TagHaloUpdateSelf, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
        *this);
    }
    N_ghost += proc_num_recv[phase];
  }

  Kokkos::Profiling::popRegion();
};

void CommMPI::update_force() {

  Kokkos::Profiling::pushRegion("Comm::update_force");

  N_ghost = 0;
  s=*system;

  ghost_offsets[0] = s.N_local;
  for(phase = 1; phase<6; phase++) {
    ghost_offsets[phase] = ghost_offsets[phase-1] + proc_num_recv[phase-1];
  }

  pack_buffer_update = t_buffer_update((T_X_FLOAT*)pack_buffer.data(),pack_indicies_all.extent(1));
  unpack_buffer_update = t_buffer_update((T_X_FLOAT*)unpack_buffer.data(),pack_indicies_all.extent(1));

  for(phase = 5; phase>=0; phase--) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
    if(proc_grid[phase/2]>1) {

      Kokkos::parallel_for("CommMPI::halo_force_pack",
         Kokkos::RangePolicy<TagHaloForcePack, Kokkos::IndexType<T_INT> >(0,proc_num_recv[phase]),
         *this);
      MPI_Request request;
      MPI_Status status;
      MPI_Irecv(pack_buffer.data(),proc_num_send[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_send[phase],100002,MPI_COMM_WORLD,&request);
      MPI_Send (unpack_buffer.data(),proc_num_recv[phase]*sizeof(T_X_FLOAT)*3/sizeof(int),MPI_INT, proc_neighbors_recv[phase],100002,MPI_COMM_WORLD);
      s = *system;
      MPI_Wait(&request,&status);
      Kokkos::parallel_for("CommMPI::halo_force_unpack",
                Kokkos::RangePolicy<TagHaloForceUnpack, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
                *this);

    } else {
      //printf("HaloUpdateCopy: %i %i %i\n",phase,proc_num_send[phase],pack_indicies.extent(0));
      Kokkos::parallel_for("CommMPI::halo_force_self",
        Kokkos::RangePolicy<TagHaloForceSelf, Kokkos::IndexType<T_INT> >(0,proc_num_send[phase]),
        *this);
    }
  }

  Kokkos::Profiling::popRegion();
};

const char* CommMPI::name() { return "CommMPI"; }

int CommMPI::process_rank() { return proc_rank; }
int CommMPI::num_processes() { return proc_size; }
void CommMPI::error(const char *errormsg) {
  if(proc_rank==0)
  printf("%s\n",errormsg);
  MPI_Abort(MPI_COMM_WORLD,1);
};
#endif


---

# comm_mpi.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
   if( (strcmp(argv[i+1], "MPI") == 0) )
     comm_type = COMM_MPI;
#endif
#ifdef COMM_MODULES_INSTANTIATION
   else if(input->comm_type == COMM_MPI) {
     comm = new CommMPI(system,input->force_cutoff + input->neighbor_skin);
   }
#endif


#if !defined(MODULES_OPTION_CHECK) && !defined(COMM_MODULES_INSTANTIATION)
#ifndef COMM_MPI_H
#define COMM_MPI_H
#include<comm.h>

#ifndef EXAMINIMD_ENABLE_MPI
#error "Trying to compile CommMPI without MPI"
#endif

#include "mpi.h"

class CommMPI: public Comm {

  // Variables Comm doesn't own but requires for computations

  T_INT N_local;
  T_INT N_ghost;

  System s;

  // Owned Variables

  int phase; // Communication Phase
  int proc_neighbors_recv[6]; // Neighbor for each phase
  int proc_neighbors_send[6]; // Neighbor for each phase
  int proc_num_recv[6];  // Number of received particles in each phase
  int proc_num_send[6];  // Number of send particles in each phase
  int proc_pos[3];       // My process position
  int proc_grid[3];      // Process Grid size
  int proc_rank;         // My Process rank
  int proc_size;         // Number of processes

  T_INT num_ghost[6];
  T_INT ghost_offsets[6];

  T_INT num_packed;
  Kokkos::View<int, Kokkos::MemoryTraits<Kokkos::Atomic> > pack_count;
  Kokkos::View<Particle*> pack_buffer;
  Kokkos::View<Particle*> unpack_buffer;
  typedef Kokkos::View<T_X_FLOAT*[3], Kokkos::LayoutRight, Kokkos::MemoryTraits<Kokkos::Unmanaged>> t_buffer_update;
  t_buffer_update pack_buffer_update;
  t_buffer_update unpack_buffer_update;

  Kokkos::View<T_INT**,Kokkos::LayoutRight> pack_indicies_all;
  Kokkos::View<T_INT*,Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Unmanaged> > pack_indicies;
  Kokkos::View<T_INT*,Kokkos::LayoutRight > exchange_dest_list;

public:

  struct TagUnpack {};

  struct TagExchangeSelf {};
  struct TagExchangePack {};
  struct TagExchangeCreateDestList {};
  struct TagExchangeCompact {};
  
  struct TagHaloSelf {};
  struct TagHaloPack {};
  struct TagHaloUpdateSelf {};
  struct TagHaloUpdatePack {};
  struct TagHaloUpdateUnpack {};

  struct TagHaloForceSelf {};
  struct TagHaloForcePack {};
  struct TagHaloForceUnpack {};

  struct TagPermuteIndexList {};

  CommMPI(System* s, T_X_FLOAT comm_depth_);
  void init();
  void create_domain_decomposition();
  void permute_index_lists(Binning::t_permute_vector& permute_vector);
  void exchange();
  void exchange_halo();
  void update_halo();
  void update_force();
  void scan_int(T_INT* vals, T_INT count);
  void reduce_int(T_INT* vals, T_INT count);
  void reduce_float(T_FLOAT* vals, T_INT count);
  void reduce_max_int(T_INT* vals, T_INT count);
  void reduce_max_float(T_FLOAT* vals, T_INT count);
  void reduce_min_int(T_INT* vals, T_INT count);
  void reduce_min_float(T_FLOAT* vals, T_INT count);

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeSelf, 
                   const T_INT& i) const {
    if(proc_grid[0]==1) {
      const T_X_FLOAT x = s.x(i,0);
      if(x>s.domain_x) s.x(i,0) -= s.domain_x;
      if(x<0)          s.x(i,0) += s.domain_x;
    }
    if(proc_grid[1]==1) {
      const T_X_FLOAT y = s.x(i,1);
      if(y>s.domain_y) s.x(i,1) -= s.domain_y;
      if(y<0)          s.x(i,1) += s.domain_y;
    }
    if(proc_grid[2]==1) {
      const T_X_FLOAT z = s.x(i,2);
      if(z>s.domain_z) s.x(i,2) -= s.domain_z;
      if(z<0)          s.x(i,2) += s.domain_z;
    }   
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangePack, 
                   const T_INT& i) const {
    if(s.type(i)<0) return;
    if( (phase == 0) && (s.x(i,0)>s.sub_domain_hi_x)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i; 
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[0] == proc_grid[0]-1)
          p.x -= s.domain_x;
        pack_buffer(pack_idx) = p;
      }
    }  

    if( (phase == 1) && (s.x(i,0)<s.sub_domain_lo_x)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[0] == 0)
          p.x += s.domain_x;
        pack_buffer(pack_idx) = p;
      }
    }

    if( (phase == 2) && (s.x(i,1)>s.sub_domain_hi_y)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[1] == proc_grid[1]-1)
          p.y -= s.domain_y;
        pack_buffer(pack_idx) = p;
      }
    }
    if( (phase == 3) && (s.x(i,1)<s.sub_domain_lo_y)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[1] == 0)
          p.y += s.domain_y;
        pack_buffer(pack_idx) = p;
      }
    }

    if( (phase == 4) && (s.x(i,2)>s.sub_domain_hi_z)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[2] == proc_grid[2]-1)
          p.z -= s.domain_z;
        pack_buffer(pack_idx) = p;
      }
    }
    if( (phase == 5) && (s.x(i,2)<s.sub_domain_lo_z)) {
      const int pack_idx = pack_count()++;
      if( pack_idx < pack_indicies.extent(0) ) {
        pack_indicies(pack_idx) = i;
        Particle p = s.get_particle(i);
        s.type(i) = -1;
        if(proc_pos[2] == 0)
          p.z += s.domain_z;
        pack_buffer(pack_idx) = p;
      }
    }
  } 

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeCreateDestList,
                   const T_INT& i, T_INT& c, const bool final) const {
    if(s.type(i)<0) {
      if(final) {
        exchange_dest_list(c) = i;
      }
      c++;
    }
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeCompact,
                   const T_INT& ii, T_INT& c, const bool final) const {
    const T_INT i = N_local+N_ghost-1-ii;
    if(s.type(i)>=0) {
      if(final) {
        s.copy(exchange_dest_list(c),i,0,0,0);
      }
      c++;
    }
  }

  
  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloSelf,
                   const T_INT& i) const {
    if(phase == 0) {
      if( s.x(i,0)>=s.sub_domain_hi_x - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x -= s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 1) {
      if( s.x(i,0)<=s.sub_domain_lo_x + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x += s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 2) {
      if( s.x(i,1)>=s.sub_domain_hi_y - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y -= s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 3) {
      if( s.x(i,1)<=s.sub_domain_lo_y + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y += s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 4) {
      if( s.x(i,2)>=s.sub_domain_hi_z - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z -= s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 5) {
      if( s.x(i,2)<=s.sub_domain_lo_z + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z += s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }

  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloPack,
                   const T_INT& i) const {
    if(phase == 0) {
      if( s.x(i,0)>=s.sub_domain_hi_x - comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[0] == proc_grid[0]-1)
            p.x -= s.domain_x;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 1) {
      if( s.x(i,0)<=s.sub_domain_lo_x + comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[0] == 0)
            p.x += s.domain_x;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 2) {
      if( s.x(i,1)>=s.sub_domain_hi_y - comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[1] == proc_grid[1]-1)
            p.y -= s.domain_y;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 3) {
      if( s.x(i,1)<=s.sub_domain_lo_y + comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[1] == 0)
            p.y += s.domain_y;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 4) {
      if( s.x(i,2)>=s.sub_domain_hi_z - comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[2] == proc_grid[2]-1)
            p.z -= s.domain_z;
          pack_buffer(pack_idx) = p;
        }
      }
    }
    if(phase == 5) {
      if( s.x(i,2)<=s.sub_domain_lo_z + comm_depth ) {
        const int pack_idx = pack_count()++;
        if(pack_idx < pack_indicies.extent(0)) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          if(proc_pos[2] == 0)
            p.z += s.domain_z;
          pack_buffer(pack_idx) = p;
        }
      }
    }
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagUnpack,
                   const T_INT& i) const {
    s.set_particle(N_local+N_ghost+i, unpack_buffer(i));
  }


  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdateSelf,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_X_FLOAT x_i = s.x(i,0);
    T_X_FLOAT y_i = s.x(i,1);
    T_X_FLOAT z_i = s.x(i,2);

    switch (phase) {
      case 0: x_i -= s.domain_x; break;
      case 1: x_i += s.domain_x; break;
      case 2: y_i -= s.domain_y; break;
      case 3: y_i += s.domain_y; break;
      case 4: z_i -= s.domain_z; break;
      case 5: z_i += s.domain_z; break;
    }
    s.x(N_local + N_ghost + ii, 0) = x_i;
    s.x(N_local + N_ghost + ii, 1) = y_i;
    s.x(N_local + N_ghost + ii, 2) = z_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdatePack,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_X_FLOAT x_i = s.x(i,0);
    T_X_FLOAT y_i = s.x(i,1);
    T_X_FLOAT z_i = s.x(i,2);

    switch (phase) {
      case 0: if(proc_pos[0] == proc_grid[0]-1) x_i -= s.domain_x; break;
      case 1: if(proc_pos[0] == 0)              x_i += s.domain_x; break;
      case 2: if(proc_pos[1] == proc_grid[1]-1) y_i -= s.domain_y; break;
      case 3: if(proc_pos[1] == 0)              y_i += s.domain_y; break;
      case 4: if(proc_pos[2] == proc_grid[2]-1) z_i -= s.domain_z; break;
      case 5: if(proc_pos[2] == 0)              z_i += s.domain_z; break;
    }
    pack_buffer_update(ii, 0) = x_i;
    pack_buffer_update(ii, 1) = y_i;
    pack_buffer_update(ii, 2) = z_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdateUnpack,
                   const T_INT& ii) const {
    s.x(N_local + N_ghost + ii, 0) = unpack_buffer_update(ii, 0);
    s.x(N_local + N_ghost + ii, 1) = unpack_buffer_update(ii, 1);
    s.x(N_local + N_ghost + ii, 2) = unpack_buffer_update(ii, 2);
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForceSelf,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_F_FLOAT fx_i = s.f(ghost_offsets[phase] + ii,0);
    T_F_FLOAT fy_i = s.f(ghost_offsets[phase] + ii,1);
    T_F_FLOAT fz_i = s.f(ghost_offsets[phase] + ii,2);

    s.f(i, 0) += fx_i;
    s.f(i, 1) += fy_i;
    s.f(i, 2) += fz_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForcePack,
                   const T_INT& ii) const {

    T_F_FLOAT fx_i = s.f(ghost_offsets[phase] + ii,0);
    T_F_FLOAT fy_i = s.f(ghost_offsets[phase] + ii,1);
    T_F_FLOAT fz_i = s.f(ghost_offsets[phase] + ii,2);

    unpack_buffer_update(ii, 0) = fx_i;
    unpack_buffer_update(ii, 1) = fy_i;
    unpack_buffer_update(ii, 2) = fz_i;
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForceUnpack,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);

    s.f(i, 0) += pack_buffer_update(ii, 0);
    s.f(i, 1) += pack_buffer_update(ii, 1);
    s.f(i, 2) += pack_buffer_update(ii, 2);
  }

  const char* name();
  int process_rank();
  int num_processes();
  void error(const char *);
};

#endif
#endif // MODULES_OPTION_CHECK



---

# comm_serial.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<comm_serial.h>

CommSerial::CommSerial(System* s, T_X_FLOAT comm_depth):Comm(s,comm_depth) {
  printf("CommSerial\n");
  pack_count = Kokkos::View<int>("CommSerial::pack_count");
  pack_indicies_all = Kokkos::View<T_INT**,Kokkos::LayoutRight>("CommSerial::pack_indicies_all",6,0);
}

void CommSerial::exchange() {
  s = *system;
  N_local = system->N_local;

  Kokkos::parallel_for("CommSerial::exchange_self",
            Kokkos::RangePolicy<TagExchangeSelf, Kokkos::IndexType<T_INT> >(0,N_local), *this);
};

void CommSerial::exchange_halo() {

  N_local = system->N_local;
  N_ghost = 0;

  s = *system;

  for(phase = 0; phase < 6; phase ++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    T_INT count = 0;
    Kokkos::deep_copy(pack_count,0);

    T_INT nparticles = N_local + N_ghost - ( (phase%2==1) ? num_ghost[phase-1]:0 );
    Kokkos::parallel_for("CommSerial::halo_exchange_self",
              Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
              *this);
    Kokkos::deep_copy(count,pack_count);
    bool redo = false;
    if(N_local+N_ghost+count>s.x.extent(0)) {
      system->grow(N_local + N_ghost + count);
      s = *system;
      redo = true;
    }
    if(count > pack_indicies.extent(0)) {
      Kokkos::resize(pack_indicies_all,6,count*1.1);
      pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());
      redo = true;
    }
    if(redo) {
      Kokkos::deep_copy(pack_count,0);
      Kokkos::parallel_for("CommSerial::halo_exchange_self",
                Kokkos::RangePolicy<TagHaloSelf, Kokkos::IndexType<T_INT> >(0,nparticles),
                *this);
    }

    num_ghost[phase] = count;

    N_ghost += count;
  }

  system->N_ghost = N_ghost;
};

void CommSerial::update_halo() {
  N_ghost = 0;
  s=*system;
  for(phase = 0; phase<6; phase++) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    Kokkos::parallel_for("CommSerial::halo_update_self",
      Kokkos::RangePolicy<TagHaloUpdateSelf, Kokkos::IndexType<T_INT> >(0,num_ghost[phase]),
      *this);
    N_ghost += num_ghost[phase];
  }
};

void CommSerial::update_force() {
  //printf("Update Force\n");
  s=*system;
  ghost_offsets[0] = s.N_local;
  for(phase = 1; phase<6; phase++) {
    ghost_offsets[phase] = ghost_offsets[phase-1] + num_ghost[phase-1];
  }

  for(phase = 5; phase>=0; phase--) {
    pack_indicies = Kokkos::subview(pack_indicies_all,phase,Kokkos::ALL());

    Kokkos::parallel_for("CommSerial::halo_force_self",
      Kokkos::RangePolicy<TagHaloForceSelf, Kokkos::IndexType<T_INT> >(0,num_ghost[phase]),
      *this);
  }
};

const char* CommSerial::name() { return "CommSerial"; }


---

# comm_serial.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "SERIAL") == 0) )
        comm_type = COMM_SERIAL;
#endif
#ifdef COMM_MODULES_INSTANTIATION
      else if(input->comm_type == COMM_SERIAL) {
        comm = new CommSerial(system,input->force_cutoff + input->neighbor_skin);
      }
#endif


#if !defined(MODULES_OPTION_CHECK) && !defined(COMM_MODULES_INSTANTIATION)
#ifndef COMM_SERIAL_H
#define COMM_SERIAL_H
#include<comm.h>

class CommSerial: public Comm {

  // Variables Comm doesn't own but requires for computations

  T_INT N_local;
  T_INT N_ghost;

  System s;

  // Owned Variables

  int phase; // Communication Phase
  T_INT num_ghost[6];

  T_INT ghost_offsets[6];

  T_INT num_packed;
  Kokkos::View<int, Kokkos::MemoryTraits<Kokkos::Atomic> > pack_count;

  Kokkos::View<T_INT**,Kokkos::LayoutRight> pack_indicies_all;
  Kokkos::View<T_INT*,Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Unmanaged> > pack_indicies;


public:

  struct TagUnpack {};

  struct TagExchangeSelf {};
  
  struct TagHaloSelf {};
  struct TagHaloUpdateSelf {};
  struct TagHaloForceSelf {};

  CommSerial(System* s, T_X_FLOAT comm_depth_);
  void exchange();
  void exchange_halo();
  void update_halo();
  void update_force();

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagExchangeSelf, 
                   const T_INT& i) const {
    const T_X_FLOAT x = s.x(i,0);
    if(x>s.domain_x) s.x(i,0) -= s.domain_x;
    if(x<0)          s.x(i,0) += s.domain_x;

    const T_X_FLOAT y = s.x(i,1);
    if(y>s.domain_y) s.x(i,1) -= s.domain_y;
    if(y<0)          s.x(i,1) += s.domain_y;

    const T_X_FLOAT z = s.x(i,2);
    if(z>s.domain_z) s.x(i,2) -= s.domain_z;
    if(z<0)          s.x(i,2) += s.domain_z;
  }


  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloSelf,
                   const T_INT& i) const {
    if(phase == 0) {
      if( s.x(i,0)>=s.sub_domain_hi_x - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x -= s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 1) {
      if( s.x(i,0)<=s.sub_domain_lo_x + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.x += s.domain_x;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 2) {
      if( s.x(i,1)>=s.sub_domain_hi_y - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y -= s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 3) {
      if( s.x(i,1)<=s.sub_domain_lo_y + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.y += s.domain_y;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 4) {
      if( s.x(i,2)>=s.sub_domain_hi_z - comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z -= s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }
    if(phase == 5) {
      if( s.x(i,2)<=s.sub_domain_lo_z + comm_depth ) {
        const int pack_idx = pack_count()++;
        if((pack_idx < pack_indicies.extent(0)) && (N_local+N_ghost+pack_idx< s.x.extent(0))) {
          pack_indicies(pack_idx) = i;
          Particle p = s.get_particle(i);
          p.z += s.domain_z;
          s.set_particle(N_local + N_ghost + pack_idx, p);
        }
      }
    }

  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloUpdateSelf,
                   const T_INT& i) const {

    Particle p = s.get_particle(pack_indicies(i));
    switch (phase) {
      case 0: p.x -= s.domain_x; break;
      case 1: p.x += s.domain_x; break;
      case 2: p.y -= s.domain_y; break;
      case 3: p.y += s.domain_y; break;
      case 4: p.z -= s.domain_z; break;
      case 5: p.z += s.domain_z; break;
    }
    s.set_particle(N_local + N_ghost + i, p);     
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagHaloForceSelf,
                   const T_INT& ii) const {

    const T_INT i = pack_indicies(ii);
    T_F_FLOAT fx_i = s.f(ghost_offsets[phase] + ii,0);
    T_F_FLOAT fy_i = s.f(ghost_offsets[phase] + ii,1);
    T_F_FLOAT fz_i = s.f(ghost_offsets[phase] + ii,2);

    //printf("FORCESELF %i %i %i %lf %lf\n",i,ghost_offsets[phase] + ii,ghost_offsets[phase],s.f(i,0),fx_i);
    s.f(i, 0) += fx_i;
    s.f(i, 1) += fy_i;
    s.f(i, 2) += fz_i;

  }

  const char* name();
};
#endif
#endif // MODULES_OPTION_CHECK


---

# CMakeLists.txt

SET(HEADERS
  force_lj_cell.h
  force_lj_idial_neigh.h
  force_lj_idial_neigh_impl.h
  force_lj_neigh.h
  force_lj_neigh_impl.h
  force_snap_neigh.h
  force_snap_neigh_impl.h
  sna.h)

SET(SOURCES
  force_lj_cell.cpp
  force_lj_idial_neigh.cpp
  force_lj_neigh.cpp
  force_snap_neigh.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# force_lj_cell.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_cell.h>

ForceLJCell::ForceLJCell(char** args, System* system, bool half_neigh_):Force(args,system,half_neigh) {
  lj1 = t_fparams("ForceLJCell::lj1",system->ntypes,system->ntypes);
  lj2 = t_fparams("ForceLJCell::lj2",system->ntypes,system->ntypes);
  cutsq = t_fparams("ForceLJCell::cutsq",system->ntypes,system->ntypes);
}

void ForceLJCell::init_coeff(int nargs, char** args) {
  int one_based_type = 1;
  int t1 = atoi(args[1])-one_based_type;
  int t2 = atoi(args[2])-one_based_type;
  double eps = atof(args[3]);
  double sigma = atof(args[4]);
  double cut = atof(args[5]);

  lj1(t1,t2) = 48.0 * eps * pow(sigma,12.0);
  lj2(t1,t2) = 24.0 * eps * pow(sigma,6.0);
  lj1(t2,t1) = lj1(t1,t2);
  lj2(t2,t1) = lj2(t1,t2);
  cutsq(t1,t2) = cut*cut;
  cutsq(t2,t1) = cut*cut;
};

void ForceLJCell::compute(System* system, Binning* binning, Neighbor*) {
  x = system->x;
  f = system->f;
  id = system->id;
  type = system->type;
  N_local = system->N_local;


  static int step_i = 0;
  step = step_i;
  bin_count = binning->bincount;
  bin_offsets = binning->binoffsets;
  permute_vector = binning->permute_vector;

  nhalo = binning->nhalo;
  nbinx = binning->nbinx;
  nbiny = binning->nbiny;
  nbinz = binning->nbinz;

  Kokkos::deep_copy(f,0.0);
  T_INT nbins = nbinx*nbiny*nbinz;

  Kokkos::parallel_for("ForceLJCell::computer", t_policy(nbins,1,8), *this);

  step_i++;
  x = t_x();
  type = t_type();
  f = t_f();

}

T_F_FLOAT ForceLJCell::compute_energy(System* system, Binning* binning, Neighbor*) {
  x = system->x;
  id = system->id;
  type = system->type;
  N_local = system->N_local;

  bin_count = binning->bincount;
  bin_offsets = binning->binoffsets;
  permute_vector = binning->permute_vector;

  nhalo = binning->nhalo;
  nbinx = binning->nbinx;
  nbiny = binning->nbiny;
  nbinz = binning->nbinz;

  T_INT nbins = nbinx*nbiny*nbinz;
  T_F_FLOAT PE;
  Kokkos::parallel_reduce("ForceLJCell::compute_energy", t_policy_pe(nbins,1,8), *this, PE);

  x = t_x();
  id = t_id();
  type = t_type();

  return PE;
}

const char* ForceLJCell::name() { return "ForceLJCellFull"; }


---

# force_lj_cell.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "CELL_FULL") == 0) )
        force_iteration_type = FORCE_ITER_CELL_FULL;
#endif
#ifdef MODULES_INSTANTIATION
    else if ((input->force_type == FORCE_LJ) && (input->force_iteration_type == FORCE_ITER_CELL_FULL)){
      force = new ForceLJCell(input->input_data.words[input->force_line],system,false);
    }
#endif


#if !defined(MODULES_OPTION_CHECK) && !defined(MODULES_INSTANTIATION)

#ifndef FORCE_LJ_CELL_H
#define FORCE_LJ_CELL_H
#include<force.h>

class ForceLJCell: public Force {
private:
  t_x x;
  t_f f;
  t_id id;
  t_type type;
  Binning::t_bincount bin_count;
  Binning::t_binoffsets bin_offsets;
  Binning::t_permute_vector permute_vector;
  T_INT nbinx,nbiny,nbinz,nhalo;
  int N_local;
  int step;

  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  t_fparams lj1,lj2,cutsq;

public:
  struct TagCell {};
  struct TagCellPE {};

  typedef Kokkos::TeamPolicy<TagCell, Kokkos::IndexType<T_INT> > t_policy;
  typedef Kokkos::TeamPolicy<TagCellPE, Kokkos::IndexType<T_INT> > t_policy_pe;

  ForceLJCell (char** args, System* system, bool half_neigh);

  void init_coeff(int nargs, char** args);

  void compute(System* system, Binning* binning, Neighbor* );
  T_F_FLOAT compute_energy(System* system, Binning* binning, Neighbor* );

  KOKKOS_INLINE_FUNCTION
    void operator() (TagCell, const typename t_policy::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz);
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny;
    const T_INT bz = team.league_rank() % nbinz;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      t_scalar3<T_F_FLOAT> f_i;
      for(int bx_j = bx>0?bx-1:bx; bx_j < (bx+1<nbinx?bx+2:bx+1); bx_j++)
      for(int by_j = by>0?by-1:by; by_j < (by+1<nbiny?by+2:by+1); by_j++)
      for(int bz_j = bz>0?bz-1:bz; bz_j < (bz+1<nbinz?bz+2:bz+1); bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

        t_scalar3<T_F_FLOAT> f_i_tmp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&]
          (const T_INT bj, t_scalar3<T_F_FLOAT>& lf_i) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
          
          if((rsq < cutsq(type_i,type_j)) && (i!=j)) {
            T_F_FLOAT r2inv = 1.0/rsq;
            T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
            T_F_FLOAT fpair = (r6inv * (lj1(type_i,type_j)*r6inv - lj2(type_i,type_j))) * r2inv;
            lf_i.x += dx*fpair;
            lf_i.y += dy*fpair;
            lf_i.z += dz*fpair;
          }
        },f_i_tmp);
        f_i += f_i_tmp;
      }
      f(i,0) += f_i.x;
      f(i,1) += f_i.y;
      f(i,2) += f_i.z;
    });
  } 

  KOKKOS_INLINE_FUNCTION
  void operator() (TagCellPE, const typename t_policy_pe::member_type& team, T_F_FLOAT& PE_bi) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz);
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny;
    const T_INT bz = team.league_rank() % nbinz;
    const bool shift_flag = true;

    T_F_FLOAT PE_i;
    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_reduce(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&]
      (const int bi, T_F_FLOAT& PE_i) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx>0?bx-1:bx; bx_j < (bx+1<nbinx?bx+2:bx+1); bx_j++)
      for(int by_j = by>0?by-1:by; by_j < (by+1<nbiny?by+2:by+1); by_j++)
      for(int bz_j = bz>0?bz-1:bz; bz_j < (bz+1<nbinz?bz+2:bz+1); bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

        T_F_FLOAT PE_ibj;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&]
          (const T_INT bj, T_F_FLOAT& PE_ibj) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
          
          if((rsq < cutsq(type_i,type_j)) && (i!=j)) {
            T_F_FLOAT r2inv = 1.0/rsq;
            T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
            PE_ibj += 0.5*r6inv * (0.5*lj1(type_i,type_j)*r6inv - lj2(type_i,type_j)) / 6.0; // optimize later
            if (shift_flag) {
              T_F_FLOAT r2invc = 1.0/cutsq(type_i,type_j);
              T_F_FLOAT r6invc = r2invc*r2invc*r2invc;
              PE_ibj -= 0.5*r6invc * (0.5*lj1(type_i,type_j)*r6invc - lj2(type_i,type_j)) / 6.0; // optimize later
            }
          }
        },PE_ibj);
        PE_i += PE_ibj;
      }
      },PE_i);
    PE_bi += PE_i;
  }

  const char* name();
};
#endif
#endif


---

# force_lj_idial_neigh.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_idial_neigh_impl.h>
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJIDialNeigh<NeighType>
#define FORCE_MODULES_TEMPLATE
#include<modules_neighbor.h>
#undef FORCE_MODULES_TEMPLATE


---

# force_lj_idial_neigh.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "NEIGH_FULL") == 0) )
        force_iteration_type = FORCE_ITER_NEIGH_FULL;
      if( (strcmp(argv[i+1], "NEIGH_HALF") == 0) ) {
        force_iteration_type = FORCE_ITER_NEIGH_HALF;
      }
#endif
#ifdef FORCE_MODULES_INSTANTIATION
    else if (input->force_type == FORCE_LJ_IDIAL) {
      bool half_neigh = input->force_iteration_type == FORCE_ITER_NEIGH_HALF;
      switch ( input->neighbor_type ) {
        #define FORCETYPE_ALLOCATION_MACRO(NeighType)  ForceLJIDialNeigh<NeighType>(input->input_data.words[input->force_line],system,half_neigh)
        #include <modules_neighbor.h>
        #undef FORCETYPE_ALLOCATION_MACRO
      }
    }
#endif


#if !defined(MODULES_OPTION_CHECK) && \
    !defined(FORCE_MODULES_INSTANTIATION)

#ifndef FORCE_LJ_IDIAL_NEIGH_H
#define FORCE_LJ_IDIAL_NEIGH_H
#include<force.h>

template<class NeighborClass>
class ForceLJIDialNeigh: public Force {
private:
  int N_local;
  t_x_const_rnd x;
  t_f f;
  t_f_atomic f_a;
  t_id id;
  t_type_const_rnd type;
  Binning::t_bincount bin_count;
  Binning::t_binoffsets bin_offsets;
  T_INT nbinx,nbiny,nbinz,nhalo;
  int step;

  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  typedef Kokkos::View<const T_F_FLOAT**,
      Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_fparams_rnd;
  t_fparams lj1,lj2,cutsq,intensity;
  t_fparams_rnd rnd_lj1,rnd_lj2,rnd_cutsq,rnd_intensity;

  typedef typename NeighborClass::t_neigh_list t_neigh_list;
  t_neigh_list neigh_list;

public:
  struct TagFullNeigh {};
  struct TagHalfNeigh {};

  typedef Kokkos::RangePolicy<TagFullNeigh,Kokkos::IndexType<T_INT> > t_policy_full_neigh;
  typedef Kokkos::RangePolicy<TagHalfNeigh,Kokkos::IndexType<T_INT> > t_policy_half_neigh;

  ForceLJIDialNeigh (char** args, System* system, bool half_neigh_);

  void init_coeff(int nargs, char** args);

  void compute(System* system, Binning* binning, Neighbor* neighbor );

  KOKKOS_INLINE_FUNCTION
  void operator() (TagFullNeigh, const T_INT& i) const;

  KOKKOS_INLINE_FUNCTION
  void operator() (TagHalfNeigh, const T_INT& i) const;

  const char* name();
};

#define FORCE_MODULES_EXTERNAL_TEMPLATE
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJIDialNeigh<NeighType>
#include<modules_neighbor.h>
#undef FORCETYPE_DECLARE_TEMPLATE_MACRO
#undef FORCE_MODULES_EXTERNAL_TEMPLATE
#endif
#endif


---

# force_lj_idial_neigh_impl.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_idial_neigh.h>

template<class NeighborClass>
ForceLJIDialNeigh<NeighborClass>::ForceLJIDialNeigh(char** args, System* system, bool half_neigh_):Force(args,system,half_neigh_) {
  lj1 = t_fparams("ForceLJIDialNeigh::lj1",system->ntypes,system->ntypes);
  lj2 = t_fparams("ForceLJIDialNeigh::lj2",system->ntypes,system->ntypes);
  cutsq = t_fparams("ForceLJIDialNeigh::cutsq",system->ntypes,system->ntypes);
  intensity = t_fparams("ForceLJIDialNeigh::intensity",system->ntypes,system->ntypes);
}

template<class NeighborClass>
void ForceLJIDialNeigh<NeighborClass>::init_coeff(int nargs, char** args) {
  int one_based_type = 1;
  int t1 = atoi(args[1])-one_based_type;
  int t2 = atoi(args[2])-one_based_type;
  double eps = atof(args[3]);
  double sigma = atof(args[4]);
  double cut = atof(args[5]);
  int nrepeat = atoi(args[6]);

  t_fparams::HostMirror h_lj1 = Kokkos::create_mirror_view(lj1);
  t_fparams::HostMirror h_lj2 = Kokkos::create_mirror_view(lj2);
  t_fparams::HostMirror h_cutsq = Kokkos::create_mirror_view(cutsq);
  t_fparams::HostMirror h_intensity = Kokkos::create_mirror_view(intensity);
  Kokkos::deep_copy(h_lj1,lj1);
  Kokkos::deep_copy(h_lj2,lj2);
  Kokkos::deep_copy(h_cutsq,cutsq);
  Kokkos::deep_copy(h_intensity,intensity);

  h_lj1(t1,t2) = 48.0 * eps * pow(sigma,12.0);
  h_lj2(t1,t2) = 24.0 * eps * pow(sigma,6.0);
  h_lj1(t2,t1) = h_lj1(t1,t2);
  h_lj2(t2,t1) = h_lj2(t1,t2);
  h_cutsq(t1,t2) = cut*cut;
  h_cutsq(t2,t1) = cut*cut;
  h_intensity(t1,t2) = nrepeat;
  h_intensity(t2,t1) = nrepeat;

  Kokkos::deep_copy(lj1,h_lj1);
  Kokkos::deep_copy(lj2,h_lj2);
  Kokkos::deep_copy(cutsq,h_cutsq);
  Kokkos::deep_copy(intensity,h_intensity);

  rnd_lj1 = lj1;
  rnd_lj2 = lj2;
  rnd_cutsq = cutsq;
  rnd_intensity = intensity;
  step = 0;
};

template<class NeighborClass>
void ForceLJIDialNeigh<NeighborClass>::compute(System* system, Binning* binning, Neighbor* neighbor_ ) {
  // Set internal data handles
  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();

  N_local = system->N_local;
  x = system->x;
  f = system->f;
  f_a = system->f;
  type = system->type;
  if(half_neigh)
    Kokkos::parallel_for("ForceLJIDialNeigh::computer", t_policy_half_neigh(0, system->N_local), *this);
  else
    Kokkos::parallel_for("ForceLJIDialNeigh::computer", t_policy_full_neigh(0, system->N_local), *this);
  Kokkos::fence();

  // Reset internal data handles so we don't keep a reference count
  /*x = t_x();
  type = t_type();
  f = t_f();
  neigh_list = NeighborCSR<t_neigh_mem_space>::t_neigh_list();*/
  step++;
}

template<class NeighborClass>
const char* ForceLJIDialNeigh<NeighborClass>::name() { return half_neigh?"ForceLJIDialNeighHalf":"ForceLJIDialNeighFull"; }

template<class NeighborClass>
KOKKOS_INLINE_FUNCTION
void ForceLJIDialNeigh<NeighborClass>::operator() (TagFullNeigh, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;

//    printf("NUMNEIGHS: %i %i\n",i,num_neighs);
  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    if( rsq < rnd_cutsq(type_i,type_j) ) {
      //-----------------
      // This 'for' loop increases the computational intensity of the LJ force evaluation.
      // intensity(type_i,type_j) acts as an intensity dial.
      // Could/should we implement this as a 'kokkos:parallel_for' loop?
      //-----------------
      T_F_FLOAT fpair = 0;
      for(int repeat = 0; repeat < intensity(type_i,type_j); repeat++) {
        T_F_FLOAT r2inv = 1.0/rsq;
        T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
        fpair += (r6inv * (rnd_lj1(type_i,type_j)*r6inv
                - rnd_lj2(type_i,type_j))) * r2inv/intensity(type_i,type_j);
      }
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
    }
  }
  f(i,0) += fxi;
  f(i,1) += fyi;
  f(i,2) += fzi;

}

template<class NeighborClass>
KOKKOS_INLINE_FUNCTION
void ForceLJIDialNeigh<NeighborClass>::operator() (TagHalfNeigh, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;
//printf("NUMNEIGHS: %i %i\n",i,num_neighs);
  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    if( rsq < rnd_cutsq(type_i,type_j) ) {
      //-----------------
      // This 'for' loop increases the computational intensity of the LJ force evaluation.
      // intensity(type_i,type_j) acts as an intensity dial.
      // Could/should we implement this as a 'kokkos:parallel_for' loop?
      //-----------------
      T_F_FLOAT fpair = 0;
      for(int repeat = 0; repeat < intensity(type_i,type_j); repeat++) {
        T_F_FLOAT r2inv = 1.0/rsq;
        T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
        fpair += (r6inv * (rnd_lj1(type_i,type_j)*r6inv
                  - rnd_lj2(type_i,type_j))) * r2inv/intensity(type_i,type_j);
      }
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
      if(j<N_local) {
        f_a(j,0) -= dx*fpair;
        f_a(j,1) -= dy*fpair;
        f_a(j,2) -= dz*fpair;
      }
    }
  }
  f_a(i,0) += fxi;
  f_a(i,1) += fyi;
  f_a(i,2) += fzi;

}


---

# force_lj_neigh.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_neigh_impl.h>
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJNeigh<NeighType>
#define FORCE_MODULES_TEMPLATE
#include<modules_neighbor.h>
#undef FORCE_MODULES_TEMPLATE


---

# force_lj_neigh.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "NEIGH_FULL") == 0) )
        force_iteration_type = FORCE_ITER_NEIGH_FULL;
      if( (strcmp(argv[i+1], "NEIGH_HALF") == 0) ) {
        force_iteration_type = FORCE_ITER_NEIGH_HALF;
      }
#endif
#ifdef FORCE_MODULES_INSTANTIATION
    else if (input->force_type == FORCE_LJ) {
      bool half_neigh = input->force_iteration_type == FORCE_ITER_NEIGH_HALF;
      switch ( input->neighbor_type ) {
        #define FORCETYPE_ALLOCATION_MACRO(NeighType)  ForceLJNeigh<NeighType>(input->input_data.words[input->force_line],system,half_neigh)
        #include <modules_neighbor.h>
        #undef FORCETYPE_ALLOCATION_MACRO
      }
    }
#endif


#if !defined(MODULES_OPTION_CHECK) && \
    !defined(FORCE_MODULES_INSTANTIATION)

#ifndef FORCE_LJ_NEIGH_H
#define FORCE_LJ_NEIGH_H
#include<force.h>

template<class NeighborClass>
class ForceLJNeigh: public Force {
private:
  int N_local,ntypes;
  t_x_const_rnd x;
  t_f f;
  t_f_atomic f_a;
  t_id id;
  t_type_const_rnd type;
  Binning::t_bincount bin_count;
  Binning::t_binoffsets bin_offsets;
  T_INT nbinx,nbiny,nbinz,nhalo;
  int step;
  bool use_stackparams;

  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  typedef Kokkos::View<const T_F_FLOAT**,
      Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_fparams_rnd;
  t_fparams lj1,lj2,cutsq;
  t_fparams_rnd rnd_lj1,rnd_lj2,rnd_cutsq;

  T_F_FLOAT stack_lj1[MAX_TYPES_STACKPARAMS+1][MAX_TYPES_STACKPARAMS+1]; // hardwired space for 12 atom types
  T_F_FLOAT stack_lj2[MAX_TYPES_STACKPARAMS+1][MAX_TYPES_STACKPARAMS+1];
  T_F_FLOAT stack_cutsq[MAX_TYPES_STACKPARAMS+1][MAX_TYPES_STACKPARAMS+1];

  typedef typename NeighborClass::t_neigh_list t_neigh_list;
  t_neigh_list neigh_list;

public:
  typedef T_V_FLOAT value_type;

  template<bool STACKPARAMS>
  struct TagFullNeigh {};

  template<bool STACKPARAMS>
  struct TagHalfNeigh {};

  template<bool STACKPARAMS>
  struct TagFullNeighPE {};

  template<bool STACKPARAMS>
  struct TagHalfNeighPE {};

  typedef Kokkos::RangePolicy<TagFullNeigh<false>,Kokkos::IndexType<T_INT> > t_policy_full_neigh;
  typedef Kokkos::RangePolicy<TagHalfNeigh<false>,Kokkos::IndexType<T_INT> > t_policy_half_neigh;
  typedef Kokkos::RangePolicy<TagFullNeighPE<false>,Kokkos::IndexType<T_INT> > t_policy_full_neigh_pe;
  typedef Kokkos::RangePolicy<TagHalfNeighPE<false>,Kokkos::IndexType<T_INT> > t_policy_half_neigh_pe;

  typedef Kokkos::RangePolicy<TagFullNeigh<true>,Kokkos::IndexType<T_INT> > t_policy_full_neigh_stackparams;
  typedef Kokkos::RangePolicy<TagHalfNeigh<true>,Kokkos::IndexType<T_INT> > t_policy_half_neigh_stackparams;
  typedef Kokkos::RangePolicy<TagFullNeighPE<true>,Kokkos::IndexType<T_INT> > t_policy_full_neigh_pe_stackparams;
  typedef Kokkos::RangePolicy<TagHalfNeighPE<true>,Kokkos::IndexType<T_INT> > t_policy_half_neigh_pe_stackparams;

  ForceLJNeigh (char** args, System* system, bool half_neigh_);

  void init_coeff(int nargs, char** args);

  void compute(System* system, Binning* binning, Neighbor* neighbor );
  T_F_FLOAT compute_energy(System* system, Binning* binning, Neighbor* neighbor);

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagFullNeigh<STACKPARAMS>, const T_INT& i) const;

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagHalfNeigh<STACKPARAMS>, const T_INT& i) const;

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagFullNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const;

  template<bool STACKPARAMS>
  KOKKOS_INLINE_FUNCTION
  void operator() (TagHalfNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const;

  const char* name();
};

#define FORCE_MODULES_EXTERNAL_TEMPLATE
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceLJNeigh<NeighType>
#include<modules_neighbor.h>
#undef FORCETYPE_DECLARE_TEMPLATE_MACRO
#undef FORCE_MODULES_EXTERNAL_TEMPLATE
#endif
#endif


---

# force_lj_neigh_impl.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<force_lj_neigh.h>

template<class NeighborClass>
ForceLJNeigh<NeighborClass>::ForceLJNeigh(char** args, System* system, bool half_neigh_):Force(args,system,half_neigh_) {
  ntypes = system->ntypes;
  use_stackparams = (ntypes <= MAX_TYPES_STACKPARAMS);
  if (!use_stackparams) {
    lj1 = t_fparams("ForceLJNeigh::lj1",ntypes,ntypes);
    lj2 = t_fparams("ForceLJNeigh::lj2",ntypes,ntypes);
    cutsq = t_fparams("ForceLJNeigh::cutsq",ntypes,ntypes);
  }
  nbinx = nbiny = nbinz = 0;
  N_local = 0;
  nhalo = 0;
  step = 0;
}

template<class NeighborClass>
void ForceLJNeigh<NeighborClass>::init_coeff(int nargs, char** args) {
  step = 0;

  int one_based_type = 1;
  int t1 = atoi(args[1])-one_based_type;
  int t2 = atoi(args[2])-one_based_type;
  double eps = atof(args[3]);
  double sigma = atof(args[4]);
  double cut = atof(args[5]);

  if (use_stackparams) {
    for (int i = 0; i < ntypes; i++) {
      for (int j = 0; j < ntypes; j++) {
        stack_lj1[i][j] = 48.0 * eps * pow(sigma,12.0);
        stack_lj2[i][j] = 24.0 * eps * pow(sigma,6.0);
        stack_cutsq[i][j] = cut*cut;
      }
    }
  } else {
    t_fparams::HostMirror h_lj1 = Kokkos::create_mirror_view(lj1);
    t_fparams::HostMirror h_lj2 = Kokkos::create_mirror_view(lj2);
    t_fparams::HostMirror h_cutsq = Kokkos::create_mirror_view(cutsq);
    Kokkos::deep_copy(h_lj1,lj1);
    Kokkos::deep_copy(h_lj2,lj2);
    Kokkos::deep_copy(h_cutsq,cutsq);

    h_lj1(t1,t2) = 48.0 * eps * pow(sigma,12.0);
    h_lj2(t1,t2) = 24.0 * eps * pow(sigma,6.0);
    h_lj1(t2,t1) = h_lj1(t1,t2);
    h_lj2(t2,t1) = h_lj2(t1,t2);
    h_cutsq(t1,t2) = cut*cut;
    h_cutsq(t2,t1) = cut*cut;

    Kokkos::deep_copy(lj1,h_lj1);
    Kokkos::deep_copy(lj2,h_lj2);
    Kokkos::deep_copy(cutsq,h_cutsq);

    rnd_lj1 = lj1;
    rnd_lj2 = lj2;
    rnd_cutsq = cutsq;
  }
};

template<class NeighborClass>
void ForceLJNeigh<NeighborClass>::compute(System* system, Binning* binning, Neighbor* neighbor_ ) {
  // Set internal data handles
  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();

  N_local = system->N_local;
  x = system->x;
  f = system->f;
  f_a = system->f;
  type = system->type;
  id = system->id;
  if (use_stackparams) {
    if(half_neigh)
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_half_neigh_stackparams(0, system->N_local), *this);
    else
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_full_neigh_stackparams(0, system->N_local), *this);
  } else {
    if(half_neigh)
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_half_neigh(0, system->N_local), *this);
    else
      Kokkos::parallel_for("ForceLJNeigh::compute", t_policy_full_neigh(0, system->N_local), *this);
  }
  Kokkos::fence();

  step++;
}

template<class NeighborClass>
T_V_FLOAT ForceLJNeigh<NeighborClass>::compute_energy(System* system, Binning* binning, Neighbor* neighbor_ ) {
  // Set internal data handles
  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();

  N_local = system->N_local;
  x = system->x;
  f = system->f;
  f_a = system->f;
  type = system->type;
  id = system->id;
  T_V_FLOAT energy;
  if (use_stackparams) {
    if(half_neigh)
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_half_neigh_pe_stackparams(0, system->N_local), *this, energy);
    else
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_full_neigh_pe_stackparams(0, system->N_local), *this, energy);
  } else {
    if(half_neigh)
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_half_neigh_pe(0, system->N_local), *this, energy);
    else
      Kokkos::parallel_reduce("ForceLJNeigh::compute_energy", t_policy_full_neigh_pe(0, system->N_local), *this, energy);
  }
  Kokkos::fence();

  step++;
  return energy;
}

template<class NeighborClass>
const char* ForceLJNeigh<NeighborClass>::name() { return half_neigh?"ForceLJNeighHalf":"ForceLJNeighFull"; }

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagFullNeigh<STACKPARAMS>, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;

  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      T_F_FLOAT fpair = (r6inv * (lj1_ij*r6inv - lj2_ij)) * r2inv;
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
    }
  }

  f(i,0) += fxi;
  f(i,1) += fyi;
  f(i,2) += fzi;

}

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagHalfNeigh<STACKPARAMS>, const T_INT& i) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  T_F_FLOAT fxi = 0.0;
  T_F_FLOAT fyi = 0.0;
  T_F_FLOAT fzi = 0.0;
  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      T_F_FLOAT fpair = (r6inv * (lj1_ij*r6inv - lj2_ij)) * r2inv;
      fxi += dx*fpair;
      fyi += dy*fpair;
      fzi += dz*fpair;
      f_a(j,0) -= dx*fpair;
      f_a(j,1) -= dy*fpair;
      f_a(j,2) -= dz*fpair;
    }
  }
  f_a(i,0) += fxi;
  f_a(i,1) += fyi;
  f_a(i,2) += fzi;

}

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagFullNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);
  const bool shift_flag = true;

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      PE += 0.5*r6inv * (0.5*lj1_ij*r6inv - lj2_ij) / 6.0; // optimize later

      if (shift_flag) {
        T_F_FLOAT r2invc = 1.0/cutsq_ij;
        T_F_FLOAT r6invc = r2invc*r2invc*r2invc;
        PE -= 0.5*r6invc * (0.5*lj1_ij*r6invc - lj2_ij) / 6.0; // optimize later
      }
    }
  }
}

template<class NeighborClass>
template<bool STACKPARAMS>
KOKKOS_INLINE_FUNCTION
void ForceLJNeigh<NeighborClass>::operator() (TagHalfNeighPE<STACKPARAMS>, const T_INT& i, T_V_FLOAT& PE) const {
  const T_F_FLOAT x_i = x(i,0);
  const T_F_FLOAT y_i = x(i,1);
  const T_F_FLOAT z_i = x(i,2);
  const int type_i = type(i);
  const bool shift_flag = true;

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  for(int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x_i - x(j,0);
    const T_F_FLOAT dy = y_i - x(j,1);
    const T_F_FLOAT dz = z_i - x(j,2);

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

    const T_F_FLOAT cutsq_ij = STACKPARAMS?stack_cutsq[type_i][type_j]:rnd_cutsq(type_i,type_j);

    if( rsq < cutsq_ij ) {
      const T_F_FLOAT lj1_ij = STACKPARAMS?stack_lj1[type_i][type_j]:rnd_lj1(type_i,type_j);
      const T_F_FLOAT lj2_ij = STACKPARAMS?stack_lj2[type_i][type_j]:rnd_lj2(type_i,type_j);

      T_F_FLOAT r2inv = 1.0/rsq;
      T_F_FLOAT r6inv = r2inv*r2inv*r2inv;
      T_F_FLOAT fac;
      if(j<N_local) fac = 1.0;
      else fac = 0.5;

      PE += fac * r6inv * (0.5*lj1_ij*r6inv - lj2_ij) / 6.0;  // optimize later

      if (shift_flag) {
        T_F_FLOAT r2invc = 1.0/cutsq_ij;
        T_F_FLOAT r6invc = r2invc*r2invc*r2invc;
        PE -= fac * r6invc * (0.5*lj1_ij*r6invc - lj2_ij) / 6.0;  // optimize later
      }
    }
  }

}


---

# force_snap_neigh.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include<Kokkos_Macros.hpp>
#ifndef KOKKOS_ENABLE_OPENMPTARGET
#include<force_snap_neigh_impl.h>
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceSNAP<NeighType>
#define FORCE_MODULES_TEMPLATE
#include<modules_neighbor.h>
#undef FORCE_MODULES_TEMPLATE
#endif


---

# force_snap_neigh.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

/* -*- c++ -*- ----------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "NEIGH_FULL") == 0) )
        force_iteration_type = FORCE_ITER_NEIGH_FULL;
#endif
#ifdef FORCE_MODULES_INSTANTIATION
    else if (input->force_type == FORCE_SNAP) {
      bool half_neigh = input->force_iteration_type == FORCE_ITER_NEIGH_HALF;
      if(half_neigh) Kokkos::abort("ForceSNAP does not support half neighborlist");
      switch ( input->neighbor_type ) {
        #define FORCETYPE_ALLOCATION_MACRO(NeighType)  ForceSNAP<NeighType>(input->input_data.words[input->force_line],system,half_neigh)
        #include <modules_neighbor.h>
        #undef FORCETYPE_ALLOCATION_MACRO
      }
    }

#endif


#if !defined(MODULES_OPTION_CHECK) && \
    !defined(FORCE_MODULES_INSTANTIATION)

#ifndef FORCE_SNAP_NEIGH_H
#define FORCE_SNAP_NEIGH_H
#include<force.h>
#include<sna.h>

template<class NeighborClass>
class ForceSNAP : public Force {
public:
  ForceSNAP(char** args, System* system, bool half_neigh_);
  ~ForceSNAP();
  
  void init_coeff(int nargs, char** args);
  void compute(System* system, Binning* binning, Neighbor* neighbor );

  const char* name() {return "ForceSNAP";}

protected:
  System* system;

  typedef typename NeighborClass::t_neigh_list t_neigh_list;
  t_neigh_list neigh_list;

  int ncoeff, ncoeffq, ncoeffall;
  typedef Kokkos::View<T_F_FLOAT**> t_bvec;
  t_bvec bvec;
  typedef Kokkos::View<T_F_FLOAT***> t_dbvec;
  t_dbvec dbvec;
  SNA sna;

  int nmax;

  // How much parallelism to use within an interaction
  int vector_length;
  // How many interactions can be run concurrently
  int concurrent_interactions;

  void allocate();
  void read_files(char *, char *);
  /*inline int equal(double* x,double* y);
  inline double dist2(double* x,double* y);
  double extra_cutoff();
  void load_balance();
  void set_sna_to_shared(int snaid,int i);
  void build_per_atom_arrays();*/

  int schedule_user;
  double schedule_time_guided;
  double schedule_time_dynamic;

  int ncalls_neigh;
  int do_load_balance;
  int ilistmask_max;
  Kokkos::View<T_INT*> ilistmast;
  int ghostinum;
  int ghostilist_max;
  Kokkos::View<T_INT*> ghostilist;
  int ghostnumneigh_max;
  Kokkos::View<T_INT*> ghostnumneigh;
  Kokkos::View<T_INT*> ghostneighs;
  Kokkos::View<T_INT*> ghostfirstneigh;
  int ghostneighs_total;
  int ghostneighs_max;

  int use_optimized;
  int use_shared_arrays;

  int i_max;
  int i_neighmax;
  int i_numpairs;
  Kokkos::View<T_INT**, Kokkos::LayoutRight> i_pairs;
  Kokkos::View<T_INT***, Kokkos::LayoutRight> i_rij;
  Kokkos::View<T_INT**, Kokkos::LayoutRight> i_inside;
  Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight> i_wj;
  Kokkos::View<T_F_FLOAT***, Kokkos::LayoutRight>i_rcutij;
  Kokkos::View<T_INT*> i_ninside;
  Kokkos::View<T_F_FLOAT****, Kokkos::LayoutRight> i_uarraytot_r, i_uarraytot_i;
  Kokkos::View<T_F_FLOAT******, Kokkos::LayoutRight> i_zarray_r, i_zarray_i;

#ifdef TIMING_INFO
  //  timespec starttime, endtime;
  double timers[4];
#endif

  double rcutmax;               // max cutoff for all elements
  int nelements;                // # of unique elements
  char **elements;              // names of unique elements
  Kokkos::View<T_F_FLOAT*> radelem;              // element radii
  Kokkos::View<T_F_FLOAT*> wjelem;               // elements weights
  Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight> coeffelem;           // element bispectrum coefficients
  Kokkos::View<T_INT*> map;                     // mapping from atom types to elements
  int twojmax, diagonalstyle, switchflag, bzeroflag, quadraticflag;
  double rcutfac, rfac0, rmin0, wj1, wj2;
  int rcutfacflag, twojmaxflag; // flags for required parameters
  typedef Kokkos::View<T_F_FLOAT**> t_fparams;
  t_fparams cutsq;
  typedef Kokkos::View<const T_F_FLOAT**,
      Kokkos::MemoryTraits<Kokkos::RandomAccess>> t_fparams_rnd;
  t_fparams_rnd rnd_cutsq;


  t_x x;
  t_f_atomic f;
  t_type type;

public:

  KOKKOS_INLINE_FUNCTION
  void operator() (const Kokkos::TeamPolicy<>::member_type& team) const;

};

#define FORCE_MODULES_EXTERNAL_TEMPLATE
#define FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighType) ForceSNAP<NeighType>
#include<modules_neighbor.h>
#undef FORCETYPE_DECLARE_TEMPLATE_MACRO
#undef FORCE_MODULES_EXTERNAL_TEMPLATE

#endif
#endif


---

# force_snap_neigh_impl.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "force_snap_neigh.h"

#define MAXLINE 1024
#define MAXWORD 3

// Outstanding issues with quadratic term
// 1. there seems to a problem with compute_optimized energy calc
// it does not match compute_regular, even when quadratic coeffs = 0

//static double t1 = 0.0;
//static double t2 = 0.0;
//static double t3 = 0.0;
//static double t4 = 0.0;
//static double t5 = 0.0;
//static double t6 = 0.0;
//static double t7 = 0.0;
/* ---------------------------------------------------------------------- */

template<class NeighborClass>
ForceSNAP<NeighborClass>::ForceSNAP(char** args, System* system_, bool half_neigh_):Force(args,system_,half_neigh_)
{

  system = system_;
  nelements = 0;

  nmax = 0;

  vector_length = 8;
  concurrent_interactions =
#if defined(KOKKOS_ENABLE_CUDA)
      std::is_same<Kokkos::DefaultExecutionSpace,Kokkos::Cuda>::value ?
          Kokkos::DefaultExecutionSpace::concurrency()/vector_length :
#elif defined(KOKKOS_ENABLE_HIP)
      std::is_same<Kokkos::DefaultExecutionSpace,Kokkos::Experimental::HIP>::value ?
          Kokkos::DefaultExecutionSpace::concurrency()/vector_length :
#elif defined(KOKKOS_ENABLE_SYCL)
      std::is_same<Kokkos::DefaultExecutionSpace,Kokkos::Experimental::SYCL>::value ?
          Kokkos::DefaultExecutionSpace::concurrency()/vector_length :
#else
          Kokkos::DefaultExecutionSpace::concurrency();
#endif

  schedule_user = 0;
  schedule_time_guided = -1;
  schedule_time_dynamic = -1;
  ncalls_neigh =-1;

  ilistmask_max = 0;
  ghostinum = 0;
  ghostilist_max = 0;
  ghostnumneigh_max = 0;
  ghostneighs_total = 0;
  ghostneighs_max = 0;

  i_max = 0;
  i_neighmax = 0;
  i_numpairs = 0;

  use_shared_arrays = 0;

#ifdef TIMING_INFO
  timers[0] = 0;
  timers[1] = 0;
  timers[2] = 0;
  timers[3] = 0;
#endif

  // Need to set this because restart not handled by ForceHybrid

  cutsq = t_fparams("ForceSNAP::cutsq",system->ntypes,system->ntypes);
}

/* ---------------------------------------------------------------------- */

template<class NeighborClass>
ForceSNAP<NeighborClass>::~ForceSNAP()
{
  // Need to set this because restart not handled by ForceHybrid

  /*if (sna) {
    for (int tid = 0; tid<concurrent_interactions; tid++)
      delete sna[tid];
    delete [] sna;

  }*/
}

template<class NeighList>
struct FindMaxNumNeighs {
  NeighList neigh_list;

  FindMaxNumNeighs(NeighList& nl): neigh_list(nl) {}

  KOKKOS_INLINE_FUNCTION
  void operator() (const int& i, int& max_neighs) const {
    typename NeighList::t_neighs neighs_i = neigh_list.get_neighs(i);
    const int num_neighs = neighs_i.get_num_neighs();
    if(max_neighs<num_neighs) max_neighs = num_neighs;
  }
};
/* ----------------------------------------------------------------------
   This version is a straightforward implementation
   ---------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::compute(System* system, Binning* binning, Neighbor* neighbor_)
{

  if(comm_newton == false)
    Kokkos::abort("ForceSNAP requires 'newton on'");
  x = system->x;
  f = system->f;
  type = system->type;
  int nlocal = system->N_local;

  //class SNA* snaptr = sna[0];

  NeighborClass* neighbor = (NeighborClass*) neighbor_;
  neigh_list = neighbor->get_neigh_list();
  int max_neighs = 0;
  /*
  for (int i = 0; i < nlocal; i++) {
    typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);
    const int num_neighs = neighs_i.get_num_neighs();
    if(max_neighs<num_neighs) max_neighs = num_neighs;
  }*/
  Kokkos::parallel_reduce("ForceSNAP::find_max_neighs",nlocal, FindMaxNumNeighs<t_neigh_list>(neigh_list), Kokkos::Max<int>(max_neighs));

  sna.nmax = max_neighs;

  T_INT team_scratch_size = sna.size_team_scratch_arrays();
  T_INT thread_scratch_size = sna.size_thread_scratch_arrays();

  //printf("Sizes: %i %i\n",team_scratch_size/1024,thread_scratch_size/1024);
  int vector_length = 8;
  int team_size_max = Kokkos::TeamPolicy<>(nlocal,Kokkos::AUTO).team_size_max(*this,Kokkos::ParallelForTag());
#ifdef EMD_ENABLE_GPU
  int team_size = 20;//max_neighs;
  if(team_size*vector_length > team_size_max)
    team_size = team_size_max/vector_length;
#else
  int team_size = 1;
#endif
  Kokkos::TeamPolicy<> policy(nlocal,team_size,vector_length);

  Kokkos::parallel_for("ForceSNAP::compute",policy
      .set_scratch_size(1,Kokkos::PerThread(thread_scratch_size))
      .set_scratch_size(1,Kokkos::PerTeam(team_scratch_size))
    ,*this);
//static int step =0;
//step++;
//if(step%10==0)
//        printf(" %e %e %e %e %e (%e %e): %e\n",t1,t2,t3,t4,t5,t6,t7,t1+t2+t3+t4+t5);
}



/* ----------------------------------------------------------------------
   allocate all arrays
------------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::allocate()
{
  map = Kokkos::View<T_INT*>("ForceSNAP::map",nelements+1);
}


/* ----------------------------------------------------------------------
   set coeffs for one or more type pairs
------------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::init_coeff(int narg, char **arg)
{
  // read SNAP element names between 2 filenames
  // nelements = # of SNAP elements
  // elements = list of unique element names

  if (narg < 7) Kokkos::abort("SNAP 1: Incorrect args for pair coefficients");
  allocate();

  if (nelements) {
    for (int i = 0; i < nelements; i++)
      delete[] elements[i];
    delete[] elements;
    radelem = Kokkos::View<T_F_FLOAT*>();
    wjelem = Kokkos::View<T_F_FLOAT*>();
    coeffelem = Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight>();
  }

  nelements = narg - 5 - system->ntypes;
  if (nelements < 1) Kokkos::abort("SNAP 2: Incorrect args for pair coefficients");

  map = Kokkos::View<T_INT*>("ForceSNAP::map",nelements+1);

  char* type1 = arg[1];
  char* type2 = arg[2];
  char* coefffilename = arg[3];
  char** elemlist = &arg[4];
  char* paramfilename = arg[4+nelements];
  char** elemtypes = &arg[5+nelements];

  // insure I,J args are * *
  if (strcmp(type1,"*") != 0 || strcmp(type2,"*") != 0)
    Kokkos::abort("A Incorrect args for pair coefficients");

  elements = new char*[nelements];

  for (int i = 0; i < nelements; i++) {
    char* elemname = elemlist[i];
    int n = strlen(elemname) + 1;
    elements[i] = new char[n];
    strcpy(elements[i],elemname);
  }

  // read snapcoeff and snapparam files

  read_files(coefffilename,paramfilename);

  if (!quadraticflag)
    ncoeff = ncoeffall - 1;
  else {

    // ncoeffall should be (ncoeff+2)*(ncoeff+1)/2
    // so, ncoeff = floor(sqrt(2*ncoeffall))-1

    ncoeff = sqrt(2*ncoeffall)-1;
    ncoeffq = (ncoeff*(ncoeff+1))/2;
    int ntmp = 1+ncoeff+ncoeffq;
    if (ntmp != ncoeffall) {
      printf("ncoeffall = %d ntmp = %d ncoeff = %d \n",ncoeffall,ntmp,ncoeff);
      Kokkos::abort("Incorrect SNAP coeff file");
    }
  }

  // read args that map atom types to SNAP elements
  // map[i] = which element the Ith atom type is, -1 if not mapped
  // map[0] is not used

  auto h_map = Kokkos::create_mirror_view(map);
  for (int i = 1; i <= system->ntypes; i++) {
    char* elemname = elemtypes[i-1];
    int jelem;
    for (jelem = 0; jelem < nelements; jelem++)
      if (strcmp(elemname,elements[jelem]) == 0)
	break;

    if (jelem < nelements)
      h_map[i] = jelem;
    else if (strcmp(elemname,"NULL") == 0) h_map[i] = -1;
    else Kokkos::abort("Incorrect args for pair coefficients");
  }

  Kokkos::deep_copy(map,h_map);
  // allocate memory for per OpenMP thread data which
  // is wrapped into the sna class


  sna = SNA(rfac0,twojmax,
            diagonalstyle,use_shared_arrays,
		        rmin0,switchflag,bzeroflag);
    //if (!use_shared_arrays)
  sna.grow_rij(nmax);
  sna.init();

  //printf("ncoeff = %d snancoeff = %d \n",ncoeff,sna[0]->ncoeff);
  if (ncoeff != sna.ncoeff) {
    printf("ncoeff = %d snancoeff = %d \n",ncoeff,sna.ncoeff);
    Kokkos::abort("Incorrect SNAP parameter file");
  }

  // Calculate maximum cutoff for all elements
  auto h_radelem = Kokkos::create_mirror_view(radelem);
  Kokkos::deep_copy(h_radelem,radelem);
  rcutmax = 0.0;
  for (int ielem = 0; ielem < nelements; ielem++) {
    rcutmax = MAX(2.0*h_radelem[ielem]*rcutfac,rcutmax);
  }
  Kokkos::deep_copy(cutsq,rcutmax*rcutmax);
  rnd_cutsq = cutsq;
}

/* ---------------------------------------------------------------------- */

template<class NeighborClass>
void ForceSNAP<NeighborClass>::read_files(char *coefffilename, char *paramfilename)
{

  // open SNAP coefficient file on proc 0

  FILE *fpcoeff;
  //if (comm->me == 0) {
    fpcoeff = fopen(coefffilename,"r");
    if (fpcoeff == NULL) {
      char str[128];
      sprintf(str,"Cannot open SNAP coefficient file %s",coefffilename);
      //error->one(FLERR,str);
    }
  //}

  char line[MAXLINE],*ptr;
  int eof = 0;

  int n;
  int nwords = 0;
  while (nwords == 0) {
    //if (comm->me == 0) {
      ptr = fgets(line,MAXLINE,fpcoeff);
      if (ptr == NULL) {
        eof = 1;
        fclose(fpcoeff);
      } else n = strlen(line) + 1;
    // }
    //MPI_Bcast(&eof,1,MPI_INT,0,world);
    if (eof) break;
    //MPI_Bcast(&n,1,MPI_INT,0,world);
    //MPI_Bcast(line,n,MPI_CHAR,0,world);

    // strip comment, skip line if blank

    if ((ptr = strchr(line,'#'))) {*ptr = '\0';}
    else if(line[0]!=10) {nwords = 2;}
    //nwords = atom->count_words(line);
  }
  if (nwords != 2)
    Kokkos::abort("Incorrect format in SNAP coefficient file");

  // words = ptrs to all words in line
  // strip single and double quotes from words
  char* words[MAXWORD];
  int iword = 0;
  words[iword] = strtok(line,"' \t\n\r\f");
  iword = 1;
  words[iword] = strtok(NULL,"' \t\n\r\f");

  int nelemfile = atoi(words[0]);
  ncoeffall = atoi(words[1]);

  // Set up element lists

  radelem = Kokkos::View<T_F_FLOAT*>("pair:radelem",nelements);
  wjelem = Kokkos::View<T_F_FLOAT*>("pair:wjelem",nelements);
  coeffelem = Kokkos::View<T_F_FLOAT**, Kokkos::LayoutRight>("pair:coeffelem",nelements,ncoeffall);

  int *found = new int[nelements];
  for (int ielem = 0; ielem < nelements; ielem++)
    found[ielem] = 0;

  // Loop over elements in the SNAP coefficient file

  for (int ielemfile = 0; ielemfile < nelemfile; ielemfile++) {

    //if (comm->me == 0) {
      ptr = fgets(line,MAXLINE,fpcoeff);
      if (ptr == NULL) {
	eof = 1;
	fclose(fpcoeff);
      } else n = strlen(line) + 1;
    //}
    //MPI_Bcast(&eof,1,MPI_INT,0,world);
    if (eof)
      Kokkos::abort("Incorrect format in SNAP coefficient file");
    //MPI_Bcast(&n,1,MPI_INT,0,world);
    //MPI_Bcast(line,n,MPI_CHAR,0,world);

    //nwords = atom->count_words(line);
    //if (nwords != 3)
    //  Kokkos::abort("Incorrect format in SNAP coefficient file");

    iword = 0;
    words[iword] = strtok(line,"' \t\n\r\f");
    iword = 1;
    words[iword] = strtok(NULL,"' \t\n\r\f");
    iword = 2;
    words[iword] = strtok(NULL,"' \t\n\r\f");

    char* elemtmp = words[0];
    double radtmp = atof(words[1]);
    double wjtmp = atof(words[2]);

    // skip if element name isn't in element list

    int ielem;
    for (ielem = 0; ielem < nelements; ielem++)
      if (strcmp(elemtmp,elements[ielem]) == 0) break;
    if (ielem == nelements) {
      //if (comm->me == 0)
	for (int icoeff = 0; icoeff < ncoeffall; icoeff++)
	  ptr = fgets(line,MAXLINE,fpcoeff);
      continue;
    }

    // skip if element already appeared

    if (found[ielem]) {
    //  if (comm->me == 0)
	for (int icoeff = 0; icoeff < ncoeffall; icoeff++)
	  ptr = fgets(line,MAXLINE,fpcoeff);
      continue;
    }

    found[ielem] = 1;
    auto radelem_i = Kokkos::subview(radelem,ielem);
    Kokkos::deep_copy(radelem,radtmp);
    auto wjelem_i = Kokkos::subview(wjelem,ielem);
    Kokkos::deep_copy(wjelem,wjtmp);
//    radelem[ielem] = radtmp;
//    wjelem[ielem] = wjtmp;


    //if (comm->me == 0) {
      //if (logfile) fprintf(logfile,"SNAP Element = %s, Radius %g, Weight %g \n",
			//  elements[ielem], radelem[ielem], wjelem[ielem]);
    //}

    for (int icoeff = 0; icoeff < ncoeffall; icoeff++) {
      //if (comm->me == 0) {
	ptr = fgets(line,MAXLINE,fpcoeff);
	if (ptr == NULL) {
	  eof = 1;
	  fclose(fpcoeff);
	} else n = strlen(line) + 1;
      //}

      //MPI_Bcast(&eof,1,MPI_INT,0,world);
      if (eof)
	Kokkos::abort("Incorrect format in SNAP coefficient file");
      //MPI_Bcast(&n,1,MPI_INT,0,world);
      //MPI_Bcast(line,n,MPI_CHAR,0,world);

      //nwords = atom->count_words(line);
      //if (nwords != 1)
	//Kokkos::abort("Incorrect format in SNAP coefficient file");

      iword = 0;
      words[iword] = strtok(line,"' \t\n\r\f");

      //coeffelem(ielem,icoeff) = atof(words[0]);
      auto coeffelem_ii = Kokkos::subview(coeffelem,ielem,icoeff);
      Kokkos::deep_copy(coeffelem_ii,atof(words[0]));

    }
  }

  // set flags for required keywords

  rcutfacflag = 0;
  twojmaxflag = 0;

  // Set defaults for optional keywords

  rfac0 = 0.99363;
  rmin0 = 0.0;
  diagonalstyle = 3;
  switchflag = 1;
  bzeroflag = 1;
  quadraticflag = 0;

  // open SNAP parameter file on proc 0

  FILE *fpparam;
  //if (comm->me == 0) {
    fpparam = fopen(paramfilename,"r");
    if (fpparam == NULL) {
      char str[128];
      sprintf(str,"Cannot open SNAP parameter file %s",paramfilename);
      //error->one(FLERR,str);
    }
  //}

  eof = 0;
  while (1) {
    //if (comm->me == 0) {
      ptr = fgets(line,MAXLINE,fpparam);
      if (ptr == NULL) {
        eof = 1;
        fclose(fpparam);
      } else n = strlen(line) + 1;
    //}
    //MPI_Bcast(&eof,1,MPI_INT,0,world);
    if (eof) break;
    //MPI_Bcast(&n,1,MPI_INT,0,world);
    //MPI_Bcast(line,n,MPI_CHAR,0,world);

    // strip comment, skip line if blank

    if ((ptr = strchr(line,'#'))) {*ptr = '\0'; continue;}
    //nwords = atom->count_words(line);
    if(line[0]!=10) nwords = 2; else nwords = 0;
    if (nwords == 0) continue;

    if (nwords != 2)
      Kokkos::abort("Incorrect format in SNAP parameter file");

    // words = ptrs to all words in line
    // strip single and double quotes from words

    char* keywd = strtok(line,"' \t\n\r\f");
    char* keyval = strtok(NULL,"' \t\n\r\f");

    //if (comm->me == 0) {
      //if (screen)
      //if (logfile) fprintf(logfile,"SNAP keyword %s %s \n",keywd,keyval);
    //}

    if (strcmp(keywd,"rcutfac") == 0) {
      rcutfac = atof(keyval);
      rcutfacflag = 1;
    } else if (strcmp(keywd,"twojmax") == 0) {
      twojmax = atoi(keyval);
      twojmaxflag = 1;
    } else if (strcmp(keywd,"rfac0") == 0)
      rfac0 = atof(keyval);
    else if (strcmp(keywd,"rmin0") == 0)
      rmin0 = atof(keyval);
    else if (strcmp(keywd,"diagonalstyle") == 0)
      diagonalstyle = atoi(keyval);
    else if (strcmp(keywd,"switchflag") == 0)
      switchflag = atoi(keyval);
    else if (strcmp(keywd,"bzeroflag") == 0)
      bzeroflag = atoi(keyval);
    else if (strcmp(keywd,"quadraticflag") == 0)
      quadraticflag = atoi(keyval);
    else
      Kokkos::abort("Incorrect SNAP parameter file");
  }

  if (rcutfacflag == 0 || twojmaxflag == 0)
    Kokkos::abort("Incorrect SNAP parameter file");

  delete[] found;
}

template<class NeighborClass>
KOKKOS_INLINE_FUNCTION
void ForceSNAP<NeighborClass>::operator() (const Kokkos::TeamPolicy<>::member_type& team) const {
  const int i = team.league_rank();
  SNA my_sna(sna,team);
  const double x_i = x(i,0);
  const double y_i = x(i,1);
  const double z_i = x(i,2);
  const int type_i = type[i];
  const int elem_i = map[type_i];
  const double radi = radelem[elem_i];

  typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);

  const int num_neighs = neighs_i.get_num_neighs();

  // rij[][3] = displacements between atom I and those neighbors
  // inside = indices of neighbors of I within cutoff
  // wj = weights for neighbors of I within cutoff
  // rcutij = cutoffs for neighbors of I within cutoff
  // note Rij sign convention => dU/dRij = dU/dRj = -dU/dRi

  //Kokkos::Timer timer;
  int ninside = 0;
  Kokkos::parallel_reduce(Kokkos::TeamThreadRange(team,num_neighs),
      [&] (const int jj, int& count) {
    Kokkos::single(Kokkos::PerThread(team), [&] (){
      T_INT j = neighs_i(jj);
      const T_F_FLOAT dx = x(j,0) - x_i;
      const T_F_FLOAT dy = x(j,1) - y_i;
      const T_F_FLOAT dz = x(j,2) - z_i;

      const int type_j = type(j);
      const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
      const int elem_j = map[type_j];

      if( rsq < rnd_cutsq(type_i,type_j) )
       count++;
    });
  },ninside);

  //t1 += timer.seconds(); timer.reset();

  if(team.team_rank() == 0)
  Kokkos::parallel_scan(Kokkos::ThreadVectorRange(team,num_neighs),
      [&] (const int jj, int& offset, bool final){
  //for (int jj = 0; jj < num_neighs; jj++) {
    T_INT j = neighs_i(jj);
    const T_F_FLOAT dx = x(j,0) - x_i;
    const T_F_FLOAT dy = x(j,1) - y_i;
    const T_F_FLOAT dz = x(j,2) - z_i;

    const int type_j = type(j);
    const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;
    const int elem_j = map[type_j];

    if( rsq < rnd_cutsq(type_i,type_j) ) {
      if(final) {
        my_sna.rij(offset,0) = dx;
        my_sna.rij(offset,1) = dy;
        my_sna.rij(offset,2) = dz;
        my_sna.inside[offset] = j;
        my_sna.wj[offset] = wjelem[elem_j];
        my_sna.rcutij[offset] = (radi + radelem[elem_j])*rcutfac;
      }
      offset++;
    }
  });

  //t2 += timer.seconds(); timer.reset();

  team.team_barrier();
  // compute Ui, Zi, and Bi for atom I
  my_sna.compute_ui(team,ninside);
  //t3 += timer.seconds(); timer.reset();
  team.team_barrier();
  my_sna.compute_zi(team);
  //t4 += timer.seconds(); timer.reset();
  team.team_barrier();

  // for neighbors of I within cutoff:
  // compute dUi/drj and dBi/drj
  // Fij = dEi/dRj = -dEi/dRi => add to Fi, subtract from Fj

  Kokkos::View<double*,Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Unmanaged>>
    coeffi(coeffelem,elem_i,Kokkos::ALL);

  Kokkos::parallel_for(Kokkos::TeamThreadRange(team,ninside),
      [&] (const int jj) {
  //for (int jj = 0; jj < ninside; jj++) {
    int j = my_sna.inside[jj];
    //Kokkos::Timer timer2;
    my_sna.compute_duidrj(team,&my_sna.rij(jj,0),
                           my_sna.wj[jj],my_sna.rcutij[jj]);
    //t6 += timer2.seconds(); timer2.reset();
    my_sna.compute_dbidrj(team);
    //t7 += timer2.seconds(); timer2.reset();
    my_sna.copy_dbi2dbvec(team);


    Kokkos::single(Kokkos::PerThread(team), [&] (){
    T_F_FLOAT fij[3];

    fij[0] = 0.0;
    fij[1] = 0.0;
    fij[2] = 0.0;

    // linear contributions

    for (int k = 1; k <= ncoeff; k++) {
      double bgb = coeffi[k];
      fij[0] += bgb*my_sna.dbvec(k-1,0);
      fij[1] += bgb*my_sna.dbvec(k-1,1);
      fij[2] += bgb*my_sna.dbvec(k-1,2);
    }

    const double dx = my_sna.rij(jj,0);
    const double dy = my_sna.rij(jj,1);
    const double dz = my_sna.rij(jj,2);
    const double fdivr = -1.5e6/pow(dx*dx + dy*dy + dz*dz,7.0);
    fij[0] += dx*fdivr;
    fij[1] += dy*fdivr;
    fij[2] += dz*fdivr;

    //OK
    //printf("%lf %lf %lf %lf %lf %lf %lf %lf %lf SNAP-COMPARE: FIJ\n"
    //    ,x(i,0),x(i,1),x(i,2),x(j,0),x(j,1),x(j,2),fij[0],fij[1],fij[2] );
    f(i,0) += fij[0];
    f(i,1) += fij[1];
    f(i,2) += fij[2];
    f(j,0) -= fij[0];
    f(j,1) -= fij[1];
    f(j,2) -= fij[2];
    });
  });
  //t5 += timer.seconds(); timer.reset();
}


---

# sna.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

/* -*- c++ -*- -------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
   Contributing authors: Aidan Thompson, Christian Trott, SNL
------------------------------------------------------------------------- */

#ifndef LMP_SNA_H
#define LMP_SNA_H

#include <complex>
#include <ctime>
#include <Kokkos_Core.hpp>
#include <types.h>

struct SNA_LOOPINDICES {
  int j1, j2, j;
};

class SNA {

public:
  typedef Kokkos::View<int*> t_sna_1i;
  typedef Kokkos::View<double*> t_sna_1d;
  typedef Kokkos::View<double**, Kokkos::LayoutRight> t_sna_2d;
  typedef Kokkos::View<double***, Kokkos::LayoutRight> t_sna_3d;
  typedef Kokkos::View<double***, Kokkos::LayoutRight,Kokkos::MemoryTraits<Kokkos::Atomic> > t_sna_3d_atomic;
  typedef Kokkos::View<double***[3], Kokkos::LayoutRight> t_sna_4d;
  typedef Kokkos::View<double**[3], Kokkos::LayoutRight> t_sna_3d3;
  typedef Kokkos::View<double*****, Kokkos::LayoutRight> t_sna_5d;
  inline
  SNA() {};
  KOKKOS_INLINE_FUNCTION
  SNA(const SNA& sna, const Kokkos::TeamPolicy<>::member_type& team);
  inline
  SNA(double, int, int, int, double, int, int);

  KOKKOS_INLINE_FUNCTION
  ~SNA();
  inline
  void build_indexlist(); // SNA()
  inline
  void init();            //
  inline
  T_INT size_team_scratch_arrays();
  inline
  T_INT size_thread_scratch_arrays();

  int ncoeff;

  // functions for bispectrum coefficients

  KOKKOS_INLINE_FUNCTION
  void compute_ui(const Kokkos::TeamPolicy<>::member_type& team, int); // ForceSNAP
  KOKKOS_INLINE_FUNCTION
  void compute_zi(const Kokkos::TeamPolicy<>::member_type& team);    // ForceSNAP

  // functions for derivatives

  KOKKOS_INLINE_FUNCTION
  void compute_duidrj(const Kokkos::TeamPolicy<>::member_type& team, double*, double, double); //ForceSNAP
  KOKKOS_INLINE_FUNCTION
  void compute_dbidrj(const Kokkos::TeamPolicy<>::member_type& team); //ForceSNAP
  KOKKOS_INLINE_FUNCTION
  void copy_dbi2dbvec(const Kokkos::TeamPolicy<>::member_type& team); //ForceSNAP
  KOKKOS_INLINE_FUNCTION
  double compute_sfac(double, double); // add_uarraytot, compute_duarray
  KOKKOS_INLINE_FUNCTION
  double compute_dsfac(double, double); // compute_duarray

#ifdef TIMING_INFO
  double* timers;
  timespec starttime, endtime;
  int print;
  int counter;
#endif

  //per sna class instance for OMP use


  // Per InFlight Particle
  t_sna_2d rij;
  t_sna_1i inside;
  t_sna_1d wj;
  t_sna_1d rcutij;
  int nmax;

  void grow_rij(int);

  int twojmax, diagonalstyle;
  // Per InFlight Particle
  t_sna_3d uarraytot_r, uarraytot_i;
  t_sna_3d_atomic uarraytot_r_a, uarraytot_i_a;
  t_sna_5d zarray_r, zarray_i;

  // Per InFlight Interaction
  t_sna_3d uarray_r, uarray_i;

  // derivatives of data
  Kokkos::View<double*[3], Kokkos::LayoutRight> dbvec;
  t_sna_4d duarray_r, duarray_i;
  t_sna_4d dbarray;

private:
  double rmin0, rfac0;

  //use indexlist instead of loops, constructor generates these
  // Same accross all SNA
  Kokkos::View<SNA_LOOPINDICES*> idxj,idxj_full;
  int idxj_max,idxj_full_max;
  // data for bispectrum coefficients

  // Same accross all SNA
  t_sna_5d cgarray;
  t_sna_2d rootpqarray;


  static const int nmaxfactorial = 167;
  KOKKOS_INLINE_FUNCTION
  double factorial(int);

  KOKKOS_INLINE_FUNCTION
  void create_team_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team); // SNA()
  KOKKOS_INLINE_FUNCTION
  void create_thread_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team); // SNA()
  inline
  void init_clebsch_gordan(); // init()
  inline
  void init_rootpqarray();    // init()
  KOKKOS_INLINE_FUNCTION
  void zero_uarraytot(const Kokkos::TeamPolicy<>::member_type& team);      // compute_ui
  KOKKOS_INLINE_FUNCTION
  void addself_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double); // compute_ui
  KOKKOS_INLINE_FUNCTION
  void add_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double, double, double); // compute_ui

  KOKKOS_INLINE_FUNCTION
  void compute_uarray(const Kokkos::TeamPolicy<>::member_type& team,
                      double, double, double,
                      double, double); // compute_ui
  KOKKOS_INLINE_FUNCTION
  double deltacg(int, int, int);  // init_clebsch_gordan
  inline
  int compute_ncoeff();           // SNA()
  KOKKOS_INLINE_FUNCTION
  void compute_duarray(const Kokkos::TeamPolicy<>::member_type& team,
                       double, double, double, // compute_duidrj
                       double, double, double, double, double);

  // if number of atoms are small use per atom arrays
  // for twojmax arrays, rij, inside, bvec
  // this will increase the memory footprint considerably,
  // but allows parallel filling and reuse of these arrays
  int use_shared_arrays;

  // Sets the style for the switching function
  // 0 = none
  // 1 = cosine
  int switch_flag;

  // Self-weight
  double wself;
};

#include<sna_impl.hpp>
#endif

/* ERROR/WARNING messages:

E: Invalid argument to factorial %d

N must be >= 0 and <= 167, otherwise the factorial result is too
large.

*/


---

# sna_impl.hpp

/* ----------------------------------------------------------------------
   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
   http://lammps.sandia.gov, Sandia National Laboratories
   Steve Plimpton, sjplimp@sandia.gov

   Copyright (2003) Sandia Corporation.  Under the terms of Contract
   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
   certain rights in this software.  This software is distributed under
   the GNU General Public License.

   See the README file in the top-level LAMMPS directory.
------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
   Contributing authors: Aidan Thompson, Christian Trott, SNL
------------------------------------------------------------------------- */

#include "sna.h"
#include <math.h>
#include <string.h>
#include <stdlib.h>

static const double MY_PI  = 3.14159265358979323846; // pi

inline
SNA::SNA(double rfac0_in,
         int twojmax_in, int diagonalstyle_in, int use_shared_arrays_in,
         double rmin0_in, int switch_flag_in, int bzero_flag_in) 
{
  wself = 1.0;
  
  use_shared_arrays = use_shared_arrays_in;
  rfac0 = rfac0_in;
  rmin0 = rmin0_in;
  switch_flag = switch_flag_in;

  twojmax = twojmax_in;
  diagonalstyle = diagonalstyle_in;

  ncoeff = compute_ncoeff();

  //create_twojmax_arrays();

  nmax = 0;
  
  build_indexlist();

  int jdim = twojmax + 1;

  cgarray = t_sna_5d("SNA::cgarray",jdim,jdim,jdim,jdim,jdim);
  rootpqarray = t_sna_2d("SNA::rootpqarray",jdim+1,jdim+1);

}

KOKKOS_INLINE_FUNCTION
SNA::SNA(const SNA& sna, const Kokkos::TeamPolicy<>::member_type& team) {
  wself = sna.wself;

  use_shared_arrays = sna.use_shared_arrays;
  rfac0 = sna.rfac0;
  rmin0 = sna.rmin0;
  switch_flag = sna.switch_flag;

  twojmax = sna.twojmax;
  diagonalstyle = sna.diagonalstyle;

  ncoeff = sna.ncoeff;
  nmax = sna.nmax;
  idxj = sna.idxj;
  idxj_max = sna.idxj_max;
  idxj_full = sna.idxj_full;
  idxj_full_max = sna.idxj_full_max;
  cgarray = sna.cgarray;
  rootpqarray = sna.rootpqarray;
  create_team_scratch_arrays(team);
  create_thread_scratch_arrays(team);
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
SNA::~SNA()
{
}

inline
void SNA::build_indexlist()
{
  if(diagonalstyle == 3) {
    int idxj_count = 0;
    int idxj_full_count = 0;

    for(int j1 = 0; j1 <= twojmax; j1++)
      for(int j2 = 0; j2 <= j1; j2++)
        for(int j = abs(j1 - j2); j <= MIN(twojmax, j1 + j2); j += 2) {
          if (j >= j1) idxj_count++;
          idxj_full_count++;
        }

    // indexList can be changed here

    idxj = Kokkos::View<SNA_LOOPINDICES*>("SNA::idxj",idxj_count);
    idxj_full = Kokkos::View<SNA_LOOPINDICES*>("SNA::idxj_full",idxj_full_count);
    auto h_idxj = Kokkos::create_mirror_view(idxj);
    auto h_idxj_full = Kokkos::create_mirror_view(idxj_full);

    idxj_max = idxj_count;
    idxj_full_max = idxj_full_count;

    idxj_count = 0;
    idxj_full_count = 0;

    for(int j1 = 0; j1 <= twojmax; j1++)
      for(int j2 = 0; j2 <= j1; j2++)
        for(int j = abs(j1 - j2); j <= MIN(twojmax, j1 + j2); j += 2) {
          if (j >= j1) {
            h_idxj[idxj_count].j1 = j1;
            h_idxj[idxj_count].j2 = j2;
            h_idxj[idxj_count].j = j;
            idxj_count++;
          }
          h_idxj_full[idxj_full_count].j1 = j1;
          h_idxj_full[idxj_full_count].j2 = j2;
          h_idxj_full[idxj_full_count].j = j;
          idxj_full_count++;
        }
    Kokkos::deep_copy(idxj,h_idxj);
    Kokkos::deep_copy(idxj_full,h_idxj_full);

  }

}
/* ---------------------------------------------------------------------- */

inline
void SNA::init()
{
  init_clebsch_gordan();
  init_rootpqarray();
}

inline
void SNA::grow_rij(int newnmax)
{
  if(newnmax <= nmax) return;
  nmax = newnmax;
}
/* ----------------------------------------------------------------------
   compute Ui by summing over neighbors j
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_ui(const Kokkos::TeamPolicy<>::member_type& team, int jnum)
{
  double rsq, r, x, y, z, z0, theta0;

  // utot(j,ma,mb) = 0 for all j,ma,ma
  // utot(j,ma,ma) = 1 for all j,ma
  // for j in neighbors of i:
  //   compute r0 = (x,y,z,z0)
  //   utot(j,ma,mb) += u(r0;j,ma,mb) for all j,ma,mb

  if(team.team_rank() == 0) {
    zero_uarraytot(team);
    //Kokkos::single(Kokkos::PerThread(team), [&] (){
    addself_uarraytot(team,wself);
    //});
  }
  team.team_barrier();

  Kokkos::parallel_for(Kokkos::TeamThreadRange(team,jnum),
      [&] (const int& j) {
  //for(int j = 0; j < jnum; j++) {
    x = rij(j,0);
    y = rij(j,1);
    z = rij(j,2);
    rsq = x * x + y * y + z * z;
    r = sqrt(rsq);

    theta0 = (r - rmin0) * rfac0 * MY_PI / (rcutij[j] - rmin0);
    //    theta0 = (r - rmin0) * rscale0;
    z0 = r / tan(theta0);

    compute_uarray(team,x, y, z, z0, r);
    //Kokkos::single(Kokkos::PerThread(team), [&] (){
    add_uarraytot(team,r, wj[j], rcutij[j]);
    //});
  });

}

/* ----------------------------------------------------------------------
   compute Zi by summing over products of Ui
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_zi(const Kokkos::TeamPolicy<>::member_type& team)
{
  // for j1 = 0,...,twojmax
  //   for j2 = 0,twojmax
  //     for j = |j1-j2|,Min(twojmax,j1+j2),2
  //        for ma = 0,...,j
  //          for mb = 0,...,jmid
  //            z(j1,j2,j,ma,mb) = 0
  //            for ma1 = Max(0,ma+(j1-j2-j)/2),Min(j1,ma+(j1+j2-j)/2)
  //              sumb1 = 0
  //              ma2 = ma-ma1+(j1+j2-j)/2;
  //              for mb1 = Max(0,mb+(j1-j2-j)/2),Min(j1,mb+(j1+j2-j)/2)
  //                mb2 = mb-mb1+(j1+j2-j)/2;
  //                sumb1 += cg(j1,mb1,j2,mb2,j) *
  //                  u(j1,ma1,mb1) * u(j2,ma2,mb2)
  //              z(j1,j2,j,ma,mb) += sumb1*cg(j1,ma1,j2,ma2,j)

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &starttime);
#endif

  // compute_dbidrj() requires full j1/j2/j chunk of z elements
  // use zarray j1/j2 symmetry

  Kokkos::parallel_for(Kokkos::TeamThreadRange(team,idxj_full_max),
      [&] (const int& idx) {
    const int j1 = idxj_full(idx).j1;
    const int j2 = idxj_full(idx).j2;
    const int j =  idxj_full(idx).j;

    const int bound = (j+2)/2;
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+1)*bound),
        [&] (const int mbma ) {
	//for(int mb = 0; 2*mb <= j; mb++)
	  //for(int ma = 0; ma <= j; ma++) {
      const int ma = mbma%(j+1);
      const int mb = mbma/(j+1);
	    //zarray_r(j1,j2,j,ma,mb) = 0.0;
	    //zarray_i(j1,j2,j,ma,mb) = 0.0;
      double z_r = 0.0;
      double z_i = 0.0;

	    for(int ma1 = MAX(0, (2 * ma - j - j2 + j1) / 2);
		ma1 <= MIN(j1, (2 * ma - j + j2 + j1) / 2); ma1++) {
	      double sumb1_r = 0.0;
	      double sumb1_i = 0.0;

	      const int ma2 = (2 * ma - j - (2 * ma1 - j1) + j2) / 2;

	      for(int mb1  = MAX( 0, (2 * mb - j - j2 + j1) / 2);
                mb1 <= MIN(j1, (2 * mb - j + j2 + j1) / 2); mb1++) {

		const int mb2 = (2 * mb - j - (2 * mb1 - j1) + j2) / 2;
    const double cga = cgarray(j1,j2,j,mb1,mb2);
    const double uat1_r = uarraytot_r(j1,ma1,mb1);
    const double uat1_i = uarraytot_i(j1,ma1,mb1);
    const double uat2_r = uarraytot_r(j2,ma2,mb2);
    const double uat2_i = uarraytot_i(j2,ma2,mb2);
    sumb1_r += cga * (uat1_r * uat2_r - uat1_i * uat2_i);
    sumb1_i += cga * (uat1_r * uat2_i + uat1_i * uat2_r);
		/*sumb1_r += cgarray(j1,j2,j,mb1,mb2) *
		  (uarraytot_r(j1,ma1,mb1) * uarraytot_r(j2,ma2,mb2) -
		   uarraytot_i(j1,ma1,mb1) * uarraytot_i(j2,ma2,mb2));
		sumb1_i += cgarray(j1,j2,j,mb1,mb2) *
		  (uarraytot_r(j1,ma1,mb1) * uarraytot_i(j2,ma2,mb2) +
		   uarraytot_i(j1,ma1,mb1) * uarraytot_r(j2,ma2,mb2));*/
	      } // end loop over mb1

        const double cga = cgarray(j1,j2,j,ma1,ma2);
	      z_r += sumb1_r * cga;//rray(j1,j2,j,ma1,ma2);
	      z_i += sumb1_i * cga;//rray(j1,j2,j,ma1,ma2);
	    } // end loop over ma1
      zarray_r(j1,j2,j,mb,ma) = z_r;
	    zarray_i(j1,j2,j,mb,ma) = z_i;
	  }); // end loop over ma, mb
    //  }
    //}
  });
      //} // end loop over j
    //} // end loop over j1, j2

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &endtime);
  timers[1] += (endtime.tv_sec - starttime.tv_sec + 1.0 *
                (endtime.tv_nsec - starttime.tv_nsec) / 1000000000);
#endif
}


/* ----------------------------------------------------------------------
   calculate derivative of Ui w.r.t. atom j
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_duidrj(const Kokkos::TeamPolicy<>::member_type& team,
                         double* rij, double wj, double rcut)
{
  double rsq, r, x, y, z, z0, theta0, cs, sn;
  double dz0dr;

  x = rij[0];
  y = rij[1];
  z = rij[2];
  rsq = x * x + y * y + z * z;
  r = sqrt(rsq);
  double rscale0 = rfac0 * MY_PI / (rcut - rmin0);
  theta0 = (r - rmin0) * rscale0;
  cs = cos(theta0);
  sn = sin(theta0);
  z0 = r * cs / sn;
  dz0dr = z0 / r - (r*rscale0) * (rsq + z0 * z0) / rsq;

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &starttime);
#endif

  compute_duarray(team, x, y, z, z0, r, dz0dr, wj, rcut);

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &endtime);
  timers[3] += (endtime.tv_sec - starttime.tv_sec + 1.0 *
                (endtime.tv_nsec - starttime.tv_nsec) / 1000000000);
#endif

}

/* ----------------------------------------------------------------------
   calculate derivative of Bi w.r.t. atom j
   variant using indexlist for j1,j2,j
   variant using symmetry relation
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_dbidrj(const Kokkos::TeamPolicy<>::member_type& team)
{
  // for j1 = 0,...,twojmax
  //   for j2 = 0,twojmax
  //     for j = |j1-j2|,Min(twojmax,j1+j2),2
  //        zdb = 0
  //        for mb = 0,...,jmid
  //          for ma = 0,...,j
  //            zdb +=
  //              Conj(dudr(j,ma,mb))*z(j1,j2,j,ma,mb)
  //        dbdr(j1,j2,j) += 2*zdb
  //        zdb = 0
  //        for mb1 = 0,...,j1mid
  //          for ma1 = 0,...,j1
  //            zdb +=
  //              Conj(dudr(j1,ma1,mb1))*z(j,j2,j1,ma1,mb1)
  //        dbdr(j1,j2,j) += 2*zdb*(j+1)/(j1+1)
  //        zdb = 0
  //        for mb2 = 0,...,j2mid
  //          for ma2 = 0,...,j2
  //            zdb +=
  //              Conj(dudr(j2,ma2,mb2))*z(j1,j,j2,ma2,mb2)
  //        dbdr(j1,j2,j) += 2*zdb*(j+1)/(j2+1)

  double* dudr_r, *dudr_i;
  double jjjmambzarray_r;
  double jjjmambzarray_i;

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &starttime);
#endif
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,idxj_max),
          [&] (const int& JJ) {
  //for(int JJ = 0; JJ < idxj_max; JJ++) {
    const int j1 = idxj[JJ].j1;
    const int j2 = idxj[JJ].j2;
    const int j = idxj[JJ].j;

//    dbdr = &dbarray(j1,j2,j,0);
//    dbdr[0] = 0.0;
//    dbdr[1] = 0.0;
//    dbdr[2] = 0.0;

    t_scalar3<double> dbdr,sumzdu_r;
    // Sum terms Conj(dudr(j,ma,mb))*z(j1,j2,j,ma,mb)

    // use zarray j1/j2 symmetry (optional)

    int j_,j1_,j2_;
    if (j1 >= j2) {
      //jjjzarray_r = &zarray_r(j1,j2,j);
      //jjjzarray_i = &zarray_i(j1,j2,j);
      j1_ = j1;
      j2_ = j2;
      j_ = j;
    } else {
      j1_ = j2;
      j2_ = j1;
      j_ = j;
      //jjjzarray_r = &zarray_r(j2,j1,j);
      //jjjzarray_i = &zarray_i(j2,j1,j);
    }

    for(int mb = 0; 2*mb < j; mb++)
      for(int ma = 0; ma <= j; ma++) {

        dudr_r = &duarray_r(j,mb,ma,0);
        dudr_i = &duarray_i(j,mb,ma,0);
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb,ma);
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb,ma);
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);

      } //end loop over ma mb

    // For j even, handle middle column

    if (j%2 == 0) {
      int mb = j/2;
      for(int ma = 0; ma <= mb; ma++) {
        dudr_r = &duarray_r(j,mb,ma,0);
        dudr_i = &duarray_i(j,mb,ma,0);
        const double factor = ma==mb?0.5:1.0;
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb,ma) * factor;
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb,ma) * factor;
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      }
    } // end if jeven

      dbdr += 2.0*sumzdu_r;

    // Sum over Conj(dudr(j1,ma1,mb1))*z(j,j2,j1,ma1,mb1)

    double j1fac = (j+1)/(j1+1.0);

    sumzdu_r.x = 0.0; sumzdu_r.y = 0.0; sumzdu_r.z = 0.0;

    // use zarray j1/j2 symmetry (optional)

    if (j >= j2) {
      j1_ = j;
      j2_ = j2;
      j_ = j1;

      //jjjzarray_r = zarray_r(j,j2,j1);
      //jjjzarray_i = zarray_i(j,j2,j1);
    } else {
      j1_ = j2;
      j2_ = j;
      j_ = j1;
      //jjjzarray_r = zarray_r(j2,j,j1);
      //jjjzarray_i = zarray_i(j2,j,j1);
    }

    for(int mb1 = 0; 2*mb1 < j1; mb1++)
      for(int ma1 = 0; ma1 <= j1; ma1++) {

        dudr_r = &duarray_r(j1,mb1,ma1,0);
        dudr_i = &duarray_i(j1,mb1,ma1,0);
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb1,ma1);
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb1,ma1);
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      } //end loop over ma1 mb1

    // For j1 even, handle middle column

    if (j1%2 == 0) {
      const int mb1 = j1/2;
      for(int ma1 = 0; ma1 <= mb1; ma1++) {
        dudr_r = &duarray_r(j1,mb1,ma1,0);
        dudr_i = &duarray_i(j1,mb1,ma1,0);
        const double factor = ma1==mb1?0.5:1.0;
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb1,ma1) * factor;
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb1,ma1) * factor;
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      }
    } // end if j1even

      dbdr += 2.0*sumzdu_r*j1fac;

    // Sum over Conj(dudr(j2,ma2,mb2))*z(j1,j,j2,ma2,mb2)

    double j2fac = (j+1)/(j2+1.0);

    sumzdu_r.x = 0.0; sumzdu_r.y = 0.0; sumzdu_r.z = 0.0;

    // use zarray j1/j2 symmetry (optional)

    if (j1 >= j) {
      j1_ = j1;
      j2_ = j;
      j_ = j2;
      //jjjzarray_r = zarray_r(j1,j,j2);
      //jjjzarray_i = zarray_i(j1,j,j2);
    } else {
      j1_ = j;
      j2_ = j1;
      j_ = j2;
      //jjjzarray_r = zarray_r(j,j1,j2);
      //jjjzarray_i = zarray_i(j,j1,j2);
    }

    for(int mb2 = 0; 2*mb2 < j2; mb2++)
      for(int ma2 = 0; ma2 <= j2; ma2++) {

        dudr_r = &duarray_r(j2,mb2,ma2,0);
        dudr_i = &duarray_i(j2,mb2,ma2,0);
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb2,ma2);
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb2,ma2);
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      } //end loop over ma2 mb2

    // For j2 even, handle middle column

    if (j2%2 == 0) {
      const int mb2 = j2/2;
      for(int ma2 = 0; ma2 <= mb2; ma2++) {
        dudr_r = &duarray_r(j2,mb2,ma2,0);
        dudr_i = &duarray_i(j2,mb2,ma2,0);
        const double factor = ma2==mb2?0.5:1.0;
        jjjmambzarray_r = zarray_r(j1_,j2_,j_,mb2,ma2) * factor;
        jjjmambzarray_i = zarray_i(j1_,j2_,j_,mb2,ma2) * factor;
        sumzdu_r.x += (dudr_r[0] * jjjmambzarray_r + dudr_i[0] * jjjmambzarray_i);
        sumzdu_r.y += (dudr_r[1] * jjjmambzarray_r + dudr_i[1] * jjjmambzarray_i);
        sumzdu_r.z += (dudr_r[2] * jjjmambzarray_r + dudr_i[2] * jjjmambzarray_i);
      }
    } // end if j2even

    dbdr += 2.0*sumzdu_r*j2fac;
    dbarray(j1,j2,j,0) = dbdr.x;
    dbarray(j1,j2,j,1) = dbdr.y;
    dbarray(j1,j2,j,2) = dbdr.z;
  }); //end loop over j1 j2 j

#ifdef TIMING_INFO
  clock_gettime(CLOCK_REALTIME, &endtime);
  timers[4] += (endtime.tv_sec - starttime.tv_sec + 1.0 *
                (endtime.tv_nsec - starttime.tv_nsec) / 1000000000);
#endif

}

/* ----------------------------------------------------------------------
   copy Bi derivatives into a vector
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::copy_dbi2dbvec(const Kokkos::TeamPolicy<>::member_type& team)
{
 /* int ncount, j1, j2, j;

  ncount = 0;

  for(j1 = 0; j1 <= twojmax; j1++) {
      for(j2 = 0; j2 <= j1; j2++)
        for(j = abs(j1 - j2);
            j <= MIN(twojmax, j1 + j2); j += 2)
	  if (j >= j1) {*/
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,idxj_max),
          [&] (const int& JJ) {
  //for(int JJ = 0; JJ < idxj_max; JJ++) {
    const int j1 = idxj[JJ].j1;
    const int j2 = idxj[JJ].j2;
    const int j = idxj[JJ].j;

	    dbvec(JJ,0) = dbarray(j1,j2,j,0);
	    dbvec(JJ,1) = dbarray(j1,j2,j,1);
	    dbvec(JJ,2) = dbarray(j1,j2,j,2);
	    //ncount++;
	  //});
  });
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::zero_uarraytot(const Kokkos::TeamPolicy<>::member_type& team)
{
  {
    double* const ptr = uarraytot_r.data();
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,uarraytot_r.span()),
        [&] (const int& i) {
      ptr[i] = 0.0;
    });
  }
  {
    double* const ptr = uarraytot_i.data();
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,uarraytot_r.span()),
        [&] (const int& i) {
      ptr[i] = 0.0;
    });
  }
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::addself_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double wself_in)
{
  //for (int j = 0; j <= twojmax; j++)
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,twojmax+1),
    [&] (const int& j) {
    for (int ma = 0; ma <= j; ma++) {
      uarraytot_r(j,ma,ma) = wself_in;
      uarraytot_i(j,ma,ma) = 0.0;
    }
  });
}

/* ----------------------------------------------------------------------
   add Wigner U-functions for one neighbor to the total
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::add_uarraytot(const Kokkos::TeamPolicy<>::member_type& team, double r, double wj, double rcut)
{
  const double sfac = compute_sfac(r, rcut) * wj;

/*
  for (int j = 0; j <= twojmax; j++)
    for (int ma = 0; ma <= j; ma++)
      for (int mb = 0; mb <= j; mb++) {
        uarraytot_r_a(j,ma,mb) +=
          sfac * uarray_r(j,ma,mb);
        uarraytot_i_a(j,ma,mb) +=
          sfac * uarray_i(j,ma,mb);
      }*/
  const double* const ptr_r = uarray_r.data();
  const double* const ptr_i = uarray_i.data();
  double* const ptrtot_r = uarraytot_r.data();
  double* const ptrtot_i = uarraytot_i.data();
  Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,uarraytot_r.span()),
      [&] (const int& i) {
    Kokkos::atomic_add(ptrtot_r+i, sfac * ptr_r[i]);
    Kokkos::atomic_add(ptrtot_i+i, sfac * ptr_i[i]);
  });
}

/* ----------------------------------------------------------------------
   compute Wigner U-functions for one neighbor
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_uarray(const Kokkos::TeamPolicy<>::member_type& team,
                         double x, double y, double z,
                         double z0, double r)
{
  double r0inv;
  double a_r, b_r, a_i, b_i;
  double rootpq;

  // compute Cayley-Klein parameters for unit quaternion

  r0inv = 1.0 / sqrt(r * r + z0 * z0);
  a_r = r0inv * z0;
  a_i = -r0inv * z;
  b_r = r0inv * y;
  b_i = -r0inv * x;

  // VMK Section 4.8.2

  uarray_r(0,0,0) = 1.0;
  uarray_i(0,0,0) = 0.0;

  for (int j = 1; j <= twojmax; j++) {

    // fill in left side of matrix layer from previous layer

    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {
      //const int mb = 2*mb_2;
    //for (int mb = 0; 2*mb <= j; mb++) {
      uarray_r(j,0,mb) = 0.0;
      uarray_i(j,0,mb) = 0.0;

      for (int ma = 0; ma < j; ma++) {
	rootpq = rootpqarray(j - ma,j - mb);
        uarray_r(j,ma,mb) +=
          rootpq *
          (a_r * uarray_r(j - 1,ma,mb) +
	   a_i * uarray_i(j - 1,ma,mb));
        uarray_i(j,ma,mb) +=
          rootpq *
          (a_r * uarray_i(j - 1,ma,mb) -
	   a_i * uarray_r(j - 1,ma,mb));

	rootpq = rootpqarray(ma + 1,j - mb);
        uarray_r(j,ma + 1,mb) =
          -rootpq *
          (b_r * uarray_r(j - 1,ma,mb) +
	   b_i * uarray_i(j - 1,ma,mb));
        uarray_i(j,ma + 1,mb) =
          -rootpq *
          (b_r * uarray_i(j - 1,ma,mb) -
	   b_i * uarray_r(j - 1,ma,mb));
      }
    });

    // copy left side to right side with inversion symmetry VMK 4.4(2)
    // u[ma-j,mb-j] = (-1)^(ma-mb)*Conj([u[ma,mb))

    //int mbpar = -1;
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {
//    for (int mb = 0; 2*mb <= j; mb++) {
      int mbpar = (mb)%2==0?1:-1;
      int mapar = -mbpar;
      for (int ma = 0; ma <= j; ma++) {
    	mapar = -mapar;
    	if (mapar == 1) {
    	  uarray_r(j,j-ma,j-mb) = uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = -uarray_i(j,ma,mb);
    	} else {
    	  uarray_r(j,j-ma,j-mb) = -uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = uarray_i(j,ma,mb);
    	}
    	//OK
    	//printf("%lf %lf %lf %lf %lf %lf %lf SNAP-COMPARE: UARRAY\n",x,y,z,z0,r,uarray_r(j,ma,mb),uarray_i(j,ma,mb));
      }
    });
  }
}


/* ----------------------------------------------------------------------
   compute derivatives of Wigner U-functions for one neighbor
   see comments in compute_uarray()
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::compute_duarray(const Kokkos::TeamPolicy<>::member_type& team,
                          double x, double y, double z,
                          double z0, double r, double dz0dr,
			  double wj, double rcut)
{
  double r0inv;
  double a_r, a_i, b_r, b_i;
  double da_r[3], da_i[3], db_r[3], db_i[3];
  double dz0[3], dr0inv[3], dr0invdr;
  double rootpq;

  double rinv = 1.0 / r;
  double ux = x * rinv;
  double uy = y * rinv;
  double uz = z * rinv;

  r0inv = 1.0 / sqrt(r * r + z0 * z0);
  a_r = z0 * r0inv;
  a_i = -z * r0inv;
  b_r = y * r0inv;
  b_i = -x * r0inv;

  dr0invdr = -pow(r0inv, 3.0) * (r + z0 * dz0dr);

  dr0inv[0] = dr0invdr * ux;
  dr0inv[1] = dr0invdr * uy;
  dr0inv[2] = dr0invdr * uz;

  dz0[0] = dz0dr * ux;
  dz0[1] = dz0dr * uy;
  dz0[2] = dz0dr * uz;

  for (int k = 0; k < 3; k++) {
    da_r[k] = dz0[k] * r0inv + z0 * dr0inv[k];
    da_i[k] = -z * dr0inv[k];
  }

  da_i[2] += -r0inv;

  for (int k = 0; k < 3; k++) {
    db_r[k] = y * dr0inv[k];
    db_i[k] = -x * dr0inv[k];
  }

  db_i[0] += -r0inv;
  db_r[1] += r0inv;

  uarray_r(0,0,0) = 1.0;
  duarray_r(0,0,0,0) = 0.0;
  duarray_r(0,0,0,1) = 0.0;
  duarray_r(0,0,0,2) = 0.0;
  uarray_i(0,0,0) = 0.0;
  duarray_i(0,0,0,0) = 0.0;
  duarray_i(0,0,0,1) = 0.0;
  duarray_i(0,0,0,2) = 0.0;

  for (int j = 1; j <= twojmax; j++) {
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {

    //for (int mb = 0; 2*mb <= j; mb++) {
      uarray_r(j,0,mb) = 0.0;
      duarray_r(j,mb,0,0) = 0.0;
      duarray_r(j,mb,0,1) = 0.0;
      duarray_r(j,mb,0,2) = 0.0;
      uarray_i(j,0,mb) = 0.0;
      duarray_i(j,mb,0,0) = 0.0;
      duarray_i(j,mb,0,1) = 0.0;
      duarray_i(j,mb,0,2) = 0.0;

      for (int ma = 0; ma < j; ma++) {
        rootpq = rootpqarray(j - ma,j - mb);
        uarray_r(j,ma,mb) += rootpq *
                               (a_r *  uarray_r(j - 1,ma,mb) +
                                a_i *  uarray_i(j - 1,ma,mb));
        uarray_i(j,ma,mb) += rootpq *
                               (a_r *  uarray_i(j - 1,ma,mb) -
                                a_i *  uarray_r(j - 1,ma,mb));

        for (int k = 0; k < 3; k++) {
          duarray_r(j,mb,ma,k) +=
            rootpq * (da_r[k] * uarray_r(j - 1,ma,mb) +
                      da_i[k] * uarray_i(j - 1,ma,mb) +
                      a_r * duarray_r(j - 1,mb,ma,k) +
                      a_i * duarray_i(j - 1,mb,ma,k));
          duarray_i(j,mb,ma,k) +=
            rootpq * (da_r[k] * uarray_i(j - 1,ma,mb) -
                      da_i[k] * uarray_r(j - 1,ma,mb) +
                      a_r * duarray_i(j - 1,mb,ma,k) -
                      a_i * duarray_r(j - 1,mb,ma,k));
        }

	rootpq = rootpqarray(ma + 1,j - mb);
        uarray_r(j,ma + 1,mb) =
          -rootpq * (b_r *  uarray_r(j - 1,ma,mb) +
                     b_i *  uarray_i(j - 1,ma,mb));
        uarray_i(j,ma + 1,mb) =
          -rootpq * (b_r *  uarray_i(j - 1,ma,mb) -
                     b_i *  uarray_r(j - 1,ma,mb));

        for (int k = 0; k < 3; k++) {
          duarray_r(j,mb,ma + 1,k) =
            -rootpq * (db_r[k] * uarray_r(j - 1,ma,mb) +
                       db_i[k] * uarray_i(j - 1,ma,mb) +
                       b_r * duarray_r(j - 1,mb,ma,k) +
                       b_i * duarray_i(j - 1,mb,ma,k));
          duarray_i(j,mb,ma + 1,k) =
            -rootpq * (db_r[k] * uarray_i(j - 1,ma,mb) -
                       db_i[k] * uarray_r(j - 1,ma,mb) +
                       b_r * duarray_i(j - 1,mb,ma,k) -
                       b_i * duarray_r(j - 1,mb,ma,k));
        }
      }
    });

    //int mbpar = -1;
    Kokkos::parallel_for(Kokkos::ThreadVectorRange(team,(j+2)/2),
        [&] (const int& mb) {
//    for (int mb = 0; 2*mb <= j; mb++) {
      int mbpar = (mb)%2==0?1:-1;
      int mapar = -mbpar;
      for (int ma = 0; ma <= j; ma++) {
    	mapar = -mapar;
    	if (mapar == 1) {
    	  uarray_r(j,j-ma,j-mb) = uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = -uarray_i(j,ma,mb);
    	  for (int k = 0; k < 3; k++) {
    	    duarray_r(j,j-mb,j-ma,k) = duarray_r(j,mb,ma,k);
    	    duarray_i(j,j-mb,j-ma,k) = -duarray_i(j,mb,ma,k);
    	  }
    	} else {
    	  uarray_r(j,j-ma,j-mb) = -uarray_r(j,ma,mb);
    	  uarray_i(j,j-ma,j-mb) = uarray_i(j,ma,mb);
    	  for (int k = 0; k < 3; k++) {
    	    duarray_r(j,j-mb,j-ma,k) = -duarray_r(j,mb,ma,k);
    	    duarray_i(j,j-mb,j-ma,k) = duarray_i(j,mb,ma,k);
    	  }
    	}
      }
    });
  }

  double sfac = compute_sfac(r, rcut);
  double dsfac = compute_dsfac(r, rcut);

  sfac *= wj;
  dsfac *= wj;

  for (int j = 0; j <= twojmax; j++)
    for (int mb = 0; mb <= j; mb++) 
      for (int ma = 0; ma <= j; ma++) {
        duarray_r(j,mb,ma,0) = dsfac * uarray_r(j,ma,mb) * ux +
                                  sfac * duarray_r(j,mb,ma,0);
        duarray_i(j,mb,ma,0) = dsfac * uarray_i(j,ma,mb) * ux +
                                  sfac * duarray_i(j,mb,ma,0);
        duarray_r(j,mb,ma,1) = dsfac * uarray_r(j,ma,mb) * uy +
                                  sfac * duarray_r(j,mb,ma,1);
        duarray_i(j,mb,ma,1) = dsfac * uarray_i(j,ma,mb) * uy +
                                  sfac * duarray_i(j,mb,ma,1);
        duarray_r(j,mb,ma,2) = dsfac * uarray_r(j,ma,mb) * uz +
                                  sfac * duarray_r(j,mb,ma,2);
        duarray_i(j,mb,ma,2) = dsfac * uarray_i(j,ma,mb) * uz +
                                  sfac * duarray_i(j,mb,ma,2);
      }
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::create_team_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team)
{
  int jdim = twojmax + 1;
  uarraytot_r_a = uarraytot_r = t_sna_3d(team.team_scratch(1),jdim,jdim,jdim);
  uarraytot_i_a = uarraytot_i = t_sna_3d(team.team_scratch(1),jdim,jdim,jdim);
  zarray_r = t_sna_5d(team.team_scratch(1),jdim,jdim,jdim,jdim,jdim);
  zarray_i = t_sna_5d(team.team_scratch(1),jdim,jdim,jdim,jdim,jdim);

  rij = t_sna_2d(team.team_scratch(1),nmax,3);
  rcutij = t_sna_1d(team.team_scratch(1),nmax);
  wj = t_sna_1d(team.team_scratch(1),nmax);
  inside = t_sna_1i(team.team_scratch(1),nmax);
}


inline
T_INT SNA::size_team_scratch_arrays() {
  T_INT size = 0;
  int jdim = twojmax + 1;

  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_5d::shmem_size(jdim,jdim,jdim,jdim,jdim);
  size += t_sna_5d::shmem_size(jdim,jdim,jdim,jdim,jdim);

  size += t_sna_2d::shmem_size(nmax,3);
  size += t_sna_1d::shmem_size(nmax);
  size += t_sna_1d::shmem_size(nmax);
  size += t_sna_1i::shmem_size(nmax);

  return size;
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
void SNA::create_thread_scratch_arrays(const Kokkos::TeamPolicy<>::member_type& team)
{
  int jdim = twojmax + 1;
  dbvec = Kokkos::View<double*[3], Kokkos::LayoutRight>(team.thread_scratch(1),ncoeff);
  dbarray = t_sna_4d(team.thread_scratch(1),jdim,jdim,jdim);

  uarray_r = t_sna_3d(team.thread_scratch(1),jdim,jdim,jdim);
  uarray_i = t_sna_3d(team.thread_scratch(1),jdim,jdim,jdim);
  duarray_r = t_sna_4d(team.thread_scratch(1),jdim,jdim,jdim);
  duarray_i = t_sna_4d(team.thread_scratch(1),jdim,jdim,jdim);
}

inline
T_INT SNA::size_thread_scratch_arrays() {
  T_INT size = 0;
  int jdim = twojmax + 1;
  size += Kokkos::View<double*[3], Kokkos::LayoutRight>::shmem_size(ncoeff);
  size += t_sna_4d::shmem_size(jdim,jdim,jdim);

  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_3d::shmem_size(jdim,jdim,jdim);
  size += t_sna_4d::shmem_size(jdim,jdim,jdim);
  size += t_sna_4d::shmem_size(jdim,jdim,jdim);
  return size;
}

/* ----------------------------------------------------------------------
   factorial n
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::factorial(int n)
{
  double result = 1.0;
  for(int i=1; i<=n; i++)
    result *= 1.0*i;
  return result;
}

/* ----------------------------------------------------------------------
   the function delta given by VMK Eq. 8.2(1)
------------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::deltacg(int j1, int j2, int j)
{
  double sfaccg = factorial((j1 + j2 + j) / 2 + 1);
  return sqrt(factorial((j1 + j2 - j) / 2) *
              factorial((j1 - j2 + j) / 2) *
              factorial((-j1 + j2 + j) / 2) / sfaccg);
}

/* ----------------------------------------------------------------------
   assign Clebsch-Gordan coefficients using
   the quasi-binomial formula VMK 8.2.1(3)
------------------------------------------------------------------------- */

inline
void SNA::init_clebsch_gordan()
{
  double sum,dcg,sfaccg;
  int m, aa2, bb2, cc2;
  int ifac;
  auto h_cgarray = Kokkos::create_mirror_view(cgarray);

  for (int j1 = 0; j1 <= twojmax; j1++)
    for (int j2 = 0; j2 <= twojmax; j2++)
      for (int j = abs(j1 - j2); j <= MIN(twojmax, j1 + j2); j += 2)
        for (int m1 = 0; m1 <= j1; m1 += 1) {
          aa2 = 2 * m1 - j1;

          for (int m2 = 0; m2 <= j2; m2 += 1) {

            // -c <= cc <= c

            bb2 = 2 * m2 - j2;
            m = (aa2 + bb2 + j) / 2;

            if(m < 0 || m > j) continue;

	    sum = 0.0;

	    for (int z = MAX(0, MAX(-(j - j2 + aa2)
				   / 2, -(j - j1 - bb2) / 2));
		z <= MIN((j1 + j2 - j) / 2,
			 MIN((j1 - aa2) / 2, (j2 + bb2) / 2));
		z++) {
	      ifac = z % 2 ? -1 : 1;
	      sum += ifac /
		(factorial(z) *
		 factorial((j1 + j2 - j) / 2 - z) *
		 factorial((j1 - aa2) / 2 - z) *
		 factorial((j2 + bb2) / 2 - z) *
		 factorial((j - j2 + aa2) / 2 + z) *
		 factorial((j - j1 - bb2) / 2 + z));
	    }

	    cc2 = 2 * m - j;
	    dcg = deltacg(j1, j2, j);
	    sfaccg = sqrt(factorial((j1 + aa2) / 2) *
			factorial((j1 - aa2) / 2) *
			factorial((j2 + bb2) / 2) *
			factorial((j2 - bb2) / 2) *
			factorial((j  + cc2) / 2) *
			factorial((j  - cc2) / 2) *
			(j + 1));

	    h_cgarray(j1,j2,j,m1,m2) = sum * dcg * sfaccg;
	    //printf("SNAP-COMPARE: CG: %i %i %i %i %i %e\n",j1,j2,j,m1,m2,cgarray(j1,j2,j,m1,m2));
	  }
	}
  Kokkos::deep_copy(cgarray,h_cgarray);
}

/* ----------------------------------------------------------------------
   pre-compute table of sqrt[p/m2], p, q = 1,twojmax
   the p = 0, q = 0 entries are allocated and skipped for convenience.
------------------------------------------------------------------------- */

inline
void SNA::init_rootpqarray()
{
  auto h_rootpqarray = Kokkos::create_mirror_view(rootpqarray);
  for (int p = 1; p <= twojmax; p++)
    for (int q = 1; q <= twojmax; q++)
      h_rootpqarray(p,q) = sqrt(static_cast<double>(p)/q);
  Kokkos::deep_copy(rootpqarray,h_rootpqarray);
}


/* ---------------------------------------------------------------------- */
inline
int SNA::compute_ncoeff()
{
  int ncount;

  ncount = 0;

  for (int j1 = 0; j1 <= twojmax; j1++)
    if(diagonalstyle == 0) {
      for (int j2 = 0; j2 <= j1; j2++)
        for (int j = abs(j1 - j2);
            j <= MIN(twojmax, j1 + j2); j += 2)
          ncount++;
    } else if(diagonalstyle == 1) {
      int j2 = j1;

      for (int j = abs(j1 - j2);
          j <= MIN(twojmax, j1 + j2); j += 2)
        ncount++;
    } else if(diagonalstyle == 2) {
      ncount++;
    } else if(diagonalstyle == 3) {
      for (int j2 = 0; j2 <= j1; j2++)
        for (int j = abs(j1 - j2);
            j <= MIN(twojmax, j1 + j2); j += 2)
          if (j >= j1) ncount++;
    }

  return ncount;
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::compute_sfac(double r, double rcut)
{
  if (switch_flag == 0) return 1.0;
  if (switch_flag == 1) {
    if(r <= rmin0) return 1.0;
    else if(r > rcut) return 0.0;
    else {
      double rcutfac = MY_PI / (rcut - rmin0);
      return 0.5 * (cos((r - rmin0) * rcutfac) + 1.0);
    }
  }
  return 0.0;
}

/* ---------------------------------------------------------------------- */

KOKKOS_INLINE_FUNCTION
double SNA::compute_dsfac(double r, double rcut)
{
  if (switch_flag == 0) return 0.0;
  if (switch_flag == 1) {
    if(r <= rmin0) return 0.0;
    else if(r > rcut) return 0.0;
    else {
      double rcutfac = MY_PI / (rcut - rmin0);
      return -0.5 * sin((r - rmin0) * rcutfac) * rcutfac;
    }
  }
  return 0.0;
}



---

# CMakeLists.txt

SET(HEADERS
  neighbor_2d.h
  neighbor_csr.h
  neighbor_csr_map_constr.h)

SET(SOURCES
  neighbor_2d.cpp
  neighbor_csr.cpp
  neighbor_csr_map_constr.cpp)

target_sources(ExaMiniMD PRIVATE ${SOURCES} ${HEADERS})


---

# neighbor_2d.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <neighbor_2d.h>

#ifdef EMD_ENABLE_GPU
template struct Neighbor2D<t_neigh_mem_space>;
#endif
template struct Neighbor2D<Kokkos::HostSpace>;



---

# neighbor_2d.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Runtime Check for this Neighbor Class
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "2D") == 0) )
        neighbor_type = NEIGH_2D;
#endif

// Instantiation and Init of this class
#ifdef NEIGHBOR_MODULES_INSTANTIATION
    else if (input->neighbor_type == NEIGH_2D) {
      neighbor = new Neighbor2D<t_neigh_mem_space>();
      neighbor->init(input->force_cutoff + input->neighbor_skin);
    }
#endif

// Add Force Instantiation case
#if defined(FORCE_MODULES_INSTANTIATION)
      case NEIGH_2D: force = new FORCETYPE_ALLOCATION_MACRO(Neighbor2D<t_neigh_mem_space>); break;
#endif

// Add Force declaration line
#if defined(FORCE_MODULES_EXTERNAL_TEMPLATE)
      extern template class FORCETYPE_DECLARE_TEMPLATE_MACRO(Neighbor2D<t_neigh_mem_space>);
#endif

// Add Force Template Instantiation line
#if defined(FORCE_MODULES_TEMPLATE)
      template class FORCETYPE_DECLARE_TEMPLATE_MACRO(Neighbor2D<t_neigh_mem_space>);
#endif

// Making sure we are not just instantiating some Option
#if !defined(MODULES_OPTION_CHECK) && \
    !defined(NEIGHBOR_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_EXTERNAL_TEMPLATE) && \
    !defined(FORCE_MODULES_TEMPLATE)
#include <neighbor.h>
#ifndef NEIGHBOR_2D_H
#define NEIGHBOR_2D_H
#include <system.h>
#include <binning.h>

template<class MemorySpace>
struct NeighList2D {
  struct NeighView2D {
    private:
      T_INT* const ptr;
      const T_INT num_neighs;
      const T_INT stride;

    public:
      KOKKOS_INLINE_FUNCTION
      NeighView2D (T_INT* const ptr_, const T_INT& num_neighs_, const T_INT& stride_):
        ptr(ptr_),num_neighs(num_neighs_),stride(stride_) {}

      KOKKOS_INLINE_FUNCTION
      T_INT& operator() (const T_INT& i) const { return ptr[i*stride]; }

      KOKKOS_INLINE_FUNCTION
      T_INT get_num_neighs() const { return num_neighs; }
  };

  typedef NeighView2D t_neighs;

  NeighList2D() {
    maxneighs = 16;
  }

  KOKKOS_INLINE_FUNCTION
  T_INT get_num_neighs(const T_INT& i) const {
    return this->num_neighs(i);
  }

  KOKKOS_INLINE_FUNCTION
  t_neighs get_neighs(const T_INT& i) const {
    return t_neighs(&this->neighs(i,0),this->num_neighs(i),&this->neighs(i,1)-&this->neighs(i,0));
  }

  T_INT maxneighs;

  Kokkos::View<T_INT*, MemorySpace> num_neighs;
  Kokkos::View<T_INT**, MemorySpace> neighs;
};

template<class MemorySpace>
class Neighbor2D: public Neighbor {

protected:
  T_X_FLOAT neigh_cut;
  t_x x;
  t_type type;
  t_id id;

  T_INT nbinx,nbiny,nbinz,nhalo;
  T_INT N_local;

  bool skip_num_neigh_count, half_neigh;

  typename Binning::t_binoffsets bin_offsets;
  typename Binning::t_bincount bin_count;
  typename Binning::t_permute_vector permute_vector;

  Kokkos::View<T_INT, MemorySpace> resize,new_maxneighs;
  typename Kokkos::View<T_INT, MemorySpace>::HostMirror h_resize,h_new_maxneighs;


public:
  struct TagFillNeighListFull {};
  struct TagFillNeighListHalf {};

  typedef Kokkos::TeamPolicy<TagFillNeighListFull, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlf;
  typedef Kokkos::TeamPolicy<TagFillNeighListHalf, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlh;

  typedef NeighList2D<MemorySpace> t_neigh_list;

  t_neigh_list neigh_list;


  Neighbor2D():neigh_cut(0.0) {
    neigh_type = NEIGH_2D;

    resize = Kokkos::View<T_INT, MemorySpace> ("Neighbor2D::resize");
    new_maxneighs = Kokkos::View<T_INT, MemorySpace> ("Neighbor2D::new_maxneighs");

    h_resize = Kokkos::create_mirror_view(resize);
    h_new_maxneighs = Kokkos::create_mirror_view(new_maxneighs);
  };
  ~Neighbor2D() {};

  void init(T_X_FLOAT neigh_cut_) {
    neigh_cut = neigh_cut_;

    // Create actual 2D NeighList
    neigh_list = t_neigh_list();
  };

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillNeighListFull&, const typename t_policy_fnlf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
          T_INT j = permute_vector(j_offset + bj);

          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            T_INT n = Kokkos::atomic_fetch_add(&neigh_list.num_neighs(i),1); // n is non-incremented (old) value, could use parallel_scan instead
            if (n < neigh_list.maxneighs)
              neighs_i(n) = j;
          }
        });
      }
       Kokkos::single(Kokkos::PerThread(team), [&] () {
         const T_INT num_neighs_i = neigh_list.num_neighs(i);
         if (num_neighs_i > neigh_list.maxneighs) {
           resize() = 1;
           new_maxneighs() = num_neighs_i; // may resize more times than necessary, but probably less expensive than using an atomic max
         }
       });
    });
  }

  KOKKOS_INLINE_FUNCTION
   void operator() (const TagFillNeighListHalf&, const typename t_policy_fnlh::member_type& team) const {
     const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
     const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
     const T_INT bz = team.league_rank() % nbinz + nhalo;


     const T_INT i_offset = bin_offsets(bx,by,bz);
     Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
       const T_INT i = permute_vector(i_offset + bi);
       if(i>=N_local) return;
       const typename t_neigh_list::t_neighs neighs_i = neigh_list.get_neighs(i);
       const T_F_FLOAT x_i = x(i,0);
       const T_F_FLOAT y_i = x(i,1);
       const T_F_FLOAT z_i = x(i,2);
       const int type_i = type(i);

       for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
       for(int by_j = by-1; by_j<by+2; by_j++)
       for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

       /*  if( ( (bx_j<bx) || ((bx_j == bx) && ( (by_j>by) ||  ((by_j==by) && (bz_j>bz) )))) &&    
             (bx_j>=nhalo) && (bx_j<nbinx+nhalo-1) &&    
             (by_j>=nhalo) && (by_j<nbiny+nhalo-1) &&
             (bz_j>=nhalo) && (bz_j<nbinz+nhalo-1)    
           ) continue;
*/
         const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
           Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
             T_INT j = permute_vector(j_offset + bj);
             const T_F_FLOAT x_j = x(j,0);
             const T_F_FLOAT y_j = x(j,1);
             const T_F_FLOAT z_j = x(j,2);
             if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
               return;
             const T_F_FLOAT dx = x_i - x_j;
             const T_F_FLOAT dy = y_i - y_j;
             const T_F_FLOAT dz = z_i - z_j;

             const int type_j = type(j);
             const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

             if((rsq <= neigh_cut*neigh_cut)) {
               T_INT n = Kokkos::atomic_fetch_add(&neigh_list.num_neighs(i),1); // n is non-incremented (old) value, could use parallel_scan instead
               if (n < neigh_list.maxneighs)
                 neighs_i(n) = j;
             }
           });
       }
       Kokkos::single(Kokkos::PerThread(team), [&] () {
         const T_INT num_neighs_i = neigh_list.num_neighs(i);
         if (num_neighs_i > neigh_list.maxneighs) {
           resize() = 1;
           new_maxneighs() = num_neighs_i; // may resize more times than necessary, but probably less expensive than using an atomic max
         }
       });
     });
   }

  void create_neigh_list(System* system, Binning* binning, bool half_neigh_, bool) {
    // Get some data handles
    N_local = system->N_local;
    x = system->x;
    type = system->type;
    id = system->id;
    half_neigh = half_neigh_;

    // Reset the neighbor count array
    if( neigh_list.num_neighs.extent(0) < N_local + 1 )
      neigh_list.num_neighs = Kokkos::View<T_INT*, MemorySpace>("Neighbors2D::num_neighs", N_local + 1);

    // Create the pair list
    nhalo = binning->nhalo;
    nbinx = binning->nbinx - 2*nhalo;
    nbiny = binning->nbiny - 2*nhalo;
    nbinz = binning->nbinz - 2*nhalo;

    T_INT nbins = nbinx*nbiny*nbinz;

    bin_offsets = binning->binoffsets;
    bin_count = binning->bincount;
    permute_vector = binning->permute_vector;

    do {

      // Resize NeighborList
      if( neigh_list.neighs.extent(0) < N_local + 1 || neigh_list.neighs.extent(1) < neigh_list.maxneighs )
        neigh_list.neighs = Kokkos::View<T_INT**, MemorySpace> ("Neighbor2D::neighs", N_local + 1, neigh_list.maxneighs);


      // Fill the NeighborList
      Kokkos::deep_copy(neigh_list.num_neighs,0);
      Kokkos::deep_copy(resize,0);

      if(half_neigh)
        Kokkos::parallel_for("Neighbor2D::fill_neigh_list_half",t_policy_fnlh(nbins,Kokkos::AUTO,8),*this);
      else
        Kokkos::parallel_for("Neighbor2D::fill_neigh_list_full",t_policy_fnlf(nbins,Kokkos::AUTO,8),*this);


      Kokkos::fence();

      Kokkos::deep_copy(h_resize,resize);

      if (h_resize()) {
        Kokkos::deep_copy(h_new_maxneighs, new_maxneighs);
        neigh_list.maxneighs = h_new_maxneighs() * 1.2;
      }
    }
    while (h_resize());
  }

  t_neigh_list get_neigh_list() { return neigh_list; }
  const char* name() {return "Neighbor2D";}
};

template<>
struct NeighborAdaptor<NEIGH_2D> {
  typedef Neighbor2D<t_neigh_mem_space> type;
};

extern template struct Neighbor2D<t_neigh_mem_space>;
#endif // #define NEIGHBOR_2D_H
#endif // MODULES_OPTION_CHECK / MODULES_INSTANTIATION


---

# neighbor_csr.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <neighbor_csr.h>

#ifdef EMD_ENABLE_GPU
template struct NeighborCSR<t_neigh_mem_space>;
#endif
template struct NeighborCSR<Kokkos::HostSpace>;



---

# neighbor_csr.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Runtime Check for this Neighbor Class
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "CSR") == 0) )
        neighbor_type = NEIGH_CSR;
#endif

// Instantiation and Init of this class
#ifdef NEIGHBOR_MODULES_INSTANTIATION
    else if (input->neighbor_type == NEIGH_CSR) {
      neighbor = new NeighborCSR<t_neigh_mem_space>();
      neighbor->init(input->force_cutoff + input->neighbor_skin);
    }
#endif

// Add Force Instantiation case
#if defined(FORCE_MODULES_INSTANTIATION)
      case NEIGH_CSR: force = new FORCETYPE_ALLOCATION_MACRO(NeighborCSR<t_neigh_mem_space>); break;
#endif

// Add Force declaration line
#if defined(FORCE_MODULES_EXTERNAL_TEMPLATE)
      extern template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSR<t_neigh_mem_space>);
#endif

// Add Force Template Instantiation line
#if defined(FORCE_MODULES_TEMPLATE)
      template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSR<t_neigh_mem_space>);
#endif

// Making sure we are not just instantiating some Option
#if !defined(MODULES_OPTION_CHECK) && \
    !defined(NEIGHBOR_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_EXTERNAL_TEMPLATE) && \
    !defined(FORCE_MODULES_TEMPLATE)
#include <neighbor.h>
#ifndef NEIGHBOR_CSR_H
#define NEIGHBOR_CSR_H
#include <Kokkos_StaticCrsGraph.hpp>
#include <system.h>
#include <binning.h>

template<class MemorySpace>
struct NeighListCSR : public Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT> {
  struct NeighViewCSR {
    private:
      const T_INT* const ptr;
      const T_INT num_neighs;

    public:
      KOKKOS_INLINE_FUNCTION
      NeighViewCSR (const T_INT* const ptr_, const T_INT& num_neighs_):
        ptr(ptr_),num_neighs(num_neighs_) {}

      KOKKOS_INLINE_FUNCTION
      T_INT operator() (const T_INT& i) const { return ptr[i]; }

      KOKKOS_INLINE_FUNCTION
      T_INT get_num_neighs() const { return num_neighs; }
  };

  typedef NeighViewCSR t_neighs;

  NeighListCSR() :
    Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT>() {}
  NeighListCSR (const NeighListCSR& rhs) :
    Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT>(rhs) {
  }

  template<class EntriesType, class RowMapType>
  NeighListCSR (const EntriesType& entries_,const RowMapType& row_map_) :
    Kokkos::StaticCrsGraph<T_INT,Kokkos::LayoutLeft,MemorySpace,void,T_INT>( entries_, row_map_) {}


  KOKKOS_INLINE_FUNCTION
  T_INT get_num_neighs(const T_INT& i) const {
    return this->row_map(i+1) - this->row_map(i);
  }

  KOKKOS_INLINE_FUNCTION
  t_neighs get_neighs(const T_INT& i) const {
    const T_INT start = this->row_map(i);
    const T_INT end = this->row_map(i+1);
    return t_neighs(&this->entries(start),end-start);
  }
};

template<class MemorySpace>
class NeighborCSR: public Neighbor {

protected:
  T_X_FLOAT neigh_cut;
  t_x x;
  t_type type;
  t_id id;

  T_INT nbinx,nbiny,nbinz,nhalo;
  T_INT N_local;

  Kokkos::View<T_INT*, MemorySpace> num_neighs;
  Kokkos::View<T_INT*, MemorySpace, Kokkos::MemoryTraits<Kokkos::Atomic> > num_neighs_atomic;
  Kokkos::View<T_INT*, MemorySpace> neigh_offsets;
  Kokkos::View<T_INT*, MemorySpace> neighs;
  bool skip_num_neigh_count, half_neigh;

  typename Binning::t_binoffsets bin_offsets;
  typename Binning::t_bincount bin_count;
  typename Binning::t_permute_vector permute_vector;



public:
  struct TagCreateOffsets {};
  struct TagCountNeighsFull {};
  struct TagFillNeighListFull {};
  struct TagCountNeighsHalf {};
  struct TagFillNeighListHalf {};

  typedef Kokkos::RangePolicy<TagCreateOffsets, Kokkos::IndexType<T_INT> > t_policy_co;
  typedef Kokkos::TeamPolicy<TagCountNeighsFull, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_cnf;
  typedef Kokkos::TeamPolicy<TagFillNeighListFull, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlf;
  typedef Kokkos::TeamPolicy<TagCountNeighsHalf, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_cnh;
  typedef Kokkos::TeamPolicy<TagFillNeighListHalf, Kokkos::IndexType<T_INT> , Kokkos::Schedule<Kokkos::Dynamic> > t_policy_fnlh;

  typedef NeighListCSR<MemorySpace> t_neigh_list;

  t_neigh_list neigh_list;


  NeighborCSR():neigh_cut(0.0) {
    neigh_type = NEIGH_CSR;
  };
  ~NeighborCSR() {};

  void init(T_X_FLOAT neigh_cut_) { neigh_cut = neigh_cut_; };

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCountNeighsFull&, const typename t_policy_cnf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      int neigh_count = 0;
      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        int neigh_count_temp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
          T_INT j = permute_vector(j_offset + bj);

          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);
          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            count++;
          }
        },neigh_count_temp);
        neigh_count+=neigh_count_temp;
      }
      Kokkos::single(Kokkos::PerThread(team), [&] () {
        num_neighs(i) = neigh_count;
      });
    });
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillNeighListFull&, const typename t_policy_fnlf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

        Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);

          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            T_INT offset = Kokkos::atomic_fetch_add(&num_neighs(i),1) + neigh_offsets(i);
            neighs(offset) = j;
          }
        });
      }
    });
  }

  KOKKOS_INLINE_FUNCTION
   void operator() (const TagCountNeighsHalf&, const typename t_policy_cnh::member_type& team) const {
     const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
     const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
     const T_INT bz = team.league_rank() % nbinz + nhalo;

     const T_INT i_offset = bin_offsets(bx,by,bz);
     Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
       const T_INT i = permute_vector(i_offset + bi);
       if(i>=N_local) return;
       const T_F_FLOAT x_i = x(i,0);
       const T_F_FLOAT y_i = x(i,1);
       const T_F_FLOAT z_i = x(i,2);
       const int type_i = type(i);

       int neigh_count = 0;
       for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
       for(int by_j = by-1; by_j<by+2; by_j++)
       for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

       /*  if( ( (bx_j<bx) || ((bx_j == bx) && ( (by_j>by) ||  ((by_j==by) && (bz_j>bz) )))) &&
             (bx_j>=nhalo) && (bx_j<nbinx+nhalo-1) &&
             (by_j>=nhalo) && (by_j<nbiny+nhalo-1) &&
             (bz_j>=nhalo) && (bz_j<nbinz+nhalo-1)
           ) continue;
*/
         const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
         int neigh_count_temp;
           Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
             T_INT j = permute_vector(j_offset + bj);
             const T_F_FLOAT x_j = x(j,0);
             const T_F_FLOAT y_j = x(j,1);
             const T_F_FLOAT z_j = x(j,2);
             if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
               return;
             const T_F_FLOAT dx = x_i - x_j;
             const T_F_FLOAT dy = y_i - y_j;
             const T_F_FLOAT dz = z_i - z_j;

             const int type_j = type(j);
             const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

             if((rsq <= neigh_cut*neigh_cut)) {
               count++;
             }
           },neigh_count_temp);
         neigh_count+=neigh_count_temp;
       }
       Kokkos::single(Kokkos::PerThread(team), [&] () {
         num_neighs(i) = neigh_count;
       });
     });
   }

   KOKKOS_INLINE_FUNCTION
   void operator() (const TagFillNeighListHalf&, const typename t_policy_fnlh::member_type& team) const {
     const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
     const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
     const T_INT bz = team.league_rank() % nbinz + nhalo;

     const T_INT i_offset = bin_offsets(bx,by,bz);
     Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
       const T_INT i = permute_vector(i_offset + bi);
       if(i>=N_local) return;
       const T_F_FLOAT x_i = x(i,0);
       const T_F_FLOAT y_i = x(i,1);
       const T_F_FLOAT z_i = x(i,2);
       const int type_i = type(i);

       for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
       for(int by_j = by-1; by_j<by+2; by_j++)
       for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {
/*
         if( ( (bx_j<bx) || ((bx_j == bx) && ( (by_j>by) ||  ((by_j==by) && (bz_j>bz) )))) &&
             (bx_j>nhalo) && (bx_j<nbinx+nhalo-2) &&
             (by_j>nhalo) && (by_j<nbiny+nhalo-2) &&
             (bz_j>nhalo) && (bz_j<nbinz+nhalo-2)
           ) continue;*/
         const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);

           Kokkos::parallel_for(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj) {
             T_INT j = permute_vector(j_offset + bj);
             const T_F_FLOAT x_j = x(j,0);
             const T_F_FLOAT y_j = x(j,1);
             const T_F_FLOAT z_j = x(j,2);
             if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
               return;
             const T_F_FLOAT dx = x_i - x_j;
             const T_F_FLOAT dy = y_i - y_j;
             const T_F_FLOAT dz = z_i - z_j;

             const int type_j = type(j);
             const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

             if((rsq <= neigh_cut*neigh_cut)) {
               T_INT offset = Kokkos::atomic_fetch_add(&num_neighs(i),1) + neigh_offsets(i);
               neighs(offset) = j;
             }
           });
       }
     });
   }
  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCreateOffsets&, const T_INT& i, T_INT& offset, const bool final) const {
    const T_INT count_i = num_neighs(i);
    if(final) {
      neigh_offsets(i) = offset;
      if(i==N_local-1)
        neigh_offsets(i+1) = offset+count_i;
    }
    offset += count_i;
  }

  void create_neigh_list(System* system, Binning* binning, bool half_neigh_, bool) {
    // Get some data handles
    N_local = system->N_local;
    x = system->x;
    type = system->type;
    id = system->id;
    half_neigh = half_neigh_;

    T_INT total_num_neighs;


    // Reset the neighbor count array
    if( num_neighs.extent(0) < N_local + 1 ) {
      num_neighs = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSR::num_neighs", N_local + 1);
      neigh_offsets = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSR::neigh_offsets", N_local + 1);
    } else
      Kokkos::deep_copy(num_neighs,0);
    num_neighs_atomic = num_neighs;


    // Create the pair list
    nhalo = binning->nhalo;
    nbinx = binning->nbinx - 2*nhalo;
    nbiny = binning->nbiny - 2*nhalo;
    nbinz = binning->nbinz - 2*nhalo;

    T_INT nbins = nbinx*nbiny*nbinz;

    bin_offsets = binning->binoffsets;
    bin_count = binning->bincount;
    permute_vector = binning->permute_vector;

    if(half_neigh)
      Kokkos::parallel_for("NeighborCSR::count_neighbors_half", t_policy_cnh(nbins,Kokkos::AUTO,8),*this);
    else
      Kokkos::parallel_for("NeighborCSR::count_neighbors_full", t_policy_cnf(nbins,Kokkos::AUTO,8),*this);
    Kokkos::fence();

    // Create the Offset list for neighbors of atoms
    Kokkos::parallel_scan("NeighborCSR::create_offsets", t_policy_co(0, N_local), *this);
    Kokkos::fence();

    // Get the total neighbor count
    Kokkos::View<T_INT,MemorySpace> d_total_num_neighs(neigh_offsets,N_local);
    Kokkos::deep_copy(total_num_neighs,d_total_num_neighs);

    // Resize NeighborList
    if( neighs.extent(0) < total_num_neighs )
      neighs = Kokkos::View<T_INT*, MemorySpace> ("NeighborCSR::neighs", total_num_neighs);

    // Copy entries from the PairList to the actual NeighborList
    Kokkos::deep_copy(num_neighs,0);

    if(half_neigh)
      Kokkos::parallel_for("NeighborCSR::fill_neigh_list_half",t_policy_fnlh(nbins,Kokkos::AUTO,8),*this);
    else
      Kokkos::parallel_for("NeighborCSR::fill_neigh_list_full",t_policy_fnlf(nbins,Kokkos::AUTO,8),*this);

    Kokkos::fence();

    // Create actual CSR NeighList
    neigh_list = t_neigh_list(
        Kokkos::View<T_INT*, MemorySpace>( neighs,     Kokkos::pair<T_INT,T_INT>(0,total_num_neighs)),
        Kokkos::View<T_INT*, MemorySpace>( neigh_offsets, Kokkos::pair<T_INT,T_INT>(0,N_local+1)));

  }

  t_neigh_list get_neigh_list() { return neigh_list; }
  const char* name() {return "NeighborCSR";}
};

template<>
struct NeighborAdaptor<NEIGH_CSR> {
  typedef NeighborCSR<t_neigh_mem_space> type;
};

extern template struct NeighborCSR<t_neigh_mem_space>;
#endif // #define NEIGHBOR_CSR_H
#endif // MODULES_OPTION_CHECK / MODULES_INSTANTIATION


---

# neighbor_csr_map_constr.cpp

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

#include <neighbor_csr_map_constr.h>

#ifdef EMD_ENABLE_GPU
template struct NeighborCSRMapConstr<t_neigh_mem_space>;
#endif
template struct NeighborCSRMapConstr<Kokkos::HostSpace>;



---

# neighbor_csr_map_constr.h

//************************************************************************
//  ExaMiniMD v. 1.0
//  Copyright (2018) National Technology & Engineering Solutions of Sandia,
//  LLC (NTESS).
//
//  Under the terms of Contract DE-NA-0003525 with NTESS, the U.S. Government
//  retains certain rights in this software.
//
//  ExaMiniMD is licensed under 3-clause BSD terms of use: Redistribution and
//  use in source and binary forms, with or without modification, are
//  permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimer in the documentation
//       and/or other materials provided with the distribution.
//
//    3. Neither the name of the Corporation nor the names of the contributors
//       may be used to endorse or promote products derived from this software
//       without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY NTESS "AS IS" AND ANY EXPRESS OR IMPLIED
//  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL NTESS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
//  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
//  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
//  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
//
//  Questions? Contact Christian R. Trott (crtrott@sandia.gov)
//************************************************************************

// Runtime Check for this Neighbor Class
#ifdef MODULES_OPTION_CHECK
      if( (strcmp(argv[i+1], "CSR_MAPCONSTR") == 0) )
        neighbor_type = NEIGH_CSR_MAPCONSTR;
#endif

// Instantiation and Init of this class
#ifdef NEIGHBOR_MODULES_INSTANTIATION
    else if (input->neighbor_type == NEIGH_CSR_MAPCONSTR) {
      neighbor = new NeighborCSRMapConstr<t_neigh_mem_space>();
      neighbor->init(input->force_cutoff + input->neighbor_skin);
    }
#endif

// Add Force Instantiation case
#if defined(FORCE_MODULES_INSTANTIATION)
      case NEIGH_CSR_MAPCONSTR: force = new FORCETYPE_ALLOCATION_MACRO(NeighborCSRMapConstr<t_neigh_mem_space>); break;
#endif

// Add Force declaration line
#if defined(FORCE_MODULES_EXTERNAL_TEMPLATE)
      extern template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSRMapConstr<t_neigh_mem_space>);
#endif

// Add Force Template Instantiation line
#if defined(FORCE_MODULES_TEMPLATE)
      template class FORCETYPE_DECLARE_TEMPLATE_MACRO(NeighborCSRMapConstr<t_neigh_mem_space>);
#endif

// Making sure we are not just instantiating some Option
#if !defined(MODULES_OPTION_CHECK) && \
    !defined(NEIGHBOR_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_INSTANTIATION) && \
    !defined(FORCE_MODULES_EXTERNAL_TEMPLATE) && \
    !defined(FORCE_MODULES_TEMPLATE)
#ifndef NEIGHBOR_CSR_MAPCONSTR_H
#define NEIGHBOR_CSR_MAPCONSTR_H
#include <neighbor_csr.h>
#include <Kokkos_UnorderedMap.hpp>

template<class MemorySpace>
class NeighborCSRMapConstr: public Neighbor {

protected:
  T_X_FLOAT neigh_cut;
  t_x x;
  t_type type;
  t_id id;

  T_INT nbinx,nbiny,nbinz,nhalo;
  T_INT N_local;

  Kokkos::View<T_INT*, MemorySpace> num_neighs;
  Kokkos::View<T_INT*, MemorySpace, Kokkos::MemoryTraits<Kokkos::Atomic> > num_neighs_atomic;
  Kokkos::View<T_INT*, MemorySpace> neigh_offsets;
  Kokkos::View<T_INT*, MemorySpace> neighs;
  bool skip_num_neigh_count, half_neigh;

  typename Binning::t_binoffsets bin_offsets;
  typename Binning::t_bincount bin_count;
  typename Binning::t_permute_vector permute_vector;

  typedef Kokkos::UnorderedMap<Kokkos::pair<T_INT,T_INT>, void, MemorySpace> t_set;
  t_set pair_list;

public:
  struct TagFillPairListFull {};
  struct TagFillPairListHalf {};
  struct TagCopyNeighList {};
  struct TagCreateOffsets {};

  typedef Kokkos::TeamPolicy<TagFillPairListFull, Kokkos::IndexType<T_INT> > t_policy_fplf;
  typedef Kokkos::TeamPolicy<TagFillPairListHalf, Kokkos::IndexType<T_INT> > t_policy_fplh;
  typedef Kokkos::RangePolicy<TagCopyNeighList, Kokkos::IndexType<T_INT> > t_policy_cnl;
  typedef Kokkos::RangePolicy<TagCreateOffsets, Kokkos::IndexType<T_INT> > t_policy_co;

  typedef NeighListCSR<MemorySpace> t_neigh_list;

  t_neigh_list neigh_list;


  NeighborCSRMapConstr():neigh_cut(0.0) {
    neigh_type = NEIGH_CSR_MAPCONSTR;
  };
  ~NeighborCSRMapConstr() {};

  void init(T_X_FLOAT neigh_cut_) { neigh_cut = neigh_cut_; };

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillPairListFull&, const typename t_policy_fplf::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        int neigh_count_temp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT dx = x_i - x(j,0);
          const T_F_FLOAT dy = y_i - x(j,1);
          const T_F_FLOAT dz = z_i - x(j,2);

          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            pair_list.insert(Kokkos::pair<T_INT,T_INT>(i,j));
            count++;
          }
        },neigh_count_temp);
        Kokkos::single(Kokkos::PerThread(team), [&] () {
          if(!skip_num_neigh_count)
            num_neighs_atomic(i)+=neigh_count_temp;
        });
      }
    });
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagFillPairListHalf&, const typename t_policy_fplh::member_type& team) const {
    const T_INT bx = team.league_rank()/(nbiny*nbinz) + nhalo;
    const T_INT by = (team.league_rank()/(nbinz)) % nbiny + nhalo;
    const T_INT bz = team.league_rank() % nbinz + nhalo;

    const T_INT i_offset = bin_offsets(bx,by,bz);
    Kokkos::parallel_for(Kokkos::TeamThreadRange(team,0,bin_count(bx,by,bz)), [&] (const int bi) {
      const T_INT i = permute_vector(i_offset + bi);
      if(i>=N_local) return;
      const T_F_FLOAT x_i = x(i,0);
      const T_F_FLOAT y_i = x(i,1);
      const T_F_FLOAT z_i = x(i,2);
      const int type_i = type(i);

      for(int bx_j = bx-1; bx_j<bx+2; bx_j++)
      for(int by_j = by-1; by_j<by+2; by_j++)
      for(int bz_j = bz-1; bz_j<bz+2; bz_j++) {

        const T_INT j_offset = bin_offsets(bx_j,by_j,bz_j);
        int neigh_count_temp;
        Kokkos::parallel_reduce(Kokkos::ThreadVectorRange(team, bin_count(bx_j,by_j,bz_j)), [&] (const T_INT bj, int& count) {
          T_INT j = permute_vector(j_offset + bj);
          const T_F_FLOAT x_j = x(j,0);
          const T_F_FLOAT y_j = x(j,1);
          const T_F_FLOAT z_j = x(j,2);
          if( ((j==i) || (j<N_local || comm_newton==true)) && !((x_j > x_i)  || ((x_j == x_i) && ( (y_j>y_i) ||  ((y_j==y_i) && (z_j>z_i) )))))
            return;
          const T_F_FLOAT dx = x_i - x_j;
          const T_F_FLOAT dy = y_i - y_j;
          const T_F_FLOAT dz = z_i - z_j;

          const int type_j = type(j);
          const T_F_FLOAT rsq = dx*dx + dy*dy + dz*dz;

          if((rsq <= neigh_cut*neigh_cut) && (i!=j)) {
            pair_list.insert(Kokkos::pair<T_INT,T_INT>(i,j));
            count++;
          }
        },neigh_count_temp);
        Kokkos::single(Kokkos::PerThread(team), [&] () {
          if(!skip_num_neigh_count)
            num_neighs_atomic(i)+=neigh_count_temp;
        });
      }
    });
  }

  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCopyNeighList&, const T_INT& i) const {
    if(pair_list.valid_at(i)) {
      Kokkos::pair<T_INT,T_INT> pair_i = pair_list.key_at(i);
      T_INT offset = Kokkos::atomic_fetch_add(&num_neighs(pair_i.first),1) + neigh_offsets(pair_i.first);
      neighs(offset) = pair_i.second;
    }
  }


  KOKKOS_INLINE_FUNCTION
  void operator() (const TagCreateOffsets&, const T_INT& i, T_INT& offset, const bool final) const {
    const T_INT count_i = num_neighs(i);
    if(final)
      neigh_offsets(i) = offset;
    offset += count_i;
  }

  void create_neigh_list(System* system, Binning* binning, bool half_neigh_, bool) {
    // Get some data handles
    N_local = system->N_local;
    x = system->x;
    type = system->type;
    id = system->id;
    half_neigh = half_neigh_;

    T_INT total_num_neighs;

    // Compute number of expected neighbors
    T_X_FLOAT volume = system->domain_x * system->domain_y * system->domain_z;
    T_X_FLOAT particle_density =  1.0 * N_local / volume;
    T_INT num_neighs_estimate = particle_density *  (3.0/4.0 * 3.15 * neigh_cut * neigh_cut * neigh_cut);

    // Clear the PairList
    pair_list.clear();

    // Resize the PairList if necessary (make it a bit larger than needed for performance)
    if(pair_list.capacity() < T_INT(1.3 * num_neighs_estimate * N_local))
      pair_list.rehash( T_INT(1.3 * num_neighs_estimate * N_local) );

    // Reset the neighbor count array
    if( num_neighs.extent(0) < N_local + 1 ) {
      num_neighs = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSRMapConstr::num_neighs", N_local + 1);
      neigh_offsets = Kokkos::View<T_INT*, MemorySpace>("NeighborsCSRMapConstr::neigh_offsets", N_local + 1);
    } else
      Kokkos::deep_copy(num_neighs,0);
    num_neighs_atomic = num_neighs;

    // Create the pair list
    nhalo = binning->nhalo;
    nbinx = binning->nbinx - 2*nhalo;
    nbiny = binning->nbiny - 2*nhalo;
    nbinz = binning->nbinz - 2*nhalo;

    T_INT nbins = nbinx*nbiny*nbinz;

    bin_offsets = binning->binoffsets;
    bin_count = binning->bincount;
    permute_vector = binning->permute_vector;

    skip_num_neigh_count = false;

    if(half_neigh)
      Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_half", t_policy_fplh(nbins,Kokkos::AUTO,8),*this);
    else
      Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_full", t_policy_fplf(nbins,Kokkos::AUTO,8),*this);
    Kokkos::fence();

    // Create the Offset list for neighbors of atoms
    Kokkos::parallel_scan("NeighborCSRMapConstr::create_offsets", t_policy_co(0, N_local+1), *this);
    Kokkos::fence();

    // Get the total neighbor count
    Kokkos::View<T_INT,MemorySpace> d_total_num_neighs(neigh_offsets,N_local);
    Kokkos::deep_copy(total_num_neighs,d_total_num_neighs);

    // If inserts failed because the PairList was to small resize and recreate the PairList
    // Don't need to count this time around
    if(pair_list.failed_insert()) {
      pair_list.rehash(total_num_neighs*1.2);
      skip_num_neigh_count = true;
      if(half_neigh)
        Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_half", t_policy_fplh(nbins,Kokkos::AUTO,8),*this);
      else
        Kokkos::parallel_for("NeighborCSRMapConstr::fill_pair_list_full", t_policy_fplf(nbins,Kokkos::AUTO,8),*this);
      Kokkos::fence();
    }

    // Resize NeighborList
    if( neighs.extent(0) < total_num_neighs )
      neighs = Kokkos::View<T_INT*, MemorySpace> ("NeighborCSRMapConstr::neighs", total_num_neighs);

    // Copy entries from the PairList to the actual NeighborList
    Kokkos::deep_copy(num_neighs,0);

    Kokkos::parallel_for("NeighborCSRMapConstr::copy_to_neigh_list",t_policy_cnl(0,pair_list.capacity()),*this);
    Kokkos::fence();

    // Create actual CSR NeighList
    neigh_list = t_neigh_list(
        Kokkos::View<T_INT*, MemorySpace>( neighs,     Kokkos::pair<T_INT,T_INT>(0,total_num_neighs)),
        Kokkos::View<T_INT*, MemorySpace>( neigh_offsets, Kokkos::pair<T_INT,T_INT>(0,N_local+1)));

  }

  t_neigh_list get_neigh_list() { return neigh_list; }

  const char* name() {return "NeighborCSRMapConstr";}
};

extern template struct NeighborCSRMapConstr<t_neigh_mem_space>;
#endif // #define NEIGHBOR_CSR_MAPCONSTR_H
#endif // MODULES_OPTION_CHECK / MODULES_INSTANTIATION


---