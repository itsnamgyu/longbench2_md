cmake_minimum_required(VERSION 3.18)

#
# Allow for MSVC Runtime library controls
#
if(POLICY CMP0091)
  cmake_policy(SET CMP0091 NEW)
endif()

#
# We use simple syntax in cmake_dependent_option, so we are compatible with the
# extended syntax in CMake 3.22+
# https://cmake.org/cmake/help/v3.22/policy/CMP0127.html
#
if(POLICY CMP0127)
    cmake_policy(SET CMP0127 NEW)
endif()

#
# CMake 3.18+: CMAKE_CUDA_ARCHITECTURES
# https://cmake.org/cmake/help/latest/policy/CMP0104.html
# We have to migrate there, but maybe the new "native" option (CMake 3.24+)
# is what we want to wait for:
# https://cmake.org/cmake/help/v3.24/prop_tgt/CUDA_ARCHITECTURES.html
if(POLICY CMP0104)
    cmake_policy(SET CMP0104 OLD)
endif()

#
# Prevent in-source builds
#
if (CMAKE_BINARY_DIR STREQUAL CMAKE_SOURCE_DIR)
   message(FATAL_ERROR
      "\nin-source builds are not allowed: "
      "build directory cannot be in the source directory path!\n"
      "You MUST remove the file ${CMAKE_BINARY_DIR}/CMakeCache.txt and "
      " the directory ${CMAKE_BINARY_DIR}/CMakeFiles/ to be able to build again.")
endif ()


#
# Set search path for AMReX-specific CMake modules
#
set( AMREX_CMAKE_MODULES_PATH "${CMAKE_CURRENT_LIST_DIR}/Tools/CMake" CACHE INTERNAL "" )
set( CMAKE_MODULE_PATH ${AMREX_CMAKE_MODULES_PATH} )

#
# Retrieve amrex version
#
include( AMReXUtils )
get_amrex_version()


########################################################################
#
# AMReX project
#
########################################################################
project( AMReX
    DESCRIPTION "A software framework for massively parallel, block-structured adaptive mesh refinement (AMR) applications"
    VERSION  ${AMREX_PKG_VERSION}
    HOMEPAGE_URL "https://amrex-codes.github.io/amrex/"
    LANGUAGES C CXX
    )

message(STATUS "CMake version: ${CMAKE_VERSION}")


#
# Provide a default install directory
#
if ( CMAKE_SOURCE_DIR STREQUAL PROJECT_SOURCE_DIR AND CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT )
    set ( CMAKE_INSTALL_PREFIX "${PROJECT_SOURCE_DIR}/installdir"
          CACHE PATH "AMReX installation directory" FORCE)
endif ()

message(STATUS "AMReX installation directory: ${CMAKE_INSTALL_PREFIX}")

#
# Check if CMAKE_BUILD_TYPE is given. If not, use default
#
if ( NOT CMAKE_BUILD_TYPE )
   set(CMAKE_CONFIGURATION_TYPES "Release;Debug;MinSizeRel;RelWithDebInfo")
   set(CMAKE_BUILD_TYPE Release
       CACHE STRING
       "Choose the build type, e.g. Release, Debug, or RelWithDebInfo." FORCE)
else ()
   message(STATUS "Build type set by user to '${CMAKE_BUILD_TYPE}'.")
endif()

#
# Include options, utilities and other stuff we need
#
include( AMReXOptions )

#
# Enable CUDA if requested
#
if (AMReX_CUDA)
    enable_language(CUDA)
    if(CMAKE_VERSION VERSION_LESS 3.20)
        include(AMReX_SetupCUDA)
    endif()
endif ()

#
# Enable Fortran if requested
#
if(AMReX_FORTRAN)
   enable_language(Fortran)
endif ()

#
# Include options specifically for CUDA
#
if (AMReX_GPU_BACKEND STREQUAL "CUDA")
   include(AMReXCUDAOptions)
endif ()

#
# Check compiler version
#
set_mininum_compiler_version(CXX GNU 5.1)
set_mininum_compiler_version(CXX MSVC 19.23)

#
# Set CMAKE_<LANG>_FLAGS_<CONFIG> if not already defined
#
set_default_config_flags ()

#
# Source files for all binaries and libraries found under src
#
add_subdirectory(Src)
get_property(_amrex_targets
   DIRECTORY Src
   PROPERTY BUILDSYSTEM_TARGETS)

#
# Plotfile tools
#
option(AMReX_PLOTFILE_TOOLS "Enable Plotfile tools" NO)

if (AMReX_PLOTFILE_TOOLS)
   # If this get executed, it cannot be EXCLUDED_FROM_ALL
   # because it needs to get installed
   add_subdirectory(Tools/Plotfile)
   get_property(_plotfile_targets
      DIRECTORY Tools/Plotfile
      PROPERTY BUILDSYSTEM_TARGETS)
   list(APPEND _amrex_targets ${_plotfile_targets})
endif ()


#
# Install amrex  -- Export
#
include(AMReXInstallHelpers)
install_amrex_targets(${_amrex_targets})

if(AMReX_INSTALL)
    # Add a test_install target to smoke-test
    # the installation
    add_test_install_target(
       ${CMAKE_CURRENT_LIST_DIR}/Tests/CMakeTestInstall
       ${CMAKE_INSTALL_PREFIX})
endif()

#
# Enable CTests
#
if (AMReX_ENABLE_TESTS)
   enable_testing()
   add_subdirectory(Tests)
endif ()


{
    "creators": [
        {
            "name": "the AMReX Development Team"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Almgren, Ann",
            "orcid": "0000-0003-2103-312X"
        },
        {
            "name": "Beckner, Vince"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Blaschke, Johannes",
            "orcid": "0000-0002-6024-3990"
        },
        {
            "affiliation": "Computer Science Department, Lawrence Berkeley National Laboratory",
            "name": "Chan, Cy",
            "orcid": "0000-0001-6881-827X"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Day, Marcus",
            "orcid": "0000-0002-1711-3963"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering and NERSC, Lawrence Berkeley National Laboratory",
            "name": "Friesen, Brian",
            "orcid": "0000-0002-1572-1631"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering and NERSC, Lawrence Berkeley National Laboratory",
            "name": "Gott, Kevin",
            "orcid": "0000-0003-3244-5525"
        },
        {
            "affiliation": "Applied Numerical Algorithms Group, Lawrence Berkeley National Laboratory",
            "name": "Graves, Daniel",
            "orcid": "0000-0001-9730-7217"
        },
        {
            "affiliation": "Accelerator Technology & Applied Physics Division, Lawrence Berkeley National Laboratory",
            "name": "Huebl, Axel",
            "orcid": "0000-0003-1943-7141"
        },
        {
            "affiliation": "NVIDIA Corporation",
            "name": "Katz, Maximilian",
            "orcid": "0000-0003-0439-4556"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Myers, Andrew",
            "orcid": "0000-0001-8427-8330"
        },
        {
            "affiliation": "Computer Science Department, Lawrence Berkeley National Laboratory",
            "name": "Nguyen, Tan",
            "orcid": "0000-0003-3748-403X"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Nonaka, Andrew",
            "orcid": "0000-0003-1791-0265"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Rosso, Michele",
            "orcid": "0000-0001-8126-7425"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Sexton, Jean",
            "orcid": "0000-0003-2551-1678"
        },
        {
            "affiliation": "Computer Science Department, Lawrence Berkeley National Laboratory",
            "name": "Williams, Sam",
            "orcid": "0000-0002-8327-5717"
        },
        {
            "affiliation": "Center for Computational Sciences and Engineering, Lawrence Berkeley National Laboratory",
            "name": "Zhang, Weiqun",
            "orcid": "0000-0001-8092-1974"
        },
        {
            "affiliation": "Department of Physics and Astronomy, Stony Brook University",
            "name": "Zingale, Michael",
            "orcid": "0000-0001-8401-030X"
        }
    ],
    "keywords": [
        "adaptive mesh refinement",
        "finite difference",
        "finite volume"
    ]
}


<div align="center">
<img src="https://github.com/amrex-codes/amrex-codes.github.io/blob/main/images/AMReX_logo_small_banner_500.png" alt="AMReX Logo">

<p align="center">
  <a href="https://doi.org/10.21105/joss.01370">
  <img src="http://joss.theoj.org/papers/10.21105/joss.01370/status.svg" alt="Citing">
  </a>
  <a href="https://doi.org/10.5281/zenodo.2555438">
  <img src="https://zenodo.org/badge/DOI/10.5281/zenodo.2555438.svg" alt="DOI">
  </a>
  <a href="https://scan.coverity.com/projects/amrex-codes-amrex">
  <img alt="Coverity Scan Build Status" src="https://scan.coverity.com/projects/28563/badge.svg">
  </a>
  <a href="https://opensource.org/licenses/BSD-3-Clause">
  <img alt="License" src="https://img.shields.io/badge/License-BSD_3--Clause-blue.svg">
  </a>
</p>


<p>
A software framework for massively parallel block-structured adaptive mesh
refinement applications.
</p>

[Overview](#Overview) -
[Features](#Features) -
[Documentation](#Documentation) -
[Gallery](#Gallery) -
[Get Help](#get-help) -
[Contribute](#Contribute) -
[License](#License) -
[Citation](#Citation)

</div>

## Overview

AMReX is a software framework designed to accelerate scientific discovery for
applications solving partial differential equations on block-structured meshes. Its
massively parallel adaptive mesh refinement (AMR) algorithms focus computational
resources and allow scalable performance on heterogeneous architectures so that
scientists can efficiently resolve details in large simulations.
AMReX is developed at [LBNL](https://www.lbl.gov/), [NREL](https://www.nrel.gov/),
and [ANL](https://www.anl.gov/) as part of the Block-Structured
AMR Co-Design Center in the Department of Energy's Exascale Computing Project.

More information is available at the [AMReX website](https://amrex-codes.github.io/).

## Features

- C++ and Fortran interfaces
- Support for cell-centered, face-centered, edge-centered, and nodal data
- Support for hyperbolic, parabolic, and elliptic solves on a hierarchical adaptive grid structure
- Optional subcycling in time for time-dependent PDEs
- Support for particles
- Embedded boundary description of irregular geometry
- Parallelization via flat MPI, OpenMP, hybrid MPI/OpenMP, or MPI/MPI
- GPU Acceleration with CUDA (NVidia), HIP (AMD) or SYCL (Intel) backends
- Parallel I/O
- Plotfile format supported by Amrvis, VisIt, ParaView and yt
- Built-in profiling tools

## Documentation

Four types of documentation are available:
- [User's Guide](https://amrex-codes.github.io/amrex/docs_html/) -- For more information about AMReX features and functions
- [Example Codes](https://amrex-codes.github.io/amrex/tutorials_html/#example-codes) -- The fastest way to start your own project
- [Guided Tutorials](https://amrex-codes.github.io/amrex/tutorials_html/GuidedTutorials.html) -- Learn basic AMReX topics in a progressive way
- [Technical Reference](https://amrex-codes.github.io/amrex/doxygen/) -- Conveniently searchable code documentation via Doxygen

## Gallery

AMReX supports several Exascale Computing Project software applications, such as
ExaSky, WarpX, Pele(Combustion), Astro, and MFiX-Exa. AMReX has also been used
in a wide variety of other scientific simulations, some of which, can be seen
in our application [gallery](https://amrex-codes.github.io/amrex/gallery.html).

<div align="center">
<img src="https://github.com/amrex-codes/amrex-codes.github.io/blob/main/images/gallery_small.gif" alt="Gallery Slideshow">
</div>

## Get Help

You can also view questions
and ask your own on our [GitHub Discussions](https://github.com/AMReX-Codes/amrex/discussions) page.  
To obtain additional help, simply post an issue.

## Contribute

We are always happy to have users contribute to the AMReX source code. To
contribute, issue a pull request against the development branch.
Any level of changes are welcomed: documentation, bug fixes, new test problems,
new solvers, etc. For more details on how to contribute to AMReX, please see
[CONTRIBUTING.md](CONTRIBUTING.md).

## License

AMReX Copyright (c) 2017, The Regents of the University of California,
through Lawrence Berkeley National Laboratory and the Alliance for
Sustainable Energy, LLC., through National Renewable Energy Laboratory
(subject to receipt of any required approvals from the U.S. Dept. of
Energy).  All rights reserved.

If you have questions about your rights to use or distribute this
software, please contact Berkeley Lab's Innovation & Partnerships
Office at IPO@lbl.gov.

NOTICE.  This Software was developed under funding from the
U.S. Department of Energy and the U.S. Government consequently retains
certain rights. As such, the U.S. Government has been granted for
itself and others acting on its behalf a paid-up, nonexclusive,
irrevocable, worldwide license in the Software to reproduce,
distribute copies to the public, prepare derivative works, and perform
publicly and display publicly, and to permit other to do so.

License for AMReX can be found at [LICENSE](LICENSE).

## Citation

To cite AMReX, please use [![Citing](http://joss.theoj.org/papers/10.21105/joss.01370/status.svg)](https://doi.org/10.21105/joss.01370)

```
@article{AMReX_JOSS,
  doi = {10.21105/joss.01370},
  url = {https://doi.org/10.21105/joss.01370},
  year = {2019},
  month = may,
  publisher = {The Open Journal},
  volume = {4},
  number = {37},
  pages = {1370},
  author = {Weiqun Zhang and Ann Almgren and Vince Beckner and John Bell and Johannes Blaschke and Cy Chan and Marcus Day and Brian Friesen and Kevin Gott and Daniel Graves and Max Katz and Andrew Myers and Tan Nguyen and Andrew Nonaka and Michele Rosso and Samuel Williams and Michael Zingale},
  title = {{AMReX}: a framework for block-structured adaptive mesh refinement},
  journal = {Journal of Open Source Software}
}
```


## Development Model

Development generally follows the following ideas:

  * New features are merged into to the `development` branch using
    Pull Requests (PRs).

    Nightly regression testing is used to ensure that no answers
    change (or if they do, that the changes were expected).

  * Bug fixes, questions and contributions of new features are welcome!

       * Bugs should be reported through GitHub Issues.
       * We suggest asking questions through GitHub Discussions.
       * All contributions should be done via pull requests.
         A pull request should be generated from your fork of
         amrex and target the `development` branch. See below for
         details on how this process works.

         In general we squash commits upon merge to have a clean history.
         *Please ensure that your PR title and description are descriptive,
         since these will be used for a squashed commit message.*

         Please note the following:
            If you choose to make contributions to the code
            then you hereby grant a non-exclusive, royalty-free perpetual license
            to install, use, modify, prepare derivative works,
            incorporate into other computer software,
            distribute, and sublicense such enhancements or derivative works
            thereof, in binary and source code form.

  * On the first workday of each month, we make a tagged release.  The merge window into
    `development` is closed a few days before the release day.  While the merge window is closed,
    only bug fixes should be merged into `development`.  Once the release is done, the merge window
    reopens.

## Git workflow

AMReX uses [git](https://git-scm.com) for version control. If you
are new to git, you can follow one of these tutorials:
- [Learn git with bitbucket](https://www.atlassian.com/git/tutorials/learn-git-with-bitbucket-cloud)
- [git - the simple guide](http://rogerdudler.github.io/git-guide/)

### Make your own fork and create a branch on it

The basic workflow is:
- Fork the main repo (or update it if you already created it).
- Implement your changes and push them on a new branch `<branch_name>` on
your fork.
- Create a Pull Request from branch `<branch_name>` on your fork to branch
`development` on the main AMReX repository.

First, let us setup your local git repo. To make your own fork of the main
repository, press the fork button on the [AMReX Github page](https://github.com/AMReX-Codes/amrex).

> Note: If you already had a fork of AMReX prior to 4/17/2020, we recommend deleting it and re-forking.
> This is due to a history re-write on the main repository. Note that you will lose any branches
> on your fork that haven't been merged into main development yet.

Then, clone amrex on your local computer. If you plan on doing a lot of amrex development,
we recommend configuring your clone to use ssh access so you won't have to enter your Github
password every time, which you can do using these commands:

```
git clone git@github.com:AMReX-Codes/amrex.git
cd amrex

# Add your own fork.
# Here <Jane> is the name you give to your fork. It does not need to be your github name.
# <myGithubUsername> is your GitHub name.
git remote add <Jane> git@github.com:<myGithubUsername>/amrex.git
git fetch <Jane>

# Don't push to the main repo. Instead pushes go to your fork.
git remote set-url --push origin git@github.com:<myGithubUsername>/amrex.git
```

For instructions on setting up SSH access to your Github account on a new
machine, see
[here.](https://docs.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh)

If you instead prefer to use HTTPS authentication, configure your local clone as follows:

```
git clone https://github.com/AMReX-Codes/amrex.git
cd amrex

# Add your own fork.
# Here <Jane> is the name you give to your fork. It does not need to be your github name.
# <myGithubUsername> is your GitHub name.
git remote add <Jane> https://github.com/<myGithubUsername>/amrex.git
git fetch <Jane>

# Don't push to the main repo. Instead pushes go to your fork.
git remote set-url --push origin https://github.com/<myGithubUsername>/amrex.git
```

Now you are free to play with your fork (for additional information, you can visit the
[Github fork help page](https://help.github.com/en/articles/fork-a-repo)).

> Note: you do not have to re-do the setup above every time.

Make sure you are on the `development` branch with
```
git checkout development
git pull
```
in the AMReX directory.

Create a branch `<branch_name>` (the branch name should reflect the piece
of code you want to add, like `high_order_interpolation`) with
```
git checkout -b <branch_name>
```
and do the coding you want.
Add the files you work on to the git staging area with
```
git add <file_I_created> <and_file_I_modified>
```
### Commit & push your changes

Periodically commit your changes with
```
git commit -m "This is a 50-char description to explain my work"
```

The commit message (between quotation marks) is super important in order to
follow the developments and identify bugs.

For the moment, commits are on your local repo only. You can push them to
your fork with
```
git push -u <Jane> <branch_name>
```

If you want to synchronize your branch with the `development` branch (this is useful
when `development` is being modified while you are working on
`<branch_name>`), you can use
```
# merge amrex main repo's development into current branch
git pull origin development
```
and fix any conflicts that may occur.

Do not merge your branch for PR into your local `development` branch,
because it will make your local `development` branch diverge from the
matching branch in the main repository after your PR is merged.

### Submit a Pull Request

A Pull Request is the way to efficiently visualize the changes you made
and to propose your new feature/improvement/fix to the AMReX project.
Right after you push changes, a banner should appear on the Github page of
your fork, with your `<branch_name>`.
- Click on the `compare & pull request` button to prepare your PR.
- It is time to communicate your changes: write a title and a description for
your PR. People who review your PR are happy to know
  * what feature/fix you propose, and why
  * how you made it (created a new class than inherits from...)
  * and anything relevant to your PR (performance tests, images, *etc.*)
- Press `Create pull request`. Now you can navigate through your PR, which
highlights the changes you made.

Please DO NOT write large Pull Requests, as they are very difficult and
time-consuming to review. As much as possible, split them into small,
targeted PRs.
For example, if find typos in the documentation open a pull request that only fixes typos.
If you want to fix a bug, make a small pull request that only fixes a bug.
If you want to implement a large feature, write helper functionality first, test it and submit those as a first pull request.
If you want to implement a feature and are not too sure how to split it,
just open a discussion about your plans and ping other AMReX developers on it to chime in.

Even before your work is ready to merge, it can be convenient to create a PR
(so you can use Github tools to visualize your changes). In this case, please
make a "draft" PR using the drop-down menu next to the "Create pull request" button.

Once your pull request is made, we will review and potentially merge it.
We recommend always creating a new branch for each pull request, as per the above instructions.
Once your pull request is merged, you can delete your local PR branch with
```
git branch -D <branch_name>
```

and you can delete the remote one on your fork with
```
git push <Jane> --delete <branch_name>
```

Generally speaking, you want to follow the following rules.

  * Do not merge your branch for PR into your local `development` branch that tracks AMReX
    `development` branch.  Otherwise your local `development` branch will diverge from AMReX
    `development` branch.

  * Do not commit in your `development` branch that tracks AMReX `development` branch.

  * Always create a new branch based off the latest `development` branch for
    each pull request, unless you are going to use git to fix it later.

If you have accidentally committed in `development` branch, you can fix it as follows,
```
git checkout -b new_branch # save your changes in a branch
git checkout development
git fetch origin
git reset --hard origin/development
```
After this, the local `development` should be in sync with AMReX `development` and your recent
commits have been saved in `new_branch` branch.

## AMReX Coding Style Guide

### Code Guidelines

AMReX developers should adhere to the following coding guidelines:
  * Indentations should use 4 spaces, not tabs.
  * Use curly braces for single statement blocks. For example:
```cpp
       for (int n=0; n<10; ++n) {
           Print() << "Like this!";
       }
```
  or
```cpp
       for (int n=0; n<10; ++n) { Print() << "Like this!"; }
```
  but not
```cpp

       for (int n=0; n<10; ++n) Print() << "Not like this.";
```
  or
```cpp
       for (int n=0; n<10; ++n)
          Print() << "Not like this.";
```
  * When declaring and defining a function, add a space after the function name and before the
parenthesis of the parameter list (but not when simply calling the function). For example:
```cpp
        void CorrectFunctionDec (int input)
```
  Not
```cpp
        void IncorrectFunctionDec(int input)
```
  This makes it easy to find where functions are defined with grep.
  * Member variables should be prefixed with `m_`. For example:
```cpp
       amrex::Real m_variable;
```
These guidelines should be adhered to in new contributions to AMReX, but
please refrain from making stylistic changes to unrelated sections of code in your PRs.

### API Documentation Using Doxygen

The Doxygen documentation is designed for advanced user-developers. It aims
to maximize the efficiency of a search-and-find style of locating information.
Doxygen style comment blocks should proceed the namespace, class, function, etc.
to be documented where appropriate. For example:
```cpp
   /**
    * \brief A one line description.
    *
    * \param[in] variable A short description of the variable.
    * \param[inout] data The value of data is read and changed.
    *
    * A longer description can be included here.
    */

    void MyFunction (int variable, MultiFab& data){
    ...
```
Additional information regarding Doxygen comment formatting can be found
in the [Doxygen Manual](https://www.doxygen.nl/manual/).




## Core Developers

People who make a number of substantive contributions will be named
"core developers" of AMReX.  The criteria for becoming a core
developer are flexible, but generally involve one of the following:

  * 100 non-trivial commits to `amrex/Src/`  *and/or*

  * addition of a new algorithm / module  *and/or*

  * substantial input into the code design process or testing

If a core developer is inactive for multiple years, we may reassess their
status as a core developer.

The current list of core developers is:
Ann Almgren (LBNL),
Vince Beckner,
John Bell (LBNL),
Johannes Blaschke (LBNL),
Cy Chan (LBNL),
Marcus Day (LBNL),
Brian Friesen (NERSC),
Kevin Gott (NERSC),
Daniel Graves (LBNL),
Axel Huebl (LBNL),
Max Katz (NVIDIA),
Andrew Myers (LBNL),
Tan Nguyen (LBNL),
Andrew Nonaka (LBNL),
Michele Rosso (LBNL),
Sam Williams (LBNL),
Weiqun Zhang (LBNL),
Michael Zingale (Stony Brook University).


# AMReX Code of Conduct

## Our Pledge

We as members, contributors, and leaders pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our Standards

Examples of behavior that contributes to a positive environment for our
community include:

* Demonstrating empathy and kindness toward other people
* Being respectful of differing opinions, viewpoints, and experiences
* Giving and gracefully accepting constructive feedback
* Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
* Focusing on what is best not just for us as individuals, but for the overall
  community

Examples of unacceptable behavior include:

* The use of sexualized language or imagery, and sexual attention or advances of
  any kind
* Trolling, insulting or derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or email address,
  without their explicit permission
* Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement Responsibilities

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement at amrex@lbl.gov.
All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident. Anyone involved in the reported behavior will recuse
themselves from the investigation and decision making about the resolution of
the complaint.

## Enforcement Guidelines

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning

**Community Impact**: A violation through a single incident or series of
actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or permanent
ban.

### 3. Temporary Ban

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent Ban

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the
community.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at
[https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations


Online documentation is available at https://amrex-codes.github.io/amrex/docs_html/.



# Migration From BoxLib

To help C++ BoxLib users migrate to AMReX, we have provided a set of
tools in `Tools/Migration`.  We recommend you go through the following
steps in the order listed.  You probably should perform the migration
in a branch.  For each step, it is recommended that you start with a
fresh clone of your latest migration branch.  It is assumed that the
environment variable `AMREX_HOME` is set to the AMReX directory.

**The scripts used in this process typically perform search and
  replace in the directory tree rooted at the current directory.  So
  do not run them outside your application code.  After you run a
  script, you should do `git diff` to check the results.**

## Step 0

Make sure your code works with the [latest version of BoxLib on
github](https://github.com/BoxLib-Codes/BoxLib).

## Step 1

AMReX `migration/1-amrex_home` branch should be used in this step.  In
this step, we replace `BOXLIB_HOME` with `AMREX_HOME` in the GNU Make
system by running the following command in your application directory.

    $AMREX_HOME/Tools/Migration/step-1-amrex_home/amrex_home.sh

## Step 2

AMReX `migration/2-parray` branch should be used in this step.  In
this step, we need to remove `PArray`, which is a BoxLib class that
has been removed from AMReX.  This step has to be done manually.

* Instead of `PArray`, one should use `Array<std::unique_ptr<T> >` for
  owning pointers and `Array<T*>` for non-owning pointers.  Note that
  `Array` is an AMReX class derived from `std::vector`.

* The `PArray` class does pointer dereferencing automatically, whereas
  now one must use either `*` or `->` like working with a raw pointer.

* Another difference is how to change a pointer stored.  For `PArray`,
  one often uses the `set` function.  The `Array` class does not have
  that function.  Instead one need to use the subscript operator `[]`
  to access the element.

* The `clear()` function in `PArray` class does not change the size of
  the `PArray` container.  But the `clear` function in `Array` reduces
  the size to zero.  If you do not want to resize the container, you
  can call `amrex::FillNull(myArray)` to fill it with null pointers.
  `PArray` also has a `clear(int i)` function.  For that, you can do
  `a[i].reset()` for `unique_ptr` and `a[i] = nullptr` for `T*`.

* BoxLib codes often use `PArray<T>&` as function arguments.  In
  AMReX, depending on the situation, one should use
  `Array<std::unique_ptr<T> >&` for functions that need to modify the
  pointers (e.g., allocate memory and store the pointers in the
  function parameter), and `const Array<T*>&` for cases where the
  function does not change the pointers even though they may modify
  the data pointed by the pointers.  AMReX provides a number of
  functions that can convert from `unique_ptr<T>` to `T*`.   For
  example,
  `Array<T*> GetArrOfPtrs (const Array<std::unique_ptr<T> >& a)`.
  These functions are in `Src/C_BaseLib/Array.H` as of writing,
  and they will be moved to `Src/Base/AMReX_Array.H`.

### Step 3

AMReX `migration/3-amrex-prefix` branch should be used in this step.
We have added `AMReX_` to source file names.  Thus we must update the
header file names in the source codes.  For example, `#include
<Box.H>` needs to be changed to `#include <AMReX_Box.H>`.  A script,
`Tools/Migration/step-3-amrex-prefix/amrexprefix.sh`, can be used to
do the search and replace.

### Step 4

AMReX `migration/4-dirname` branch should be used in this step.  In
AMRex, we have renamed several directories:

* Tools/C_mk --> Tools/GNUMake
* C_AMRLib --> Amr
* C_AmrCoreLib --> AmrCore
* C_BaseLib --> Base
* C_BoundaryLib --> Boundary
* C_ParticleLib --> Particle

A script `Tools/Migration/step-4-dirname/dirname.sh` can be used to
perform the search and replace.

### Step 5

AMReX `migration/5-namespace` branch should be used in this step.
BoxLib has a `BoxLib` namespace, but most of BoxLib classes are not in
the namespace.  In AMReX, all classes and functions have been moved
into the `amrex` namespace.  In this step, you can use
`Tools/Migration/step-5-amrex-namespace/amrex-namespace.sh` to replace
`BoxLib::` with `amrex::` for those already in `BoxLib` namespace.
However, the rest of work is expected to be performed manually,
because C++ is too a complicated language for shell scripting.

For most `.cpp` files, you can put a `using namespace amrex;` line
after the last `include` line, or `using amrex::MultiFab` etc., or you
can add `amrex::` to wherever needed.  Note that having both `using
namespace amrex` and `using namespace std` in one file may cause
conflicts because some names like `min` and `max` exist in both
namespace.

For header files, it is considered bad practice to have `using
namespace amrex` because it pollutes the namespace.  So you need to
manually add `amrex::` in front of AMReX names likes `MultiFab` and
`BoxArray`.

### Step 6

AMReX `migration/6-distributionmap` branch should be used in this step.

In BoxLib, there is a `DistributionMapping` cache implemented with
`std::map` with the number of `Box`es as the key.  Utilizing the
cache, `MultiFab`s can be built with shared `DistributionMapping`
without explicitly requiring a `DistributionMapping`.  In AMReX, the
`DistributionMapping` cache is removed for more flexibility.  Because
of the change, `DistributionMapping` is now a required argument to the
non-default constructors of `MultiFab`, `FluxRegister`, `BndryData`,
`AmrLevel`, `LevelBld`, and some other objects.  Many classes
including `MultiFab`, `AmrLevel`, `AmrCore` have functions returning
`DistributionMapping`.  One may also explicitly construct
`DistributionMapping` from `BoxArray`.  For example,

    DistributionMapping dm {a_BoxArray};

It should be emphasized that the result of the code above does **not**
solely depend on `BoxArray`.  Thus, different `DistributionMapping`s
may be built when this is called multiple times with the same
`BoxArray`.  If two `MultiFab`s need to share the same
`DistributionMapping`, only one `DistributionMapping` should be built.

For extensibility, the `MultiFab` constructor now also takes an `MFInfo`
object.  To construct a `MultiFab` without allocating memory for the
data,

    MFInfo info;
    info.SetAlloc(false);   // The default MFInfo is true.

`VisMF::Read` function used to only take an empty `MultiFab` built
with the default constructor.  The function reads `BoxArray` from
disk, builds the `MultiFab` with the `BoxArray` and a
`DistributionMapping` possibly from the `DistributionMapping` cache if
there is one cached for the same number of boxes, and then read the
data from the disk into the `MultiFab`.  Because the cache is removed,
the `VisMF::Read` function has been modified to also take a pre-built
`MultiFab`.  In that case, it is an error if the `MultiFab`'s
`BoxArray` does not match the `BoxArray` on the disk.  If an empty
`MultiFab` is passed into `VisMF::Read`, a **new**
`DistributionMapping` will be built, and this maybe not be desired
behavior.  `VisMF::Read` function is rarely called directly by an
application code.  But if it is, care must be taken to ensure that
`MultiFab`s read from the disk are distributed correctly among
processes.

### Step 7

AMReX `migration/7-bindc` branch should be used in this step.  In
BoxLib, the `Amr` class calls a Fortran subroutine `probinit` to perform
problem-specific initialization on Fortran side.  This is a subroutine
provided by application codes.  In AMReX, this subroutine is renamed
to `amrex_probint`, and it is expected to have `bind(c)` making the
interface of calling it from C++ clean.  A script
`Tools/Migration/step-7-bindc/bindc.sh` can be used to for the
migration.

### Step 8

AMReX `migration/8-deboxlib` branch should be used in this step.  In
the branch, `AMReX_winstd.H` is removed because Windows is not
supported.  `AMReX_BoxLib.H` is renamed `AMReX.H`.  There are also
some changes to `buildInfo` related to `AMReX_` prefix for file names
and `amrex` namespace.  A script
`Tools/Migration/step-8-deboxlib/deboxlib.sh` can be used to for the
migration.

In BoxLib, there are some runtime parameters with the `boxlib.` prefix
(e.g., `boxlib.fpe_trap_invalid` and `boxlib.verbose`).  The prefix is
now changed to `amrex.`.

### Step 9

AMReX `migration/9-pointers-n-sentinel` branch should be used in this
step.

`Amr` and `AmrLevel` used to return `MultiFab *` in the `derive`
function; they now return `std::unique_ptr<MultiFab>` for safety.
Application codes using `Amr` and `AmrLevel` classes need to update by
changing `MultiFab* mf = derive(...)` to `auto mf = derive(...)` and
removing the `delete` call.

AMReX's own smart pointer classes have been removed.  For application
codes that do not directly use them (which is usually the case), no
changes are needed.

We have removed the sentinel from the `DistributionMapping` class.
`DistributionMapping` has an `Array<int>` storing MPI ranks for all
grids in a `BoxArray`.  It used to be that the length of the `Array`
is the number of boxes plus one.  The last element was used to store
the MPI rank of the process as a sentinel.  But that information is no
longer needed.  Thus we have remove the sentinel, and the length of
the array equals the number of boxes.  If an application code builds
its own array of MPI ranks and passes it to `DistributionMapping`,
update is needed.  One might also search for `ProcessorMap` function
that returns the array to see if the array is being used and needs
update.  Most codes probably do not need any changes.


### Step 10

AMReX `migration/10-amrex-real` branch should be used in this step.

AMReX can be compiled with `PRECISION = DOUBLE` (default) or `FALSE`.
It used to be that `Real` was either `double` or `float`.  This has
now been put into the `amrex` namespace and becomes `amrex::Real`.
Fortran code can do `use amrex_fort_module, only : amrex_real` and
define variables as `real(amrex_real) :: x`.  C code can do `#include
<AMReX_REAL.H>` and use `amrex_real`.



# -*- coding: utf-8 -*-
#
# amrex documentation build configuration file, created by
# sphinx-quickstart on Thu Oct 19 14:30:08 2017.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#
# import os
# import sys
# sys.path.insert(0, os.path.abspath('.'))

from datetime import datetime

def get_amrex_version():
    today = datetime.today()
    return u'%s.%.2d-dev' % (str(today.year)[-2:], (today.month + 1) % 12)

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = ['sphinx.ext.mathjax',
              'sphinx.ext.githubpages',
              'sphinx.ext.viewcode',
              'sphinx.ext.intersphinx']

intersphinx_mapping = {
    'amrex_tutorials': ('https://amrex-codes.github.io/amrex/tutorials_html/', None),
    'amrex_hydro':('https://amrex-fluids.github.io/amrex-hydro/docs_html/', None)
}

# Add any paths that contain templates here, relative to this directory.
templates_path = ['ytemplates']

# The suffix(es) of source filenames.
# You can specify multiple suffix as a list of string:
#
# source_suffix = ['.rst', '.md']
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'amrex'
copyright = u'2017-2018, AMReX Team'
author = u'AMReX Team'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = get_amrex_version()
# The full version, including alpha/beta/rc tags.
release = get_amrex_version()

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set "language" from the command line for these cases.
language = 'en'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
# This patterns also effect to html_static_path and html_extra_path
exclude_patterns = []

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# If true, `todo` and `todoList` produce output, else they produce nothing.
todo_include_todos = False

numfig = True

# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#
html_theme = 'sphinx_rtd_theme'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#
# html_theme_options = {}

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

html_css_files = [
    'theme_overrides.css',  # overrides for wide tables in RTD theme
]

# Custom sidebar templates, must be a dictionary that maps document names
# to template names.
#
# This is required for the alabaster theme
# refs: http://alabaster.readthedocs.io/en/latest/installation.html#sidebars
html_sidebars = {
    '**': [
        'about.html',
        'navigation.html',
        'relations.html',  # needs 'show_related': True theme option to display
        'searchbox.html',
        'donate.html',
    ]
}


# -- Options for HTMLHelp output ------------------------------------------

# Output file base name for HTML help builder.
htmlhelp_basename = 'amrexdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
    # The paper size ('letterpaper' or 'a4paper').
    #
    # 'papersize': 'letterpaper',

    # The font size ('10pt', '11pt' or '12pt').
    #
    # 'pointsize': '10pt',

    # Additional stuff for the LaTeX preamble.
    #
    # 'preamble': '',

    # Latex figure (float) alignment
    #
    # 'figure_align': 'htbp',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
    (master_doc, 'amrex.tex', u'amrex Documentation',
     u'AMReX Team', 'manual'),
]


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    (master_doc, 'amrex', u'amrex Documentation',
     [author], 1)
]


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    (master_doc, 'amrex', u'amrex Documentation',
     author, 'amrex', 'One line description of project.',
     'Miscellaneous'),
]



CPU
GPU Stream 1
GPU Stream 2
GPU Stream 3
GPU
Synchronize
CPU Work After Loop
MFIter Loop Iterations
Kernel Launches


## Summary

## Additional background

## Checklist

The proposed changes:
- [ ] fix a bug or incorrect behavior in AMReX
- [ ] add new capabilities to AMReX
- [ ] changes answers in the test suite to more than roundoff level
- [ ] are likely to significantly affect the results of downstream AMReX users
- [ ] include documentation in the code and/or rst files, if appropriate


# Notes on the Cache Cleanup Workflows

There are two cache cleanup workflows, [CleanUpCache](cleanup-cache.yml) and
[CleanUpCachePostPR](cleanup-cache-postpr.yml). The former is triggered by
workflows listed in [clean-cache.yml](cleanup-cache.yml) (e.g., LinuxClang,
cuda, LinuxGcc, etc.). The latter is triggered by the close or merge of a
PR. The CleanupCache workflow will keep the last used cache and delete all
others, whereas the CleanupCachePostPR workflow will delete all caches
associated with the PR. Note that these workflows always run on the default
branch. That is the yml files on the default branch are used.

Below are more details of these events.

## If a cache cleanup workflow is triggered by

### Push to a feature branch on a fork

The workflow below runs on the fork, not the main repo. However, if a PR of
this branch has been submitted to the main repo, it will also trigger the PR
workflows on the main repo.

<details>
  <summary>Information of CleanupCache workflow</summary>

```
github.ref = refs/heads/main
github.head_ref = refs/heads/main
github.event =
{
  "action": "completed",
  "repository": {
    "allow_forking": true,
    "archive_url": "https://api.github.com/repos/WeiqunZhang/test_ci/{archive_format}{/ref}",
    "archived": false,
    "assignees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/assignees{/user}",
    "blobs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/blobs{/sha}",
    "branches_url": "https://api.github.com/repos/WeiqunZhang/test_ci/branches{/branch}",
    "clone_url": "https://github.com/WeiqunZhang/test_ci.git",
    "collaborators_url": "https://api.github.com/repos/WeiqunZhang/test_ci/collaborators{/collaborator}",
    "comments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/comments{/number}",
    "commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/commits{/sha}",
    "compare_url": "https://api.github.com/repos/WeiqunZhang/test_ci/compare/{base}...{head}",
    "contents_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contents/{+path}",
    "contributors_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contributors",
    "created_at": "2023-03-29T23:33:24Z",
    "default_branch": "main",
    "deployments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/deployments",
    "description": null,
    "disabled": false,
    "downloads_url": "https://api.github.com/repos/WeiqunZhang/test_ci/downloads",
    "events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/events",
    "fork": true,
    "forks": 0,
    "forks_count": 0,
    "forks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/forks",
    "full_name": "WeiqunZhang/test_ci",
    "git_commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/commits{/sha}",
    "git_refs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/refs{/sha}",
    "git_tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/tags{/sha}",
    "git_url": "git://github.com/WeiqunZhang/test_ci.git",
    "has_discussions": false,
    "has_downloads": true,
    "has_issues": false,
    "has_pages": false,
    "has_projects": true,
    "has_wiki": true,
    "homepage": null,
    "hooks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/hooks",
    "html_url": "https://github.com/WeiqunZhang/test_ci",
    "id": 621066743,
    "is_template": false,
    "issue_comment_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/comments{/number}",
    "issue_events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/events{/number}",
    "issues_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues{/number}",
    "keys_url": "https://api.github.com/repos/WeiqunZhang/test_ci/keys{/key_id}",
    "labels_url": "https://api.github.com/repos/WeiqunZhang/test_ci/labels{/name}",
    "language": "C++",
    "languages_url": "https://api.github.com/repos/WeiqunZhang/test_ci/languages",
    "license": {
      "key": "bsd-3-clause",
      "name": "BSD 3-Clause \"New\" or \"Revised\" License",
      "node_id": "MDc6TGljZW5zZTU=",
      "spdx_id": "BSD-3-Clause",
      "url": "https://api.github.com/licenses/bsd-3-clause"
    },
    "merges_url": "https://api.github.com/repos/WeiqunZhang/test_ci/merges",
    "milestones_url": "https://api.github.com/repos/WeiqunZhang/test_ci/milestones{/number}",
    "mirror_url": null,
    "name": "test_ci",
    "node_id": "R_kgDOJQS59w",
    "notifications_url": "https://api.github.com/repos/WeiqunZhang/test_ci/notifications{?since,all,participating}",
    "open_issues": 0,
    "open_issues_count": 0,
    "owner": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "private": false,
    "pulls_url": "https://api.github.com/repos/WeiqunZhang/test_ci/pulls{/number}",
    "pushed_at": "2023-04-01T17:08:01Z",
    "releases_url": "https://api.github.com/repos/WeiqunZhang/test_ci/releases{/id}",
    "size": 2,
    "ssh_url": "git@github.com:WeiqunZhang/test_ci.git",
    "stargazers_count": 0,
    "stargazers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/stargazers",
    "statuses_url": "https://api.github.com/repos/WeiqunZhang/test_ci/statuses/{sha}",
    "subscribers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscribers",
    "subscription_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscription",
    "svn_url": "https://github.com/WeiqunZhang/test_ci",
    "tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/tags",
    "teams_url": "https://api.github.com/repos/WeiqunZhang/test_ci/teams",
    "topics": [],
    "trees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/trees{/sha}",
    "updated_at": "2023-04-01T17:06:26Z",
    "url": "https://api.github.com/repos/WeiqunZhang/test_ci",
    "visibility": "public",
    "watchers": 0,
    "watchers_count": 0,
    "web_commit_signoff_required": false
  },
  "sender": {
    "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
    "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
    "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
    "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
    "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/WeiqunZhang",
    "id": 7862753,
    "login": "WeiqunZhang",
    "node_id": "MDQ6VXNlcjc4NjI3NTM=",
    "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
    "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
    "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/WeiqunZhang"
  },
  "workflow": {
    "badge_url": "https://github.com/WeiqunZhang/test_ci/workflows/Gcc/badge.svg",
    "created_at": "2023-03-29T23:33:38.000Z",
    "html_url": "https://github.com/WeiqunZhang/test_ci/blob/main/.github/workflows/gcc.yml",
    "id": 52767442,
    "name": "Gcc",
    "node_id": "W_kwDOJQS5984DJSrS",
    "path": ".github/workflows/gcc.yml",
    "state": "active",
    "updated_at": "2023-03-29T23:33:38.000Z",
    "url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/workflows/52767442"
  },
  "workflow_run": {
    "actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "artifacts_url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/runs/4584289327/artifacts",
    "cancel_url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/runs/4584289327/cancel",
    "check_suite_id": 11964509924,
    "check_suite_node_id": "CS_kwDOJQS5988AAAACySPu5A",
    "check_suite_url": "https://api.github.com/repos/WeiqunZhang/test_ci/check-suites/11964509924",
    "conclusion": "success",
    "created_at": "2023-04-01T17:08:03Z",
    "display_title": "minor change on feature branch of fork",
    "event": "push",
    "head_branch": "feature",
    "head_commit": {
      "author": {
        "email": "weiqunzhang@lbl.gov",
        "name": "Weiqun Zhang"
      },
      "committer": {
        "email": "weiqunzhang@lbl.gov",
        "name": "Weiqun Zhang"
      },
      "id": "582054dbf016d0db6a96756d9d855b2c4a65c58e",
      "message": "minor change on feature branch of fork",
      "timestamp": "2023-04-01T17:07:48Z",
      "tree_id": "f2073305e78daf775e7bf68d5a8ca682b12b6f79"
    },
    "head_repository": {
      "archive_url": "https://api.github.com/repos/WeiqunZhang/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/WeiqunZhang/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/WeiqunZhang/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/WeiqunZhang/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/WeiqunZhang/test_ci/downloads",
      "events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/events",
      "fork": true,
      "forks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/forks",
      "full_name": "WeiqunZhang/test_ci",
      "git_commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/hooks",
      "html_url": "https://github.com/WeiqunZhang/test_ci",
      "id": 621066743,
      "issue_comment_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/WeiqunZhang/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/WeiqunZhang/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/WeiqunZhang/test_ci/languages",
      "merges_url": "https://api.github.com/repos/WeiqunZhang/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/WeiqunZhang/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQS59w",
      "notifications_url": "https://api.github.com/repos/WeiqunZhang/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
        "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
        "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
        "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
        "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/WeiqunZhang",
        "id": 7862753,
        "login": "WeiqunZhang",
        "node_id": "MDQ6VXNlcjc4NjI3NTM=",
        "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
        "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
        "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/WeiqunZhang"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/WeiqunZhang/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/WeiqunZhang/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/WeiqunZhang/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/tags",
      "teams_url": "https://api.github.com/repos/WeiqunZhang/test_ci/teams",
      "trees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/WeiqunZhang/test_ci"
    },
    "head_sha": "582054dbf016d0db6a96756d9d855b2c4a65c58e",
    "html_url": "https://github.com/WeiqunZhang/test_ci/actions/runs/4584289327",
    "id": 4584289327,
    "jobs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/runs/4584289327/jobs",
    "logs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/runs/4584289327/logs",
    "name": "Gcc",
    "node_id": "WFR_kwLOJQS5988AAAABET60Lw",
    "path": ".github/workflows/gcc.yml",
    "previous_attempt_url": null,
    "pull_requests": [],
    "referenced_workflows": [],
    "repository": {
      "archive_url": "https://api.github.com/repos/WeiqunZhang/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/WeiqunZhang/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/WeiqunZhang/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/WeiqunZhang/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/WeiqunZhang/test_ci/downloads",
      "events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/events",
      "fork": true,
      "forks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/forks",
      "full_name": "WeiqunZhang/test_ci",
      "git_commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/hooks",
      "html_url": "https://github.com/WeiqunZhang/test_ci",
      "id": 621066743,
      "issue_comment_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/WeiqunZhang/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/WeiqunZhang/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/WeiqunZhang/test_ci/languages",
      "merges_url": "https://api.github.com/repos/WeiqunZhang/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/WeiqunZhang/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQS59w",
      "notifications_url": "https://api.github.com/repos/WeiqunZhang/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
        "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
        "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
        "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
        "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/WeiqunZhang",
        "id": 7862753,
        "login": "WeiqunZhang",
        "node_id": "MDQ6VXNlcjc4NjI3NTM=",
        "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
        "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
        "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/WeiqunZhang"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/WeiqunZhang/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/WeiqunZhang/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/WeiqunZhang/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/tags",
      "teams_url": "https://api.github.com/repos/WeiqunZhang/test_ci/teams",
      "trees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/WeiqunZhang/test_ci"
    },
    "rerun_url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/runs/4584289327/rerun",
    "run_attempt": 1,
    "run_number": 24,
    "run_started_at": "2023-04-01T17:08:03Z",
    "status": "completed",
    "triggering_actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "updated_at": "2023-04-01T17:08:44Z",
    "url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/runs/4584289327",
    "workflow_id": 52767442,
    "workflow_url": "https://api.github.com/repos/WeiqunZhang/test_ci/actions/workflows/52767442"
  }
}
```
</details>

### Pull request from a feature branch on a fork

The CleanupCache workflow will run on the default branch of the main repo.

<details>
  <summary>Information of CleanupCache workflow</summary>

```
github.ref = refs/heads/main
github.head_ref = refs/heads/main
github.event =
{
  "action": "completed",
  "organization": {
    "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
    "description": "AMReX-Codes: Block-Structured AMR Software Framework and Applications",
    "events_url": "https://api.github.com/orgs/AMReX-Codes/events",
    "hooks_url": "https://api.github.com/orgs/AMReX-Codes/hooks",
    "id": 25084337,
    "issues_url": "https://api.github.com/orgs/AMReX-Codes/issues",
    "login": "AMReX-Codes",
    "members_url": "https://api.github.com/orgs/AMReX-Codes/members{/member}",
    "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
    "public_members_url": "https://api.github.com/orgs/AMReX-Codes/public_members{/member}",
    "repos_url": "https://api.github.com/orgs/AMReX-Codes/repos",
    "url": "https://api.github.com/orgs/AMReX-Codes"
  },
  "repository": {
    "allow_forking": true,
    "archive_url": "https://api.github.com/repos/AMReX-Codes/test_ci/{archive_format}{/ref}",
    "archived": false,
    "assignees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/assignees{/user}",
    "blobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/blobs{/sha}",
    "branches_url": "https://api.github.com/repos/AMReX-Codes/test_ci/branches{/branch}",
    "clone_url": "https://github.com/AMReX-Codes/test_ci.git",
    "collaborators_url": "https://api.github.com/repos/AMReX-Codes/test_ci/collaborators{/collaborator}",
    "comments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/comments{/number}",
    "commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/commits{/sha}",
    "compare_url": "https://api.github.com/repos/AMReX-Codes/test_ci/compare/{base}...{head}",
    "contents_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contents/{+path}",
    "contributors_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contributors",
    "created_at": "2023-03-29T23:11:15Z",
    "default_branch": "main",
    "deployments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/deployments",
    "description": null,
    "disabled": false,
    "downloads_url": "https://api.github.com/repos/AMReX-Codes/test_ci/downloads",
    "events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/events",
    "fork": false,
    "forks": 1,
    "forks_count": 1,
    "forks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/forks",
    "full_name": "AMReX-Codes/test_ci",
    "git_commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/commits{/sha}",
    "git_refs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/refs{/sha}",
    "git_tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/tags{/sha}",
    "git_url": "git://github.com/AMReX-Codes/test_ci.git",
    "has_discussions": false,
    "has_downloads": true,
    "has_issues": true,
    "has_pages": false,
    "has_projects": true,
    "has_wiki": true,
    "homepage": null,
    "hooks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/hooks",
    "html_url": "https://github.com/AMReX-Codes/test_ci",
    "id": 621061581,
    "is_template": false,
    "issue_comment_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/comments{/number}",
    "issue_events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/events{/number}",
    "issues_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues{/number}",
    "keys_url": "https://api.github.com/repos/AMReX-Codes/test_ci/keys{/key_id}",
    "labels_url": "https://api.github.com/repos/AMReX-Codes/test_ci/labels{/name}",
    "language": "C++",
    "languages_url": "https://api.github.com/repos/AMReX-Codes/test_ci/languages",
    "license": {
      "key": "bsd-3-clause",
      "name": "BSD 3-Clause \"New\" or \"Revised\" License",
      "node_id": "MDc6TGljZW5zZTU=",
      "spdx_id": "BSD-3-Clause",
      "url": "https://api.github.com/licenses/bsd-3-clause"
    },
    "merges_url": "https://api.github.com/repos/AMReX-Codes/test_ci/merges",
    "milestones_url": "https://api.github.com/repos/AMReX-Codes/test_ci/milestones{/number}",
    "mirror_url": null,
    "name": "test_ci",
    "node_id": "R_kgDOJQSlzQ",
    "notifications_url": "https://api.github.com/repos/AMReX-Codes/test_ci/notifications{?since,all,participating}",
    "open_issues": 1,
    "open_issues_count": 1,
    "owner": {
      "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
      "events_url": "https://api.github.com/users/AMReX-Codes/events{/privacy}",
      "followers_url": "https://api.github.com/users/AMReX-Codes/followers",
      "following_url": "https://api.github.com/users/AMReX-Codes/following{/other_user}",
      "gists_url": "https://api.github.com/users/AMReX-Codes/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/AMReX-Codes",
      "id": 25084337,
      "login": "AMReX-Codes",
      "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
      "organizations_url": "https://api.github.com/users/AMReX-Codes/orgs",
      "received_events_url": "https://api.github.com/users/AMReX-Codes/received_events",
      "repos_url": "https://api.github.com/users/AMReX-Codes/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/AMReX-Codes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AMReX-Codes/subscriptions",
      "type": "Organization",
      "url": "https://api.github.com/users/AMReX-Codes"
    },
    "private": false,
    "pulls_url": "https://api.github.com/repos/AMReX-Codes/test_ci/pulls{/number}",
    "pushed_at": "2023-04-01T17:17:54Z",
    "releases_url": "https://api.github.com/repos/AMReX-Codes/test_ci/releases{/id}",
    "size": 27,
    "ssh_url": "git@github.com:AMReX-Codes/test_ci.git",
    "stargazers_count": 0,
    "stargazers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/stargazers",
    "statuses_url": "https://api.github.com/repos/AMReX-Codes/test_ci/statuses/{sha}",
    "subscribers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscribers",
    "subscription_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscription",
    "svn_url": "https://github.com/AMReX-Codes/test_ci",
    "tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/tags",
    "teams_url": "https://api.github.com/repos/AMReX-Codes/test_ci/teams",
    "topics": [],
    "trees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/trees{/sha}",
    "updated_at": "2023-03-29T23:32:27Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci",
    "visibility": "public",
    "watchers": 0,
    "watchers_count": 0,
    "web_commit_signoff_required": false
  },
  "sender": {
    "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
    "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
    "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
    "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
    "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/WeiqunZhang",
    "id": 7862753,
    "login": "WeiqunZhang",
    "node_id": "MDQ6VXNlcjc4NjI3NTM=",
    "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
    "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
    "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/WeiqunZhang"
  },
  "workflow": {
    "badge_url": "https://github.com/AMReX-Codes/test_ci/workflows/Gcc/badge.svg",
    "created_at": "2023-03-29T23:32:25.000Z",
    "html_url": "https://github.com/AMReX-Codes/test_ci/blob/main/.github/workflows/gcc.yml",
    "id": 52767392,
    "name": "Gcc",
    "node_id": "W_kwDOJQSlzc4DJSqg",
    "path": ".github/workflows/gcc.yml",
    "state": "active",
    "updated_at": "2023-03-30T17:04:11.000Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/workflows/52767392"
  },
  "workflow_run": {
    "actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "artifacts_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584337976/artifacts",
    "cancel_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584337976/cancel",
    "check_suite_id": 11964598047,
    "check_suite_node_id": "CS_kwDOJQSlzc8AAAACySVHHw",
    "check_suite_url": "https://api.github.com/repos/AMReX-Codes/test_ci/check-suites/11964598047",
    "conclusion": "success",
    "created_at": "2023-04-01T17:17:57Z",
    "display_title": "Feature",
    "event": "pull_request",
    "head_branch": "feature",
    "head_commit": {
      "author": {
        "email": "weiqunzhang@lbl.gov",
        "name": "Weiqun Zhang"
      },
      "committer": {
        "email": "weiqunzhang@lbl.gov",
        "name": "Weiqun Zhang"
      },
      "id": "6dccce9ae4c709b60590e48a62766eb0b5ac9838",
      "message": "add notes",
      "timestamp": "2023-04-01T17:16:59Z",
      "tree_id": "73d7cf644e8a6e1ffdfa1d09da2a34d067c49ad5"
    },
    "head_repository": {
      "archive_url": "https://api.github.com/repos/WeiqunZhang/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/WeiqunZhang/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/WeiqunZhang/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/WeiqunZhang/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/WeiqunZhang/test_ci/downloads",
      "events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/events",
      "fork": true,
      "forks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/forks",
      "full_name": "WeiqunZhang/test_ci",
      "git_commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/hooks",
      "html_url": "https://github.com/WeiqunZhang/test_ci",
      "id": 621066743,
      "issue_comment_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/WeiqunZhang/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/WeiqunZhang/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/WeiqunZhang/test_ci/languages",
      "merges_url": "https://api.github.com/repos/WeiqunZhang/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/WeiqunZhang/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQS59w",
      "notifications_url": "https://api.github.com/repos/WeiqunZhang/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
        "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
        "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
        "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
        "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/WeiqunZhang",
        "id": 7862753,
        "login": "WeiqunZhang",
        "node_id": "MDQ6VXNlcjc4NjI3NTM=",
        "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
        "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
        "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/WeiqunZhang"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/WeiqunZhang/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/WeiqunZhang/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/WeiqunZhang/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/tags",
      "teams_url": "https://api.github.com/repos/WeiqunZhang/test_ci/teams",
      "trees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/WeiqunZhang/test_ci"
    },
    "head_sha": "6dccce9ae4c709b60590e48a62766eb0b5ac9838",
    "html_url": "https://github.com/AMReX-Codes/test_ci/actions/runs/4584337976",
    "id": 4584337976,
    "jobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584337976/jobs",
    "logs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584337976/logs",
    "name": "Gcc",
    "node_id": "WFR_kwLOJQSlzc8AAAABET9yOA",
    "path": ".github/workflows/gcc.yml",
    "previous_attempt_url": null,
    "pull_requests": [],
    "referenced_workflows": [],
    "repository": {
      "archive_url": "https://api.github.com/repos/AMReX-Codes/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/AMReX-Codes/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/AMReX-Codes/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/AMReX-Codes/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/AMReX-Codes/test_ci/downloads",
      "events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/events",
      "fork": false,
      "forks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/forks",
      "full_name": "AMReX-Codes/test_ci",
      "git_commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/hooks",
      "html_url": "https://github.com/AMReX-Codes/test_ci",
      "id": 621061581,
      "issue_comment_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/AMReX-Codes/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/AMReX-Codes/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/AMReX-Codes/test_ci/languages",
      "merges_url": "https://api.github.com/repos/AMReX-Codes/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/AMReX-Codes/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQSlzQ",
      "notifications_url": "https://api.github.com/repos/AMReX-Codes/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
        "events_url": "https://api.github.com/users/AMReX-Codes/events{/privacy}",
        "followers_url": "https://api.github.com/users/AMReX-Codes/followers",
        "following_url": "https://api.github.com/users/AMReX-Codes/following{/other_user}",
        "gists_url": "https://api.github.com/users/AMReX-Codes/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/AMReX-Codes",
        "id": 25084337,
        "login": "AMReX-Codes",
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
        "organizations_url": "https://api.github.com/users/AMReX-Codes/orgs",
        "received_events_url": "https://api.github.com/users/AMReX-Codes/received_events",
        "repos_url": "https://api.github.com/users/AMReX-Codes/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/AMReX-Codes/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/AMReX-Codes/subscriptions",
        "type": "Organization",
        "url": "https://api.github.com/users/AMReX-Codes"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/AMReX-Codes/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/AMReX-Codes/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/AMReX-Codes/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/tags",
      "teams_url": "https://api.github.com/repos/AMReX-Codes/test_ci/teams",
      "trees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/AMReX-Codes/test_ci"
    },
    "rerun_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584337976/rerun",
    "run_attempt": 1,
    "run_number": 53,
    "run_started_at": "2023-04-01T17:17:57Z",
    "status": "completed",
    "triggering_actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "updated_at": "2023-04-01T17:18:26Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584337976",
    "workflow_id": 52767392,
    "workflow_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/workflows/52767392"
  }
}
```
</details>

### Closing a pull request from a feature branch on a fork

This will trigger the CleanupCachePostPR workflow to run on the default
branch of the main repo. It will remove all the caches associated with the
PR.

<details>
  <summary>Information of CleanupCachePostPR workflow</summary>

```
github.ref = refs/heads/main
github.head_ref = refs/heads/main
github.event =
{
  "action": "completed",
  "organization": {
    "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
    "description": "AMReX-Codes: Block-Structured AMR Software Framework and Applications",
    "events_url": "https://api.github.com/orgs/AMReX-Codes/events",
    "hooks_url": "https://api.github.com/orgs/AMReX-Codes/hooks",
    "id": 25084337,
    "issues_url": "https://api.github.com/orgs/AMReX-Codes/issues",
    "login": "AMReX-Codes",
    "members_url": "https://api.github.com/orgs/AMReX-Codes/members{/member}",
    "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
    "public_members_url": "https://api.github.com/orgs/AMReX-Codes/public_members{/member}",
    "repos_url": "https://api.github.com/orgs/AMReX-Codes/repos",
    "url": "https://api.github.com/orgs/AMReX-Codes"
  },
  "repository": {
    "allow_forking": true,
    "archive_url": "https://api.github.com/repos/AMReX-Codes/test_ci/{archive_format}{/ref}",
    "archived": false,
    "assignees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/assignees{/user}",
    "blobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/blobs{/sha}",
    "branches_url": "https://api.github.com/repos/AMReX-Codes/test_ci/branches{/branch}",
    "clone_url": "https://github.com/AMReX-Codes/test_ci.git",
    "collaborators_url": "https://api.github.com/repos/AMReX-Codes/test_ci/collaborators{/collaborator}",
    "comments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/comments{/number}",
    "commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/commits{/sha}",
    "compare_url": "https://api.github.com/repos/AMReX-Codes/test_ci/compare/{base}...{head}",
    "contents_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contents/{+path}",
    "contributors_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contributors",
    "created_at": "2023-03-29T23:11:15Z",
    "default_branch": "main",
    "deployments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/deployments",
    "description": null,
    "disabled": false,
    "downloads_url": "https://api.github.com/repos/AMReX-Codes/test_ci/downloads",
    "events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/events",
    "fork": false,
    "forks": 1,
    "forks_count": 1,
    "forks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/forks",
    "full_name": "AMReX-Codes/test_ci",
    "git_commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/commits{/sha}",
    "git_refs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/refs{/sha}",
    "git_tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/tags{/sha}",
    "git_url": "git://github.com/AMReX-Codes/test_ci.git",
    "has_discussions": false,
    "has_downloads": true,
    "has_issues": true,
    "has_pages": false,
    "has_projects": true,
    "has_wiki": true,
    "homepage": null,
    "hooks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/hooks",
    "html_url": "https://github.com/AMReX-Codes/test_ci",
    "id": 621061581,
    "is_template": false,
    "issue_comment_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/comments{/number}",
    "issue_events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/events{/number}",
    "issues_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues{/number}",
    "keys_url": "https://api.github.com/repos/AMReX-Codes/test_ci/keys{/key_id}",
    "labels_url": "https://api.github.com/repos/AMReX-Codes/test_ci/labels{/name}",
    "language": "C++",
    "languages_url": "https://api.github.com/repos/AMReX-Codes/test_ci/languages",
    "license": {
      "key": "bsd-3-clause",
      "name": "BSD 3-Clause \"New\" or \"Revised\" License",
      "node_id": "MDc6TGljZW5zZTU=",
      "spdx_id": "BSD-3-Clause",
      "url": "https://api.github.com/licenses/bsd-3-clause"
    },
    "merges_url": "https://api.github.com/repos/AMReX-Codes/test_ci/merges",
    "milestones_url": "https://api.github.com/repos/AMReX-Codes/test_ci/milestones{/number}",
    "mirror_url": null,
    "name": "test_ci",
    "node_id": "R_kgDOJQSlzQ",
    "notifications_url": "https://api.github.com/repos/AMReX-Codes/test_ci/notifications{?since,all,participating}",
    "open_issues": 0,
    "open_issues_count": 0,
    "owner": {
      "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
      "events_url": "https://api.github.com/users/AMReX-Codes/events{/privacy}",
      "followers_url": "https://api.github.com/users/AMReX-Codes/followers",
      "following_url": "https://api.github.com/users/AMReX-Codes/following{/other_user}",
      "gists_url": "https://api.github.com/users/AMReX-Codes/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/AMReX-Codes",
      "id": 25084337,
      "login": "AMReX-Codes",
      "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
      "organizations_url": "https://api.github.com/users/AMReX-Codes/orgs",
      "received_events_url": "https://api.github.com/users/AMReX-Codes/received_events",
      "repos_url": "https://api.github.com/users/AMReX-Codes/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/AMReX-Codes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AMReX-Codes/subscriptions",
      "type": "Organization",
      "url": "https://api.github.com/users/AMReX-Codes"
    },
    "private": false,
    "pulls_url": "https://api.github.com/repos/AMReX-Codes/test_ci/pulls{/number}",
    "pushed_at": "2023-04-01T17:44:50Z",
    "releases_url": "https://api.github.com/repos/AMReX-Codes/test_ci/releases{/id}",
    "size": 27,
    "ssh_url": "git@github.com:AMReX-Codes/test_ci.git",
    "stargazers_count": 0,
    "stargazers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/stargazers",
    "statuses_url": "https://api.github.com/repos/AMReX-Codes/test_ci/statuses/{sha}",
    "subscribers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscribers",
    "subscription_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscription",
    "svn_url": "https://github.com/AMReX-Codes/test_ci",
    "tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/tags",
    "teams_url": "https://api.github.com/repos/AMReX-Codes/test_ci/teams",
    "topics": [],
    "trees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/trees{/sha}",
    "updated_at": "2023-03-29T23:32:27Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci",
    "visibility": "public",
    "watchers": 0,
    "watchers_count": 0,
    "web_commit_signoff_required": false
  },
  "sender": {
    "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
    "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
    "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
    "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
    "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/WeiqunZhang",
    "id": 7862753,
    "login": "WeiqunZhang",
    "node_id": "MDQ6VXNlcjc4NjI3NTM=",
    "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
    "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
    "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/WeiqunZhang"
  },
  "workflow": {
    "badge_url": "https://github.com/AMReX-Codes/test_ci/workflows/PostPR/badge.svg",
    "created_at": "2023-03-30T18:51:44.000Z",
    "html_url": "https://github.com/AMReX-Codes/test_ci/blob/main/.github/workflows/post-pr.yml",
    "id": 52867039,
    "name": "PostPR",
    "node_id": "W_kwDOJQSlzc4DJq_f",
    "path": ".github/workflows/post-pr.yml",
    "state": "active",
    "updated_at": "2023-03-30T19:16:16.000Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/workflows/52867039"
  },
  "workflow_run": {
    "actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "artifacts_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584442986/artifacts",
    "cancel_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584442986/cancel",
    "check_suite_id": 11964804514,
    "check_suite_node_id": "CS_kwDOJQSlzc8AAAACyShtog",
    "check_suite_url": "https://api.github.com/repos/AMReX-Codes/test_ci/check-suites/11964804514",
    "conclusion": "success",
    "created_at": "2023-04-01T17:46:18Z",
    "display_title": "another minor change on the feature branch",
    "event": "pull_request",
    "head_branch": "feature",
    "head_commit": {
      "author": {
        "email": "weiqunzhang@lbl.gov",
        "name": "Weiqun Zhang"
      },
      "committer": {
        "email": "weiqunzhang@lbl.gov",
        "name": "Weiqun Zhang"
      },
      "id": "937a47a762975538160014a7981687ce7f95910c",
      "message": "another minor change on the feature branch",
      "timestamp": "2023-04-01T17:34:14Z",
      "tree_id": "981672f4d4f4e2dbf23d2686f49cb727114fdb23"
    },
    "head_repository": {
      "archive_url": "https://api.github.com/repos/WeiqunZhang/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/WeiqunZhang/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/WeiqunZhang/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/WeiqunZhang/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/WeiqunZhang/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/WeiqunZhang/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/WeiqunZhang/test_ci/downloads",
      "events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/events",
      "fork": true,
      "forks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/forks",
      "full_name": "WeiqunZhang/test_ci",
      "git_commits_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/WeiqunZhang/test_ci/hooks",
      "html_url": "https://github.com/WeiqunZhang/test_ci",
      "id": 621066743,
      "issue_comment_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/WeiqunZhang/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/WeiqunZhang/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/WeiqunZhang/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/WeiqunZhang/test_ci/languages",
      "merges_url": "https://api.github.com/repos/WeiqunZhang/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/WeiqunZhang/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQS59w",
      "notifications_url": "https://api.github.com/repos/WeiqunZhang/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
        "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
        "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
        "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
        "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/WeiqunZhang",
        "id": 7862753,
        "login": "WeiqunZhang",
        "node_id": "MDQ6VXNlcjc4NjI3NTM=",
        "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
        "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
        "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/WeiqunZhang"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/WeiqunZhang/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/WeiqunZhang/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/WeiqunZhang/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/WeiqunZhang/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/WeiqunZhang/test_ci/tags",
      "teams_url": "https://api.github.com/repos/WeiqunZhang/test_ci/teams",
      "trees_url": "https://api.github.com/repos/WeiqunZhang/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/WeiqunZhang/test_ci"
    },
    "head_sha": "937a47a762975538160014a7981687ce7f95910c",
    "html_url": "https://github.com/AMReX-Codes/test_ci/actions/runs/4584442986",
    "id": 4584442986,
    "jobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584442986/jobs",
    "logs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584442986/logs",
    "name": "PostPR",
    "node_id": "WFR_kwLOJQSlzc8AAAABEUEMag",
    "path": ".github/workflows/post-pr.yml",
    "previous_attempt_url": null,
    "pull_requests": [],
    "referenced_workflows": [],
    "repository": {
      "archive_url": "https://api.github.com/repos/AMReX-Codes/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/AMReX-Codes/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/AMReX-Codes/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/AMReX-Codes/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/AMReX-Codes/test_ci/downloads",
      "events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/events",
      "fork": false,
      "forks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/forks",
      "full_name": "AMReX-Codes/test_ci",
      "git_commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/hooks",
      "html_url": "https://github.com/AMReX-Codes/test_ci",
      "id": 621061581,
      "issue_comment_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/AMReX-Codes/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/AMReX-Codes/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/AMReX-Codes/test_ci/languages",
      "merges_url": "https://api.github.com/repos/AMReX-Codes/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/AMReX-Codes/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQSlzQ",
      "notifications_url": "https://api.github.com/repos/AMReX-Codes/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
        "events_url": "https://api.github.com/users/AMReX-Codes/events{/privacy}",
        "followers_url": "https://api.github.com/users/AMReX-Codes/followers",
        "following_url": "https://api.github.com/users/AMReX-Codes/following{/other_user}",
        "gists_url": "https://api.github.com/users/AMReX-Codes/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/AMReX-Codes",
        "id": 25084337,
        "login": "AMReX-Codes",
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
        "organizations_url": "https://api.github.com/users/AMReX-Codes/orgs",
        "received_events_url": "https://api.github.com/users/AMReX-Codes/received_events",
        "repos_url": "https://api.github.com/users/AMReX-Codes/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/AMReX-Codes/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/AMReX-Codes/subscriptions",
        "type": "Organization",
        "url": "https://api.github.com/users/AMReX-Codes"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/AMReX-Codes/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/AMReX-Codes/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/AMReX-Codes/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/tags",
      "teams_url": "https://api.github.com/repos/AMReX-Codes/test_ci/teams",
      "trees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/AMReX-Codes/test_ci"
    },
    "rerun_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584442986/rerun",
    "run_attempt": 1,
    "run_number": 5,
    "run_started_at": "2023-04-01T17:46:18Z",
    "status": "completed",
    "triggering_actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "updated_at": "2023-04-01T17:46:30Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584442986",
    "workflow_id": 52867039,
    "workflow_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/workflows/52867039"
  }
}
```
</details>

### Merging a pull request from a feature branch on a fork

The merge closes the PR and therefore triggers the CleanupCachePostPR
workflow. The merge will also update the default branch on the main
repo. This is considered a push event even though it's not pushed by a
normal user. So this will trigger all the push triggerable workflows (e.g.,
cuda.yml), which will in turn trigger the CleanupCache workflow.

<details>
  <summary>Information of CleanupCache workflow</summary>

```
github.ref = refs/heads/main
github.head_ref = refs/heads/main
github.event =
{
  "action": "completed",
  "organization": {
    "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
    "description": "AMReX-Codes: Block-Structured AMR Software Framework and Applications",
    "events_url": "https://api.github.com/orgs/AMReX-Codes/events",
    "hooks_url": "https://api.github.com/orgs/AMReX-Codes/hooks",
    "id": 25084337,
    "issues_url": "https://api.github.com/orgs/AMReX-Codes/issues",
    "login": "AMReX-Codes",
    "members_url": "https://api.github.com/orgs/AMReX-Codes/members{/member}",
    "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
    "public_members_url": "https://api.github.com/orgs/AMReX-Codes/public_members{/member}",
    "repos_url": "https://api.github.com/orgs/AMReX-Codes/repos",
    "url": "https://api.github.com/orgs/AMReX-Codes"
  },
  "repository": {
    "allow_forking": true,
    "archive_url": "https://api.github.com/repos/AMReX-Codes/test_ci/{archive_format}{/ref}",
    "archived": false,
    "assignees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/assignees{/user}",
    "blobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/blobs{/sha}",
    "branches_url": "https://api.github.com/repos/AMReX-Codes/test_ci/branches{/branch}",
    "clone_url": "https://github.com/AMReX-Codes/test_ci.git",
    "collaborators_url": "https://api.github.com/repos/AMReX-Codes/test_ci/collaborators{/collaborator}",
    "comments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/comments{/number}",
    "commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/commits{/sha}",
    "compare_url": "https://api.github.com/repos/AMReX-Codes/test_ci/compare/{base}...{head}",
    "contents_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contents/{+path}",
    "contributors_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contributors",
    "created_at": "2023-03-29T23:11:15Z",
    "default_branch": "main",
    "deployments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/deployments",
    "description": null,
    "disabled": false,
    "downloads_url": "https://api.github.com/repos/AMReX-Codes/test_ci/downloads",
    "events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/events",
    "fork": false,
    "forks": 1,
    "forks_count": 1,
    "forks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/forks",
    "full_name": "AMReX-Codes/test_ci",
    "git_commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/commits{/sha}",
    "git_refs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/refs{/sha}",
    "git_tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/tags{/sha}",
    "git_url": "git://github.com/AMReX-Codes/test_ci.git",
    "has_discussions": false,
    "has_downloads": true,
    "has_issues": true,
    "has_pages": false,
    "has_projects": true,
    "has_wiki": true,
    "homepage": null,
    "hooks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/hooks",
    "html_url": "https://github.com/AMReX-Codes/test_ci",
    "id": 621061581,
    "is_template": false,
    "issue_comment_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/comments{/number}",
    "issue_events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/events{/number}",
    "issues_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues{/number}",
    "keys_url": "https://api.github.com/repos/AMReX-Codes/test_ci/keys{/key_id}",
    "labels_url": "https://api.github.com/repos/AMReX-Codes/test_ci/labels{/name}",
    "language": "C++",
    "languages_url": "https://api.github.com/repos/AMReX-Codes/test_ci/languages",
    "license": {
      "key": "bsd-3-clause",
      "name": "BSD 3-Clause \"New\" or \"Revised\" License",
      "node_id": "MDc6TGljZW5zZTU=",
      "spdx_id": "BSD-3-Clause",
      "url": "https://api.github.com/licenses/bsd-3-clause"
    },
    "merges_url": "https://api.github.com/repos/AMReX-Codes/test_ci/merges",
    "milestones_url": "https://api.github.com/repos/AMReX-Codes/test_ci/milestones{/number}",
    "mirror_url": null,
    "name": "test_ci",
    "node_id": "R_kgDOJQSlzQ",
    "notifications_url": "https://api.github.com/repos/AMReX-Codes/test_ci/notifications{?since,all,participating}",
    "open_issues": 0,
    "open_issues_count": 0,
    "owner": {
      "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
      "events_url": "https://api.github.com/users/AMReX-Codes/events{/privacy}",
      "followers_url": "https://api.github.com/users/AMReX-Codes/followers",
      "following_url": "https://api.github.com/users/AMReX-Codes/following{/other_user}",
      "gists_url": "https://api.github.com/users/AMReX-Codes/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/AMReX-Codes",
      "id": 25084337,
      "login": "AMReX-Codes",
      "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
      "organizations_url": "https://api.github.com/users/AMReX-Codes/orgs",
      "received_events_url": "https://api.github.com/users/AMReX-Codes/received_events",
      "repos_url": "https://api.github.com/users/AMReX-Codes/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/AMReX-Codes/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/AMReX-Codes/subscriptions",
      "type": "Organization",
      "url": "https://api.github.com/users/AMReX-Codes"
    },
    "private": false,
    "pulls_url": "https://api.github.com/repos/AMReX-Codes/test_ci/pulls{/number}",
    "pushed_at": "2023-04-01T17:54:37Z",
    "releases_url": "https://api.github.com/repos/AMReX-Codes/test_ci/releases{/id}",
    "size": 27,
    "ssh_url": "git@github.com:AMReX-Codes/test_ci.git",
    "stargazers_count": 0,
    "stargazers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/stargazers",
    "statuses_url": "https://api.github.com/repos/AMReX-Codes/test_ci/statuses/{sha}",
    "subscribers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscribers",
    "subscription_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscription",
    "svn_url": "https://github.com/AMReX-Codes/test_ci",
    "tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/tags",
    "teams_url": "https://api.github.com/repos/AMReX-Codes/test_ci/teams",
    "topics": [],
    "trees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/trees{/sha}",
    "updated_at": "2023-03-29T23:32:27Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci",
    "visibility": "public",
    "watchers": 0,
    "watchers_count": 0,
    "web_commit_signoff_required": false
  },
  "sender": {
    "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
    "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
    "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
    "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
    "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
    "gravatar_id": "",
    "html_url": "https://github.com/WeiqunZhang",
    "id": 7862753,
    "login": "WeiqunZhang",
    "node_id": "MDQ6VXNlcjc4NjI3NTM=",
    "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
    "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
    "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
    "site_admin": false,
    "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
    "type": "User",
    "url": "https://api.github.com/users/WeiqunZhang"
  },
  "workflow": {
    "badge_url": "https://github.com/AMReX-Codes/test_ci/workflows/Clang/badge.svg",
    "created_at": "2023-03-29T23:32:25.000Z",
    "html_url": "https://github.com/AMReX-Codes/test_ci/blob/main/.github/workflows/clang.yml",
    "id": 52767391,
    "name": "Clang",
    "node_id": "W_kwDOJQSlzc4DJSqf",
    "path": ".github/workflows/clang.yml",
    "state": "active",
    "updated_at": "2023-03-30T17:04:11.000Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/workflows/52767391"
  },
  "workflow_run": {
    "actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "artifacts_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584469723/artifacts",
    "cancel_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584469723/cancel",
    "check_suite_id": 11964859542,
    "check_suite_node_id": "CS_kwDOJQSlzc8AAAACySlElg",
    "check_suite_url": "https://api.github.com/repos/AMReX-Codes/test_ci/check-suites/11964859542",
    "conclusion": "success",
    "created_at": "2023-04-01T17:54:40Z",
    "display_title": "Merge pull request #9 from WeiqunZhang/feature",
    "event": "push",
    "head_branch": "main",
    "head_commit": {
      "author": {
        "email": "WeiqunZhang@lbl.gov",
        "name": "Weiqun Zhang"
      },
      "committer": {
        "email": "noreply@github.com",
        "name": "GitHub"
      },
      "id": "019bb8571e19f01c2afa4a06885c60fa75983d10",
      "message": "Merge pull request #9 from WeiqunZhang/feature\n\nanother minor change on the feature branch",
      "timestamp": "2023-04-01T17:54:37Z",
      "tree_id": "981672f4d4f4e2dbf23d2686f49cb727114fdb23"
    },
    "head_repository": {
      "archive_url": "https://api.github.com/repos/AMReX-Codes/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/AMReX-Codes/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/AMReX-Codes/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/AMReX-Codes/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/AMReX-Codes/test_ci/downloads",
      "events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/events",
      "fork": false,
      "forks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/forks",
      "full_name": "AMReX-Codes/test_ci",
      "git_commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/hooks",
      "html_url": "https://github.com/AMReX-Codes/test_ci",
      "id": 621061581,
      "issue_comment_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/AMReX-Codes/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/AMReX-Codes/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/AMReX-Codes/test_ci/languages",
      "merges_url": "https://api.github.com/repos/AMReX-Codes/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/AMReX-Codes/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQSlzQ",
      "notifications_url": "https://api.github.com/repos/AMReX-Codes/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
        "events_url": "https://api.github.com/users/AMReX-Codes/events{/privacy}",
        "followers_url": "https://api.github.com/users/AMReX-Codes/followers",
        "following_url": "https://api.github.com/users/AMReX-Codes/following{/other_user}",
        "gists_url": "https://api.github.com/users/AMReX-Codes/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/AMReX-Codes",
        "id": 25084337,
        "login": "AMReX-Codes",
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
        "organizations_url": "https://api.github.com/users/AMReX-Codes/orgs",
        "received_events_url": "https://api.github.com/users/AMReX-Codes/received_events",
        "repos_url": "https://api.github.com/users/AMReX-Codes/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/AMReX-Codes/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/AMReX-Codes/subscriptions",
        "type": "Organization",
        "url": "https://api.github.com/users/AMReX-Codes"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/AMReX-Codes/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/AMReX-Codes/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/AMReX-Codes/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/tags",
      "teams_url": "https://api.github.com/repos/AMReX-Codes/test_ci/teams",
      "trees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/AMReX-Codes/test_ci"
    },
    "head_sha": "019bb8571e19f01c2afa4a06885c60fa75983d10",
    "html_url": "https://github.com/AMReX-Codes/test_ci/actions/runs/4584469723",
    "id": 4584469723,
    "jobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584469723/jobs",
    "logs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584469723/logs",
    "name": "Clang",
    "node_id": "WFR_kwLOJQSlzc8AAAABEUF02w",
    "path": ".github/workflows/clang.yml",
    "previous_attempt_url": null,
    "pull_requests": [],
    "referenced_workflows": [],
    "repository": {
      "archive_url": "https://api.github.com/repos/AMReX-Codes/test_ci/{archive_format}{/ref}",
      "assignees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/assignees{/user}",
      "blobs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/blobs{/sha}",
      "branches_url": "https://api.github.com/repos/AMReX-Codes/test_ci/branches{/branch}",
      "collaborators_url": "https://api.github.com/repos/AMReX-Codes/test_ci/collaborators{/collaborator}",
      "comments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/comments{/number}",
      "commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/commits{/sha}",
      "compare_url": "https://api.github.com/repos/AMReX-Codes/test_ci/compare/{base}...{head}",
      "contents_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contents/{+path}",
      "contributors_url": "https://api.github.com/repos/AMReX-Codes/test_ci/contributors",
      "deployments_url": "https://api.github.com/repos/AMReX-Codes/test_ci/deployments",
      "description": null,
      "downloads_url": "https://api.github.com/repos/AMReX-Codes/test_ci/downloads",
      "events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/events",
      "fork": false,
      "forks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/forks",
      "full_name": "AMReX-Codes/test_ci",
      "git_commits_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/commits{/sha}",
      "git_refs_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/refs{/sha}",
      "git_tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/tags{/sha}",
      "hooks_url": "https://api.github.com/repos/AMReX-Codes/test_ci/hooks",
      "html_url": "https://github.com/AMReX-Codes/test_ci",
      "id": 621061581,
      "issue_comment_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/comments{/number}",
      "issue_events_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues/events{/number}",
      "issues_url": "https://api.github.com/repos/AMReX-Codes/test_ci/issues{/number}",
      "keys_url": "https://api.github.com/repos/AMReX-Codes/test_ci/keys{/key_id}",
      "labels_url": "https://api.github.com/repos/AMReX-Codes/test_ci/labels{/name}",
      "languages_url": "https://api.github.com/repos/AMReX-Codes/test_ci/languages",
      "merges_url": "https://api.github.com/repos/AMReX-Codes/test_ci/merges",
      "milestones_url": "https://api.github.com/repos/AMReX-Codes/test_ci/milestones{/number}",
      "name": "test_ci",
      "node_id": "R_kgDOJQSlzQ",
      "notifications_url": "https://api.github.com/repos/AMReX-Codes/test_ci/notifications{?since,all,participating}",
      "owner": {
        "avatar_url": "https://avatars.githubusercontent.com/u/25084337?v=4",
        "events_url": "https://api.github.com/users/AMReX-Codes/events{/privacy}",
        "followers_url": "https://api.github.com/users/AMReX-Codes/followers",
        "following_url": "https://api.github.com/users/AMReX-Codes/following{/other_user}",
        "gists_url": "https://api.github.com/users/AMReX-Codes/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/AMReX-Codes",
        "id": 25084337,
        "login": "AMReX-Codes",
        "node_id": "MDEyOk9yZ2FuaXphdGlvbjI1MDg0MzM3",
        "organizations_url": "https://api.github.com/users/AMReX-Codes/orgs",
        "received_events_url": "https://api.github.com/users/AMReX-Codes/received_events",
        "repos_url": "https://api.github.com/users/AMReX-Codes/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/AMReX-Codes/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/AMReX-Codes/subscriptions",
        "type": "Organization",
        "url": "https://api.github.com/users/AMReX-Codes"
      },
      "private": false,
      "pulls_url": "https://api.github.com/repos/AMReX-Codes/test_ci/pulls{/number}",
      "releases_url": "https://api.github.com/repos/AMReX-Codes/test_ci/releases{/id}",
      "stargazers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/stargazers",
      "statuses_url": "https://api.github.com/repos/AMReX-Codes/test_ci/statuses/{sha}",
      "subscribers_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscribers",
      "subscription_url": "https://api.github.com/repos/AMReX-Codes/test_ci/subscription",
      "tags_url": "https://api.github.com/repos/AMReX-Codes/test_ci/tags",
      "teams_url": "https://api.github.com/repos/AMReX-Codes/test_ci/teams",
      "trees_url": "https://api.github.com/repos/AMReX-Codes/test_ci/git/trees{/sha}",
      "url": "https://api.github.com/repos/AMReX-Codes/test_ci"
    },
    "rerun_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584469723/rerun",
    "run_attempt": 1,
    "run_number": 57,
    "run_started_at": "2023-04-01T17:54:40Z",
    "status": "completed",
    "triggering_actor": {
      "avatar_url": "https://avatars.githubusercontent.com/u/7862753?v=4",
      "events_url": "https://api.github.com/users/WeiqunZhang/events{/privacy}",
      "followers_url": "https://api.github.com/users/WeiqunZhang/followers",
      "following_url": "https://api.github.com/users/WeiqunZhang/following{/other_user}",
      "gists_url": "https://api.github.com/users/WeiqunZhang/gists{/gist_id}",
      "gravatar_id": "",
      "html_url": "https://github.com/WeiqunZhang",
      "id": 7862753,
      "login": "WeiqunZhang",
      "node_id": "MDQ6VXNlcjc4NjI3NTM=",
      "organizations_url": "https://api.github.com/users/WeiqunZhang/orgs",
      "received_events_url": "https://api.github.com/users/WeiqunZhang/received_events",
      "repos_url": "https://api.github.com/users/WeiqunZhang/repos",
      "site_admin": false,
      "starred_url": "https://api.github.com/users/WeiqunZhang/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/WeiqunZhang/subscriptions",
      "type": "User",
      "url": "https://api.github.com/users/WeiqunZhang"
    },
    "updated_at": "2023-04-01T17:55:18Z",
    "url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/runs/4584469723",
    "workflow_id": 52767391,
    "workflow_url": "https://api.github.com/repos/AMReX-Codes/test_ci/actions/workflows/52767391"
  }
}
```
</details>


#
# First, define the library we want to add
# Think of this as a constructor for object "amrex"
# In the following, we will use setters to change
# the properties of this object, like setting the sources,
# setting the compile definitions and so on
#
foreach(D IN LISTS AMReX_SPACEDIM)
    if (AMReX_BUILD_SHARED_LIBS)
        add_library(amrex_${D}d SHARED)
    else ()
        add_library(amrex_${D}d STATIC)
    endif ()
    add_library(AMReX::amrex_${D}d ALIAS amrex_${D}d)
endforeach()

#
# alias: last element will be legacy target
#
list(LENGTH AMReX_SPACEDIM list_len)
if(list_len EQUAL 0)
    message(FATAL_ERROR "AMReX_SPACEDIM cannot be empty! Provide a ;-separated LIST or single value!")
endif()
math(EXPR list_last "${list_len} - 1")
list(GET AMReX_SPACEDIM ${list_last} AMReX_SPACEDIM_LAST)
add_library(amrex ALIAS amrex_${AMReX_SPACEDIM_LAST}d)
add_library(AMReX::amrex ALIAS amrex_${AMReX_SPACEDIM_LAST}d)

# legacy symlink for build directory: libamrex.[so|a] / amrex.[dll.lib]
add_custom_command(TARGET amrex_${AMReX_SPACEDIM_LAST}d POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E create_symlink
        $<TARGET_FILE_NAME:amrex_${AMReX_SPACEDIM_LAST}d>
        $<TARGET_FILE_DIR:amrex_${AMReX_SPACEDIM_LAST}d>/$<TARGET_FILE_PREFIX:amrex_${AMReX_SPACEDIM_LAST}d>amrex$<TARGET_FILE_SUFFIX:amrex_${AMReX_SPACEDIM_LAST}d>
)


#
# Setup parallel backends (any type: inter/intra-node)
#
include(AMReXParallelBackends)

#
# Add definitions
#
include(AMReXSetDefines)

#
# Find and link third party libraries if needed
#
include(AMReXThirdPartyLibraries)

# Where to store Fortran modules
if (CMAKE_Fortran_COMPILER_LOADED)
    foreach(D IN LISTS AMReX_SPACEDIM)
        set_target_properties(amrex_${D}d
          PROPERTIES
          Fortran_MODULE_DIRECTORY
          ${PROJECT_BINARY_DIR}/mod_files_${D}d
          INTERFACE_INCLUDE_DIRECTORIES
          $<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/mod_files_${D}d>
          )
    endforeach()
endif ()

# Load Flags targets and use them if no user-defined flags is given
include(AMReXFlagsTargets)

foreach(D IN LISTS AMReX_SPACEDIM)
    if (CMAKE_Fortran_COMPILER_LOADED AND (NOT CMAKE_Fortran_FLAGS) )
       target_link_libraries(amrex_${D}d
          PUBLIC
          $<BUILD_INTERFACE:Flags_Fortran>
          )
    endif ()

    if (NOT CMAKE_CXX_FLAGS)
       target_link_libraries(amrex_${D}d
          PUBLIC
          $<BUILD_INTERFACE:Flags_CXX>
          )
    endif ()

    if (AMReX_FPE)
       target_link_libraries(amrex_${D}d
          PUBLIC
          $<BUILD_INTERFACE:Flags_FPE>
          )
    endif ()
endforeach()

# General configuration
include( AMReX_Config )
foreach(D IN LISTS AMReX_SPACEDIM)
    configure_amrex(amrex_${D}d)
endforeach()

#
# Core components
#
add_subdirectory(Base)
add_subdirectory(Boundary)
add_subdirectory(AmrCore)

#
# Optional components
#
if (AMReX_AMRLEVEL)
   add_subdirectory(Amr)
endif ()

if (AMReX_EB)
   if (  AMReX_CUDA AND
         ( CMAKE_CUDA_COMPILER_VERSION VERSION_GREATER_EQUAL 9.2) AND
         ( CMAKE_CUDA_COMPILER_VERSION VERSION_LESS 9.3)  )
      message(FATAL_ERROR "EB component of AMReX is not compatible with CUDA 9.2")
   endif ()
   add_subdirectory(EB)
endif ()

if (AMReX_LINEAR_SOLVERS)
   add_subdirectory(LinearSolvers)
endif ()

if (AMReX_FORTRAN_INTERFACES)
   add_subdirectory(F_Interfaces)
endif ()

if (AMReX_PARTICLES)
   add_subdirectory(Particle)
endif ()

#
# Optional external components
#
if (AMReX_AMRDATA)
   add_subdirectory(Extern/amrdata)
endif()

if (AMReX_PROFPARSER)
    #
    # Generate BLProfParser.tab.H, BLProfParser.tab.cpp and
    # BLProfParser.lex.yy.cpp
    # Must be done here where targets "amrex_${D}d" are defined because
    # add_custom_command create rules which are seen only within the scope
    # from which add_custom_command is called
    #
    set(_dir ${CMAKE_CURRENT_LIST_DIR}/Extern/ProfParser)
    set(_odir ${CMAKE_CURRENT_BINARY_DIR})
    add_custom_command(
        OUTPUT  ${_dir}/BLProfParser.tab.cpp ${_dir}/BLProfParser.tab.H
        COMMAND cat   BLProfParser.y $(SED0) $(SED1) > BLProfParserNC.y
        COMMAND bison --defines=BLProfParser.tab.H
        --output=BLProfParser.tab.cpp BLProfParserNC.y
        COMMAND rm    BLProfParserNC.y
        DEPENDS ${_dir}/BLProfParser.y
        WORKING_DIRECTORY ${_dir}
        COMMENT "Generating BLProfParser.tab.H and BLProfParser.tab.cpp" )

    add_custom_command(
        OUTPUT ${_dir}/BLProfParser.lex.yy.cpp
        COMMAND flex --outfile=${_dir}/BLProfParser.lex.yy.cpp BLProfParser.l
        DEPENDS ${_dir}/BLProfParser.l
        WORKING_DIRECTORY ${_dir}
        COMMENT "Generating BLProfParser.lex.yy.cpp" )

    foreach(D IN LISTS AMReX_SPACEDIM)
        target_sources(amrex_${D}d
            PRIVATE
            ${_dir}/BLProfParser.tab.cpp
            ${_dir}/BLProfParser.lex.yy.cpp
            ${_dir}/BLProfParser.tab.H
            )
        unset(_dir)
    endforeach()

    add_subdirectory(Extern/ProfParser)
endif ()

if (AMReX_SENSEI)
   add_subdirectory(Extern/SENSEI)
endif ()

if (AMReX_CONDUIT OR AMReX_ASCENT)
   add_subdirectory(Extern/Conduit)
endif ()

if (AMReX_HYPRE OR AMReX_PETSC)
   add_subdirectory(Extern/HYPRE)
endif ()

if (AMReX_PETSC)
   add_subdirectory(Extern/PETSc)
endif ()

if (AMReX_SUNDIALS)
   add_subdirectory(Extern/SUNDIALS)
endif ()

if (AMReX_HDF5)
   add_subdirectory(Extern/HDF5)
endif ()

#
# Print out summary -- do it here so we already linked all
# libs at this point
#
print_amrex_configuration_summary ()

#
# Make all headers as PUBLIC HEADERS so that they get installed
#
foreach(D IN LISTS AMReX_SPACEDIM)
    get_target_property(AMREX_SOURCES amrex_${D}d SOURCES)

    set(AMREX_PUBLIC_HEADERS ${AMREX_SOURCES})
    list(FILTER AMREX_PUBLIC_HEADERS INCLUDE REGEX "\\.H")
    set_target_properties(amrex_${D}d PROPERTIES PUBLIC_HEADER "${AMREX_PUBLIC_HEADERS}")
endforeach()

#
# If AMReX_CUDA, C++ files will be compiled as CUDA sources
#
if (AMReX_CUDA)
    foreach(D IN LISTS AMReX_SPACEDIM)
        setup_target_for_cuda_compilation(amrex_${D}d)
    endforeach()
endif ()

#
# Generate config header
#
include(AMReXGenerateConfigHeader)
generate_config_header()

#
# Static Analysis
#
include(AMReXClangTidy)
if (AMReX_CLANG_TIDY)
   setup_clang_tidy()
endif()


add_amrex_define(AMREX_USE_HYPRE NO_LEGACY NO_1D IF AMReX_HYPRE)

foreach(D IN LISTS AMReX_SPACEDIM)
    if (D EQUAL 1)
        message(WARNING "HYPRE interfaces are not supported for 1D builds (skipping)")
        continue()
    endif ()

    #
    # This file gets processed if either AMReX_PETSC or AMReX_HYPRE are ON
    # If only AMReX_PETSC is ON, we just need to include this directory
    # and a couple of files to the build.
    #
    target_include_directories(amrex_${D}d
       PUBLIC
       $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    if (NOT AMReX_HYPRE) # only AMReX_PETSC is active

       target_sources(amrex_${D}d
          PRIVATE
          AMReX_Habec_${D}D_K.H
          AMReX_Habec_K.H
          )

    else ()

       target_sources(amrex_${D}d
          PRIVATE
          AMReX_HypreABecLap.cpp
          AMReX_HypreABecLap.H
          AMReX_HypreABecLap2.cpp
          AMReX_HypreABecLap2.H
          AMReX_HypreABecLap3.cpp
          AMReX_HypreABecLap2.H
          AMReX_Hypre.cpp
          AMReX_Hypre.H
          AMReX_Habec_${D}D_K.H
          AMReX_Habec_K.H
          AMReX_HypreNodeLap.cpp
          AMReX_HypreNodeLap.H
          AMReX_HypreIJIface.cpp
          AMReX_HypreIJIface.H
          AMReX_HypreSolver.H
          )

    endif ()
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d
       PUBLIC
       $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_NVector_MultiFab.cpp
       AMReX_NVector_MultiFab.H
       AMReX_Sundials_Core.cpp
       AMReX_Sundials_Core.H
       AMReX_Sundials.H
       AMReX_SundialsIntegrator.H
       AMReX_SUNMemory.cpp
       AMReX_SUNMemory.H
    )
endforeach()


add_amrex_define(AMREX_USE_PETSC NO_LEGACY NO_1D IF AMReX_PETSC)

foreach(D IN LISTS AMReX_SPACEDIM)
    if (D EQUAL 1)
       message(STATUS "PETSc interfaces are not supported for 1D builds (skipping)")
       continue()
    endif ()

    target_include_directories(amrex_${D}d
       PUBLIC
       $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_PETSc.cpp
       AMReX_PETSc.H
    )
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d
       PUBLIC
       $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_PlotFileUtilHDF5.H
       AMReX_PlotFileUtilHDF5.cpp
       AMReX_ParticleUtilHDF5.H
       AMReX_ParticleHDF5.H
       AMReX_ParticlesHDF5.H
       AMReX_WriteBinaryParticleDataHDF5.H
    )
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    # TODO: Particles PR merges another file
    target_sources(amrex_${D}d
       PRIVATE
       AMReX_Conduit_Blueprint.H
       AMReX_Conduit_Blueprint.cpp
    )
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_AmrData.H
       AMReX_AmrData.cpp
       AMReX_XYPlotDataList.H
       AMReX_XYPlotDataList.cpp
       AMReX_DataServices.H
       AMReX_DataServices.cpp
       AMReX_WritePlotFile.H
       AMReX_WritePlotFile.cpp
       AMReX_AmrvisConstants.H
       AMReX_FABUTIL_${D}D.F
       )

    if (AMReX_PROFPARSER)
       target_sources(amrex_${D}d PRIVATE AMReX_XYPlotDataList.cpp AMReX_XYPlotDataList.H )
    endif ()
endforeach()


add_amrex_define(AMREX_USE_PROFPARSER)
foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
        PRIVATE
        AMReX_BLProfStats.H
        AMReX_BLProfStats.cpp
        AMReX_BLProfUtilities.H
        AMReX_BLProfUtilities.cpp
        AMReX_CommProfStats.H
        AMReX_CommProfStats.cpp
        AMReX_RegionsProfStats.H
        AMReX_RegionsProfStats.cpp
        AMReX_AVGDOWN_F.H
        AMReX_AVGDOWN_${D}D.F
        AMReX_BLWritePlotFile.H
        AMReX_BLWritePlotFile.cpp
        AMReX_ProfParserBatch.cpp
    )
endforeach()


#
# -DAMREX_USE_SENSEI_INSITU
#   will compile adaptors and bridge and enables the instrumentation in
#   amrex::Amr
#
# -DAMREX_NO_SENSEI_AMR_INST
#   will disable instrumentation in amrex::Amr in that case explicit
#   instrumentation must be available in the simulation code
#
add_amrex_define( AMREX_USE_SENSEI_INSITU IF AMReX_SENSEI NO_LEGACY )
add_amrex_define( AMREX_NO_SENSEI_AMR_INST IF AMReX_NO_SENSEI_AMR_INST NO_LEGACY )

#
# Mesh based adaptors and bridges
#
foreach(D IN LISTS AMReX_SPACEDIM)
    set ( amrex_sensei_sources
       AMReX_AmrMeshDataAdaptor.H
       AMReX_AmrMeshInSituBridge.H
       AMReX_InSituBridge.H
       AMReX_InSituUtils.H
       AMReX_AmrMeshDataAdaptor.cpp
       AMReX_AmrMeshInSituBridge.cpp
       AMReX_InSituBridge.cpp
       AMReX_InSituUtils.cpp )

    if( AMReX_AMRLEVEL )
       list ( APPEND amrex_sensei_sources
          AMReX_AmrDataAdaptor.H
          AMReX_AmrInSituBridge.H
          AMReX_AmrDataAdaptor.cpp
          AMReX_AmrInSituBridge.cpp )
    endif()

    #
    # Particle based adaptors and bridges
    #
    if ( AMReX_PARTICLES )
       list ( APPEND amrex_sensei_sources
          AMReX_ParticleDataAdaptor.H
          AMReX_ParticleDataAdaptorI.H
          AMReX_ParticleInSituBridge.H
          AMReX_AmrMeshParticleDataAdaptor.H
          AMReX_AmrMeshParticleDataAdaptorI.H
          AMReX_AmrMeshParticleInSituBridge.H )

       if( AMReX_AMRLEVEL )
          list ( APPEND amrex_sensei_sources
             AMReX_AmrParticleDataAdaptor.H
             AMReX_AmrParticleDataAdaptorI.H
             AMReX_AmrParticleInSituBridge.H )
       endif()
    endif ()

    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}> )
    target_sources(amrex_${D}d PRIVATE ${amrex_sensei_sources} )
endforeach()


target_include_directories( amrex
   PUBLIC
   $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

add_amrex_define(AMREX_USE_BITTREE NO_LEGACY)

target_sources( amrex
   PRIVATE
   AMReX_Bittree.H
   AMReX_Bittree.cpp
   )


SOURCE CODE LICENSE AGREEMENT
Software: BndryLib
Version: Oct. 12, 2000 Release

IMPORTANT - READ CAREFULLY: This License Agreement ("Agreement") is a
legal agreement between you (in your capacity as an individual and as
an agent for your company, institution or other entity) and The
Regents of the University of California, Department of Energy
contract-operators of the Ernest Orlando Lawrence Berkeley National
Laboratory ("Berkeley Lab").  Downloading, installing, using, or
copying of the Software (as defined below) by you or by a third party
on your behalf indicates your agreement to be bound by the terms and
conditions of this Agreement.  If you do not agree to these terms and
conditions, do not download, install or use the Software.

1.  LICENSE GRANT. Berkeley Lab grants you, and you hereby accept, a
    non-exclusive, royalty-free perpetual license to install, use,
    modify, prepare derivative works, incorporate into other computer
    software, and distribute the version noted above of the computer
    software program noted above, in binary and source code format, or
    any derivative work thereof, together with any associated media,
    printed materials, and on-line or electronic documentation (if
    any) provided by Berkeley Lab (collectively, the "Software"),
    subject to the following terms and conditions: (i) any
    distribution of the Software shall bind the receiver to the terms
    and conditions of this Agreement; (ii) any distribution of the
    Software in modified form shall clearly state that the Software
    has been modified from the version originally obtained from
    Berkeley Lab.  This version of the Software constitutes a research
    prototype and may be changed substantially.  The license grant set
    forth above is subject to receipt by Berkeley Lab of any required
    U.S. Department of Energy approvals.

2.  COPYRIGHT; RETENTION OF RIGHTS.  The above license grant is
    conditioned on the following: (i) you must reproduce all copyright
    notices and other proprietary notices on any copies of the
    Software and you must not remove such notices; (ii) in the event
    you compile the Software, you will include the copyright notice
    with the binary in such a manner as to allow it to be easily
    viewable; (iii) if you incorporate the Software into other code,
    you must provide notice that the code contains the Software and
    include a copy of the copyright notices and other proprietary
    notices.  All copies of the Software shall be subject to the terms
    of this Agreement.  Subject to approval by the U.S. Department of
    Energy: (a) you hereby acknowledge that the Software is protected
    by United States copyright law and international treaty
    provisions; (b) Berkeley Lab, and its licensors (if any), hereby
    reserve all rights in the Software which are not explicitly
    granted to you herein; (c) without limiting the generality of the
    foregoing, Berkeley Lab and its licensors retain all title,
    copyright, and other proprietary interests in the Software and any
    copies thereof, and you do not acquire any rights, express or
    implied, in the Software, other than those specifically set forth
    in this Agreement.

3.  NO MAINTENANCE OR SUPPORT; TREATMENT OF ENHANCEMENTS YOU CHOOSE TO
    PROVIDE TO BERKELEY LAB.  Berkeley Lab is under no obligation
    whatsoever to: (i) provide maintenance or support for the
    Software; or (ii) to notify you of bug fixes, patches, or upgrades
    to the features, functionality or performance of the Software
    ("Enhancements") (if any), whether developed by Berkeley Lab or
    third parties.  If, in its sole discretion, Berkeley Lab makes an
    Enhancement available to you and Berkeley Lab does not separately
    enter into a written license agreement with you relating to such
    bug fix, patch or upgrade, then it shall be deemed incorporated
    into the Software and subject to this Agreement.  You are under no
    obligation whatsoever to provide any Enhancements to Berkeley Lab
    that you may develop over time; however, if you choose to provide
    Berkeley Lab with Enhancements in source code form that you have
    developed without contemporaneously requiring Berkeley Lab to
    enter into a separate written license agreement, then you hereby
    grant Berkeley Lab a non-exclusive, royalty-free perpetual license
    to install, use, modify, prepare derivative works, incorporate
    into the Software or other computer software, distribute, and
    sublicense your Enhancements or derivative works thereof, in
    binary and source code form.

4.  U.S. GOVERNMENT RIGHTS.  The Software was developed under funding
    from the U.S. Department of Energy and the U.S. Government
    consequently retains certain rights as follows: the
    U.S. Government has been granted for itself and others acting on
    its behalf a paid-up, nonexclusive, irrevocable, worldwide license
    in the Software to reproduce, prepare derivative works, and
    perform publicly and display publicly.  Beginning five (5) years
    after the date permission to assert copyright was granted by the
    U.S. Dept. of Energy, and subject to any subsequent five (5) year
    renewals, the U.S. Government is granted for itself and others
    acting on its behalf a paid-up, nonexclusive, irrevocable,
    worldwide license in the Software to reproduce, prepare derivative
    works, distribute copies to the public, perform publicly and
    display publicly, and to permit others to do so.

5.  WARRANTY DISCLAIMER.  THE SOFTWARE IS SUPPLIED "AS IS" WITHOUT
    WARRANTY OF ANY KIND.  BERKELEY LAB, ITS LICENSORS, THE UNITED
    STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR
    EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED,
    INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR
    NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR
    RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF
    THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD
    NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE
    SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR
    THAT ANY ERRORS WILL BE CORRECTED.

6.  LIMITATION OF LIABILITY. IN NO EVENT WILL BERKELEY LAB OR ITS
    LICENSORS BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL,
    SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT
    NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON
    WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF
    CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR
    OTHERWISE, EVEN IF BERKELEY LAB HAS BEEN WARNED OF THE POSSIBILITY
    OF SUCH LOSS OR DAMAGES.  IN NO EVENT SHALL BERKELEY LAB'S
    LIABILITY FOR DAMAGES ARISING FROM OR IN CONNECTION WITH THIS
    AGREEMENT EXCEED THE AMOUNT PAID BY YOU FOR THE SOFTWARE.

7.  INDEMNITY.  You shall indemnify, defend, and hold harmless
    Berkeley Lab, the U.S. Government, the Software developers, the
    Software sponsors, and their agents, officers, and employees,
    against any and all claims, suits, losses, damage, costs, fees,
    and expenses arising out of or in connection with this Agreement.
    You shall pay all costs incurred by Berkeley Lab in enforcing this
    provision, including reasonable attorney fees.

8.  TERM AND TERMINATION.  The license granted to you under this
    Agreement will continue perpetually unless terminated by Berkeley
    Lab in accordance with this Agreement.  If you breach any term of
    this Agreement, and fail to cure such breach within thirty (30)
    days of the date of written notice, this Agreement shall
    immediately terminate. Upon such termination, you shall
    immediately cease using the Software, return to Berkeley Lab, or
    destroy, all copies of the Software, and provide Berkeley Lab with
    written certification of your compliance with the foregoing.
    Termination shall not relieve you from your obligations arising
    prior to such termination. Notwithstanding any provision of this
    Agreement to the contrary, Sections 5 through 10 shall survive
    termination of this Agreement.

9.  EXPORT CONTROLS. You shall observe all applicable United States
    and foreign laws and regulations (if any) with respect to the
    export, re-export, diversion or transfer of the Software, related
    technical data and direct products thereof, including, without
    limitation, the International Traffic in Arms Regulations (ITAR)
    and the Export Administration Regulations.

10. NO ENDORSEMENT.  In accordance with California Education Code
    Section 92000, you shall not use in advertising, publicity or
    other promotional activities any name, trade name, trademark, or
    other designation of the University of California, nor shall you
    so use "Ernest Orlando Lawrence Berkeley National Laboratory" or
    "United States Department of Energy" (including any contraction,
    abbreviation, or simulation of any of the foregoing) without
    Berkeley Lab's prior written consent.

11. GENERAL.  This Agreement shall be governed by the laws of the
    State of California, excluding its rules governing conflicts of
    laws.  No provision in either party's purchase orders, or in any
    other business forms employed by either party will supersede the
    terms of this Agreement, and no modification or amendment of this
    Agreement is binding, unless in writing signed by a duly
    authorized representative of each party.  This Agreement is
    binding upon and shall inure to the benefit of Berkeley Lab, its
    successors and assigns.  This Agreement represents the entire
    understanding of the parties, and supersedes all previous
    communications, written or oral, relating to the subject of this
    Agreement. If you have any questions concerning this license,
    contact Lawrence Berkeley National Laboratory, Technology Transfer
    Department, One Cyclotron Road, MS 90-1070, Berkeley, CA 94720,
    Attn: Software Licensing or via e-mail at TTD@lbl.gov.

If you have any questions or feedback concerning this Software,
contact the Center for Computational Sciences and Engineering,
Lawrence Berkeley National Laboratory, One Cyclotron Road, MS
50A-1148, Berkeley, CA 94720 or via email at webmaster@mothra.lbl.gov.

Form rev000928



foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_Mask.cpp
       AMReX_MultiMask.cpp
       AMReX_FabSet.H
       AMReX_BndryRegister.H
       AMReX_Mask.H
       AMReX_MultiMask.H
       AMReX_BndryData.H
       AMReX_BoundCond.H
       AMReX_InterpBndryData.H
       AMReX_LO_BCTYPES.H
       AMReX_LO_BCTYPES.cpp
       AMReX_InterpBndryData_K.H
       AMReX_InterpBndryData_${D}D_K.H
       AMReX_LOUtil_K.H
       AMReX_YAFluxRegister.H
       AMReX_YAFluxRegister_K.H
       AMReX_YAFluxRegister_${D}D_K.H
       AMReX_BoundaryFwd.H
       )

    if (AMReX_FORTRAN)
       target_sources(amrex_${D}d
          PRIVATE
          AMReX_LO_UTIL.F90
          AMReX_lo_bctypes_mod.F90
          )
    endif ()
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/Parser>)

    target_sources(amrex_${D}d
       PRIVATE
       # Utility classes ---------------------------------------------------------
       AMReX_ccse-mpi.H
       AMReX_Math.H
       AMReX_Algorithm.H
       AMReX_Any.H
       AMReX_Array.H
       AMReX_BlockMutex.H
       AMReX_BlockMutex.cpp
       AMReX_GpuComplex.H
       AMReX_Vector.H
       AMReX_TableData.H
       AMReX_Tuple.H
       AMReX_TypeList.H
       AMReX.cpp
       AMReX_error_fi.cpp
       AMReX_Version.cpp
       AMReX.H
       AMReX_Demangle.H
       AMReX_Exception.H
       AMReX_Extension.H
       AMReX_PODVector.H
       AMReX_PODVector.cpp
       AMReX_ParmParse.cpp
       AMReX_parmparse_fi.cpp
       AMReX_ParmParse.H
       AMReX_Functional.H
       AMReX_Utility.H
       AMReX_Utility.cpp
       AMReX_FileSystem.H
       AMReX_FileSystem.cpp
       AMReX_ValLocPair.H
       AMReX_Reduce.H
       AMReX_Scan.H
       AMReX_Partition.H
       AMReX_Morton.H
       AMReX_Random.H
       AMReX_RandomEngine.H
       AMReX_Random.cpp
       AMReX_BLassert.H
       AMReX_ArrayLim.H
       AMReX_REAL.H
       AMReX_INT.H
       AMReX_CONSTANTS.H
       AMReX_SPACE.H
       AMReX_DistributionMapping.H
       AMReX_DistributionMapping.cpp
       AMReX_ParallelDescriptor.H
       AMReX_ParallelDescriptor.cpp
       AMReX_OpenMP.H
       AMReX_OpenMP.cpp
       AMReX_ParallelReduce.H
       AMReX_ForkJoin.H
       AMReX_ForkJoin.cpp
       AMReX_ParallelContext.H
       AMReX_ParallelContext.cpp
       AMReX_VisMFBuffer.H
       AMReX_VisMF.H
       AMReX_VisMF.cpp
       AMReX_AsyncOut.H
       AMReX_AsyncOut.cpp
       AMReX_BackgroundThread.H
       AMReX_BackgroundThread.cpp
       AMReX_Arena.H
       AMReX_Arena.cpp
       AMReX_BArena.H
       AMReX_BArena.cpp
       AMReX_CArena.H
       AMReX_CArena.cpp
       AMReX_PArena.H
       AMReX_PArena.cpp
       AMReX_DataAllocator.H
       AMReX_BLProfiler.H
       AMReX_BLBackTrace.H
       AMReX_BLBackTrace.cpp
       AMReX_BLFort.H
       AMReX_NFiles.H
       AMReX_NFiles.cpp
       AMReX_parstream.H
       AMReX_parstream.cpp
       # I/O stuff  --------------------------------------------------------------
       AMReX_ANSIEscCode.H
       AMReX_FabConv.H
       AMReX_FabConv.cpp
       AMReX_FPC.H
       AMReX_FPC.cpp
       AMReX_VectorIO.H
       AMReX_VectorIO.cpp
       AMReX_Print.H
       AMReX_IntConv.H
       AMReX_IntConv.cpp
       # Index space -------------------------------------------------------------
       AMReX_Box.H
       AMReX_Box.cpp
       AMReX_BoxIterator.H
       AMReX_BoxIterator.cpp
       AMReX_Dim3.H
       AMReX_IntVect.H
       AMReX_IntVect.cpp
       AMReX_IndexType.H
       AMReX_IndexType.cpp
       AMReX_Loop.H
       AMReX_Loop.nolint.H
       AMReX_Orientation.H
       AMReX_Orientation.cpp
       AMReX_Periodicity.H
       AMReX_Periodicity.cpp
       # Real space --------------------------------------------------------------
       AMReX_RealBox.H
       AMReX_RealBox.cpp
       AMReX_RealVect.H
       AMReX_RealVect.cpp
       # Unions of rectangle -----------------------------------------------------
       AMReX_BoxList.H
       AMReX_BoxList.cpp
       AMReX_BoxArray.H
       AMReX_BoxArray.cpp
       AMReX_BoxDomain.H
       AMReX_BoxDomain.cpp
       # Fortran array data ------------------------------------------------------
       AMReX_FArrayBox.H
       AMReX_FArrayBox.cpp
       AMReX_IArrayBox.H
       AMReX_IArrayBox.cpp
       AMReX_BaseFab.H
       AMReX_BaseFab.cpp
       AMReX_Array4.H
       AMReX_MakeType.H
       AMReX_TypeTraits.H
       AMReX_FabFactory.H
       AMReX_BaseFabUtility.H
       # Fortran data defined on unions of rectangles ----------------------------
       AMReX_MultiFab.cpp
       AMReX_MultiFab.H
       AMReX_MFCopyDescriptor.cpp
       AMReX_MFCopyDescriptor.H
       AMReX_iMultiFab.cpp
       AMReX_iMultiFab.H
       AMReX_FabArrayBase.cpp
       AMReX_FabArrayBase.H
       AMReX_MFIter.cpp
       AMReX_MFIter.H
       AMReX_FabArray.H
       AMReX_FACopyDescriptor.H
       AMReX_FabArrayCommI.H
       AMReX_FBI.H
       AMReX_PCI.H
       AMReX_FabArrayUtility.H
       AMReX_LayoutData.H
       # Geometry / Coordinate system routines -----------------------------------
       AMReX_CoordSys.cpp
       AMReX_CoordSys.H
       AMReX_COORDSYS_${D}D_C.H
       AMReX_COORDSYS_C.H
       AMReX_Geometry.cpp
       AMReX_Geometry.H
       AMReX_MultiFabUtil.cpp
       AMReX_MultiFabUtil.H
       AMReX_MultiFabUtilI.H
       AMReX_MultiFabUtil_${D}D_C.H
       AMReX_MultiFabUtil_nd_C.H
       AMReX_MultiFabUtil_C.H
       # Boundary-related --------------------------------------------------------
       AMReX_BCRec.cpp
       AMReX_BCRec.H
       AMReX_PhysBCFunct.cpp
       AMReX_PhysBCFunct.H
       AMReX_BCUtil.cpp
       AMReX_BCUtil.H
       AMReX_BC_TYPES.H
       AMReX_FilCC_${D}D_C.H
       AMReX_FilCC_C.H
       AMReX_FilCC_C.cpp
       AMReX_FilFC_${D}D_C.H
       AMReX_FilFC_C.H
       AMReX_FilFC_C.cpp
       AMReX_FilND_C.H
       AMReX_FilND_C.cpp
       # Non-Local BC
       AMReX_NonLocalBC.H
       AMReX_NonLocalBC.cpp
       AMReX_NonLocalBCImpl.H
       # Plotfile ----------------------------------------------------------------
       AMReX_PlotFileUtil.cpp
       AMReX_PlotFileUtil.H
       AMReX_PlotFileDataImpl.H
       AMReX_PlotFileDataImpl.cpp
       # Time Integration
       AMReX_FEIntegrator.H
       AMReX_IntegratorBase.H
       AMReX_RKIntegrator.H
       AMReX_TimeIntegrator.H
       AMReX_RungeKutta.H
       # GPU --------------------------------------------------------------------
       AMReX_Gpu.H
       AMReX_GpuQualifiers.H
       AMReX_GpuKernelInfo.H
       AMReX_GpuPrint.H
       AMReX_GpuAssert.H
       AMReX_GpuTypes.H
       AMReX_GpuControl.H
       AMReX_GpuControl.cpp
       AMReX_GpuLaunch.H
       AMReX_GpuLaunch.nolint.H
       AMReX_GpuLaunchGlobal.H
       AMReX_GpuLaunchMacrosG.H
       AMReX_GpuLaunchMacrosG.nolint.H
       AMReX_GpuLaunchMacrosC.H
       AMReX_GpuLaunchMacrosC.nolint.H
       AMReX_GpuLaunchFunctsG.H
       AMReX_GpuLaunchFunctsC.H
       AMReX_GpuError.H
       AMReX_GpuDevice.H
       AMReX_GpuDevice.cpp
       AMReX_GpuBuffer.H
       AMReX_GpuAtomic.H
       AMReX_GpuUtility.H
       AMReX_GpuUtility.cpp
       AMReX_GpuAsyncArray.H
       AMReX_GpuAsyncArray.cpp
       AMReX_GpuElixir.H
       AMReX_GpuElixir.cpp
       AMReX_GpuMemory.H
       AMReX_GpuRange.H
       AMReX_GpuReduce.H
       AMReX_GpuAllocators.H
       AMReX_GpuContainers.H
       AMReX_MFParallelFor.H
       AMReX_MFParallelForC.H
       AMReX_MFParallelForG.H
       AMReX_TagParallelFor.H
       AMReX_CTOParallelForImpl.H
       AMReX_ParReduce.H
       # CUDA --------------------------------------------------------------------
       AMReX_CudaGraph.H
       # Machine model -----------------------------------------------------------
       AMReX_Machine.H
       AMReX_Machine.cpp
       # Memory pool -------------------------------------------------------------
       AMReX_MemPool.cpp
       AMReX_MemPool.H
       # Parser ---------------------------------------------------------------
       Parser/AMReX_Parser.cpp
       Parser/AMReX_Parser.H
       Parser/AMReX_Parser_Exe.cpp
       Parser/AMReX_Parser_Exe.H
       Parser/AMReX_Parser_Y.cpp
       Parser/AMReX_Parser_Y.H
       Parser/amrex_parser.lex.cpp
       Parser/amrex_parser.lex.nolint.H
       Parser/amrex_parser.lex.h
       Parser/amrex_parser.tab.cpp
       Parser/amrex_parser.tab.nolint.H
       Parser/amrex_parser.tab.h
       Parser/AMReX_IParser.cpp
       Parser/AMReX_IParser.H
       Parser/AMReX_IParser_Exe.cpp
       Parser/AMReX_IParser_Exe.H
       Parser/AMReX_IParser_Y.cpp
       Parser/AMReX_IParser_Y.H
       Parser/amrex_iparser.lex.cpp
       Parser/amrex_iparser.lex.nolint.H
       Parser/amrex_iparser.lex.h
       Parser/amrex_iparser.tab.cpp
       Parser/amrex_iparser.tab.nolint.H
       Parser/amrex_iparser.tab.h
       # AMReX Hydro -----------------------------------------------------
       AMReX_Slopes_K.H
       # Forward declaration -----------------------------------------------------
       AMReX_BaseFwd.H
       )

    # Profiling
    #   this source file has zero symbols in default conditions, which creates
    #   ranlib warnings, e.g., on macOS
    if(AMReX_BASE_PROFILE OR AMReX_TINY_PROFILE OR AMReX_FORTRAN)
       target_sources(amrex_${D}d
         PRIVATE
           AMReX_BLProfiler.cpp
       )
    endif()

    # Fortran stuff
    if (AMReX_FORTRAN)
       target_sources(amrex_${D}d
          PRIVATE
          AMReX_filcc_f.H
          AMReX_BLutil_F.F90
          AMReX_BLProfiler_F.F90
          AMReX_FILCC_${D}D.F90
          AMReX_filcc_mod.F90
          AMReX_omp_mod.F90
          AMReX_acc_mod.F90
          AMReX_fort_mod.F90
          AMReX_constants_mod.f90
          AMReX_error_mod.F90
          AMReX_parmparse_mod.F90
          AMReX_string_mod.F90
          AMReX_bc_types_mod.F90
          AMReX_ParallelDescriptor_F.F90
          AMReX_io_mod.F90
          AMReX_mempool_mod.F90
          )
    endif ()
    # LAZY mode not supported in CMake yet
    # ifeq ($(LAZY),TRUE)
    # C$(AMREX_BASE)_sources += AMReX_Lazy.cpp
    # C$(AMREX_BASE)_headers += AMReX_Lazy.H
    # endif

    # Memory Profiler
    if (AMReX_MEM_PROFILE)
       target_sources(amrex_${D}d PRIVATE AMReX_MemProfiler.cpp AMReX_MemProfiler.H )
    endif ()

    # Tiny Profiler
    if (AMReX_TINY_PROFILE)
       target_sources(amrex_${D}d PRIVATE AMReX_TinyProfiler.cpp AMReX_TinyProfiler.H )
    endif ()

    # MPMD
    if (AMReX_MPI)
       target_sources(amrex_${D}d PRIVATE AMReX_MPMD.cpp AMReX_MPMD.H )
    endif ()
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    #
    # Sources in subdirectory MLMG
    #
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/MLMG>)

    target_sources(amrex_${D}d
       PRIVATE
       MLMG/AMReX_MLMG.H
       MLMG/AMReX_MLMG.cpp
       MLMG/AMReX_MLMG_K.H
       MLMG/AMReX_MLMG_${D}D_K.H
       MLMG/AMReX_MLMGBndry.H
       MLMG/AMReX_MLLinOp.H
       MLMG/AMReX_MLLinOp_K.H
       MLMG/AMReX_MLCellLinOp.H
       MLMG/AMReX_MLNodeLinOp.H
       MLMG/AMReX_MLNodeLinOp.cpp
       MLMG/AMReX_MLCellABecLap.H
       MLMG/AMReX_MLCellABecLap_K.H
       MLMG/AMReX_MLCellABecLap_${D}D_K.H
       MLMG/AMReX_MLCGSolver.H
       MLMG/AMReX_MLABecLaplacian.H
       MLMG/AMReX_MLABecLap_K.H
       MLMG/AMReX_MLABecLap_${D}D_K.H
       MLMG/AMReX_MLALaplacian.H
       MLMG/AMReX_MLALap_K.H
       MLMG/AMReX_MLALap_${D}D_K.H
       MLMG/AMReX_MLPoisson.H
       MLMG/AMReX_MLPoisson_K.H
       MLMG/AMReX_MLPoisson_${D}D_K.H
       MLMG/AMReX_MLNodeLaplacian.H
       MLMG/AMReX_MLNodeLaplacian.cpp
       MLMG/AMReX_MLNodeLaplacian_sync.cpp
       MLMG/AMReX_MLNodeLaplacian_sten.cpp
       MLMG/AMReX_MLNodeLaplacian_misc.cpp
       MLMG/AMReX_MLNodeLap_K.H
       MLMG/AMReX_MLNodeLap_${D}D_K.H
       MLMG/AMReX_MLNodeTensorLaplacian.H
       MLMG/AMReX_MLNodeTensorLaplacian.cpp
       MLMG/AMReX_MLNodeTensorLap_K.H
       MLMG/AMReX_MLNodeTensorLap_${D}D_K.H
       MLMG/AMReX_MLTensorOp.H
       MLMG/AMReX_MLTensorOp.cpp
       MLMG/AMReX_MLTensorOp_grad.cpp
       MLMG/AMReX_MLTensor_K.H
       MLMG/AMReX_MLTensor_${D}D_K.H
       MLMG/AMReX_MLEBNodeFDLaplacian.H
       MLMG/AMReX_MLEBNodeFDLaplacian.cpp
       MLMG/AMReX_MLEBNodeFDLap_K.H
       MLMG/AMReX_MLEBNodeFDLap_${D}D_K.H
       MLMG/AMReX_MLNodeABecLaplacian.H
       MLMG/AMReX_MLNodeABecLaplacian.cpp
       MLMG/AMReX_MLNodeABecLap_K.H
       MLMG/AMReX_MLNodeABecLap_${D}D_K.H
       )

    if (D EQUAL 3)
       target_sources(amrex_${D}d
          PRIVATE
          MLMG/AMReX_MLMG_2D_K.H
          MLMG/AMReX_MLPoisson_2D_K.H
          MLMG/AMReX_MLALap_2D_K.H
          )
    endif ()

    if (AMReX_EB AND NOT D EQUAL 1)
       target_sources(amrex_${D}d
          PRIVATE
          MLMG/AMReX_MLNodeLaplacian_eb.cpp
          MLMG/AMReX_MLEBABecLap.H
          MLMG/AMReX_MLEBABecLap.cpp
          MLMG/AMReX_MLEBABecLap_F.cpp
          MLMG/AMReX_MLEBABecLap_K.H
          MLMG/AMReX_MLEBABecLap_${D}D_K.H
          MLMG/AMReX_MLEBTensorOp.H
          MLMG/AMReX_MLEBTensorOp.cpp
          MLMG/AMReX_MLEBTensorOp_bc.cpp
          MLMG/AMReX_MLEBTensor_K.H
          MLMG/AMReX_MLEBTensor_${D}D_K.H
          )
    endif ()

    if (AMReX_FORTRAN)
       target_sources(amrex_${D}d
          PRIVATE
          MLMG/AMReX_MLLinOp_F.H
          MLMG/AMReX_MLLinOp_nd.F90
          )
    endif ()

    if (AMReX_HYPRE)
       target_sources(amrex_${D}d
          PRIVATE
          MLMG/AMReX_MLNodeLaplacian_hypre.cpp
          )
    endif ()

    if (D EQUAL 3)

       target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/OpenBC>)

       target_sources(amrex_${D}d
          PRIVATE
          OpenBC/AMReX_OpenBC.H
          OpenBC/AMReX_OpenBC_K.H
          OpenBC/AMReX_OpenBC.cpp
          )
    endif ()
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_AmrCore.cpp
       AMReX_Cluster.cpp
       AMReX_ErrorList.cpp
       AMReX_AmrCore.H
       AMReX_Cluster.H
       AMReX_ErrorList.H
       AMReX_FillPatchUtil.cpp
       AMReX_FluxRegister.cpp
       AMReX_FillPatchUtil.H
       AMReX_FillPatchUtil_I.H
       AMReX_FillPatcher.H
       AMReX_FluxRegister.H
       AMReX_InterpBase.H
       AMReX_InterpBase.cpp
       AMReX_MFInterpolater.H
       AMReX_MFInterpolater.cpp
       AMReX_Interpolater.cpp
       AMReX_TagBox.cpp
       AMReX_AmrMesh.cpp
       AMReX_Interpolater.H
       AMReX_TagBox.H
       AMReX_AmrMesh.H
       AMReX_FluxReg_${D}D_C.H
       AMReX_FluxReg_C.H
       AMReX_Interp_C.H
       AMReX_Interp_${D}D_C.H
       AMReX_MFInterp_C.H
       AMReX_MFInterp_${D}D_C.H
       AMReX_InterpFaceRegister.H
       AMReX_InterpFaceRegister.cpp
       AMReX_InterpFaceReg_C.H
       AMReX_InterpFaceReg_${D}D_C.H
       AMReX_AmrCoreFwd.H
       )

    if (AMReX_FORTRAN)
       target_sources(amrex_${D}d
          PRIVATE
          AMReX_FillPatchUtil_F.H
          AMReX_FillPatchUtil_${D}d.F90
          )
    endif ()

    # These files are needed only if Particles are enabled
    if ( AMReX_PARTICLES )
      target_sources( amrex_${D}d PRIVATE AMReX_AmrParGDB.H AMReX_AmrParticles.H )
    endif ()
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_LevelBld.H
       AMReX_Amr.H
       AMReX_AmrLevel.H
       AMReX_Derive.H
       AMReX_StateData.H
       AMReX_Amr.cpp
       AMReX_AmrLevel.cpp
       AMReX_Derive.cpp
       AMReX_StateData.cpp
       AMReX_PROB_AMR_F.H
       AMReX_StateDescriptor.H
       AMReX_AuxBoundaryData.H
       AMReX_StateDescriptor.cpp
       AMReX_AuxBoundaryData.cpp
       AMReX_Extrapolater.H
       AMReX_Extrapolater.cpp
       AMReX_extrapolater_K.H
       AMReX_extrapolater_${D}D_K.H
       AMReX_AmrFwd.H
    )
endforeach()


add_amrex_define(AMREX_USE_EB NO_LEGACY NO_1D)

foreach(D IN LISTS AMReX_SPACEDIM)
    if(D EQUAL 1)
        message(WARNING "Embedded Boundary (EB) interfaces are not supported for 1D builds (skipping)")
        continue()
    endif()

    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_EBFArrayBox.H
       AMReX_EBFArrayBox.cpp
       AMReX_EBFabFactory.H
       AMReX_EBFabFactory.cpp
       AMReX_EBMultiFabUtil.H
       AMReX_EBMultiFabUtil_C.H
       AMReX_EBMultiFabUtil_${D}D_C.H
       AMReX_EBMultiFabUtil.cpp
       AMReX_EBCellFlag.H
       AMReX_EBCellFlag.cpp
       AMReX_EBDataCollection.H
       AMReX_EBDataCollection.cpp
       AMReX_MultiCutFab.H
       AMReX_MultiCutFab.cpp
       AMReX_EBSupport.H
       AMReX_EBInterpolater.H
       AMReX_EBInterpolater.cpp
       AMReX_EBMFInterpolater.H
       AMReX_EBMFInterpolater.cpp
       AMReX_EBFluxRegister.H
       AMReX_EBFluxRegister_C.H
       AMReX_EBFluxRegister_${D}D_C.H
       AMReX_EBFluxRegister.cpp
       AMReX_EBAmrUtil.H
       AMReX_EBAmrUtil.cpp
       AMReX_EB_utils.H
       AMReX_EB_utils.cpp
       AMReX_EB_FluxRedistribute.cpp
       AMReX_EB_Redistribution.cpp
       AMReX_EB_RedistributionApply.cpp
       AMReX_EB_StateRedistItracker.cpp
       AMReX_EB_StateRedistUtils.cpp
       AMReX_EB_StateRedistribute.cpp
       AMReX_EB_Redistribution.H
       AMReX_EB_StateRedistSlopeLimiter_K.H
       AMReX_EB_Slopes_${D}D_K.H
       AMReX_EB_Slopes_K.H
       AMReX_algoim.H
       AMReX_algoim_K.H
       AMReX_algoim.cpp
       AMReX_EB2_IF_AllRegular.H
       AMReX_EB2_IF_Box.H
       AMReX_EB2_IF_Cylinder.H
       AMReX_EB2_IF_Ellipsoid.H
       AMReX_EB2_IF_Plane.H
       AMReX_EB2_IF_Sphere.H
       AMReX_EB2_IF_Torus.H
       AMReX_distFcnElement.H
       AMReX_EB2_IF_Spline.H
       AMReX_EB2_IF_Polynomial.H
       AMReX_EB2_IF_Complement.H
       AMReX_EB2_IF_Intersection.H
       AMReX_EB2_IF_Lathe.H
       AMReX_EB2_IF_Rotation.H
       AMReX_EB2_IF_Scale.H
       AMReX_EB2_IF_Translation.H
       AMReX_EB2_IF_Union.H
       AMReX_EB2_IF_Extrusion.H
       AMReX_EB2_IF_Difference.H
       AMReX_EB2_IF_Parser.H
       AMReX_EB2_IF.H
       AMReX_EB2_IF_Base.H
       AMReX_EB2_IF_DevicePtr.H
       AMReX_distFcnElement.cpp
       AMReX_EB2_GeometryShop.H
       AMReX_EB2.H
       AMReX_EB2_IndexSpaceI.H
       AMReX_EB2_Level.H
       AMReX_EB2_Graph.H
       AMReX_EB2_MultiGFab.H
       AMReX_EB2.cpp
       AMReX_EB2_Level.cpp
       AMReX_EB2_MultiGFab.cpp
       AMReX_EB2_${D}D_C.cpp
       AMReX_EB2_ND_C.cpp
       AMReX_EB2_C.H
       AMReX_EB2_${D}D_C.H
       AMReX_EB_STL_utils.H
       AMReX_EB_STL_utils.cpp
       AMReX_EB_chkpt_file.H
       AMReX_EB_chkpt_file.cpp
       AMReX_EB_triGeomOps_K.H
       AMReX_EB2_Level_STL.H
       AMReX_EB2_Level_STL.cpp
       AMReX_EB2_IndexSpace_STL.H
       AMReX_EB2_IndexSpace_STL.cpp
       AMReX_EB2_Level_chkpt_file.H
       AMReX_EB2_Level_chkpt_file.cpp
       AMReX_EB2_IndexSpace_chkpt_file.H
       AMReX_EB2_IndexSpace_chkpt_file.cpp
       )

    if (D EQUAL 3)
       target_sources(amrex_${D}d
       PRIVATE
       AMReX_WriteEBSurface.cpp
       AMReX_WriteEBSurface.H
       AMReX_EBToPVD.H
       AMReX_EBToPVD.cpp
       )
    endif ()

    if (AMReX_FORTRAN)
       target_sources(amrex_${D}d
          PRIVATE
          AMReX_ebcellflag_mod.F90
          AMReX_EBFluxRegister_nd.F90
          )
    endif ()
endforeach()


add_amrex_define(AMREX_PARTICLES NO_LEGACY)

if (AMReX_PARTICLES_PRECISION STREQUAL "SINGLE")
   add_amrex_define(AMREX_SINGLE_PRECISION_PARTICLES NO_LEGACY)
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    target_include_directories(amrex_${D}d PUBLIC $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}>)

    target_sources(amrex_${D}d
       PRIVATE
       AMReX_TracerParticles.cpp
       AMReX_ParticleMPIUtil.cpp
       AMReX_Particles.H
       AMReX_ParticleContainer.H
       AMReX_SparseBins.H
       AMReX_ParGDB.H
       AMReX_Particle_mod_K.H
       AMReX_TracerParticles.H
       AMReX_NeighborParticles.H
       AMReX_NeighborParticlesI.H
       AMReX_NeighborList.H
       AMReX_Particle.H
       AMReX_ParticleInit.H
       AMReX_ParticleContainerI.H
       AMReX_ParIter.H
       AMReX_ParticleMPIUtil.H
       AMReX_ParticleUtil.H
       AMReX_ParticleUtil.cpp
       AMReX_StructOfArrays.H
       AMReX_ArrayOfStructs.H
       AMReX_ParticleTile.H
       AMReX_MakeParticle.H
       AMReX_NeighborParticlesCPUImpl.H
       AMReX_NeighborParticlesGPUImpl.H
       AMReX_ParticleBufferMap.H
       AMReX_ParticleBufferMap.cpp
       AMReX_ParticleCommunication.H
       AMReX_ParticleCommunication.cpp
       AMReX_ParticleInterpolators.H
       AMReX_ParticleReduce.H
       AMReX_ParticleMesh.H
       AMReX_ParticleLocator.H
       AMReX_ParticleIO.H
       AMReX_DenseBins.H
       AMReX_BinIterator.H
       AMReX_ParticleTransformation.H
       AMReX_WriteBinaryParticleData.H
       AMReX_ParticleContainerBase.H
       AMReX_ParticleContainerBase.cpp
       AMReX_ParticleArray.H
   )
endforeach()



#
# Compile definitions required by codes using Fortran interfaces
# These definitions are not present anywhere in AMReX source code
# so I think they are meant to be used by the app code only
#
add_amrex_define(AMREX_USE_F_INTERFACES)

foreach(D IN LISTS AMReX_SPACEDIM)
    #
    # BASE subdir
    #
    target_include_directories(amrex_${D}d PUBLIC
       $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/Base>)

    target_sources(amrex_${D}d PRIVATE
       Base/AMReX_init_mod.F90
       Base/AMReX_parallel_mod.F90
       Base/AMReX_base_mod.F90
       Base/AMReX_box_mod.F90
       Base/AMReX_boxarray_mod.F90
       Base/AMReX_distromap_mod.F90
       Base/AMReX_geometry_mod.F90
       Base/AMReX_multifab_mod.F90
       Base/AMReX_plotfile_mod.F90
       Base/AMReX_multifabutil_mod.F90
       Base/AMReX_physbc_mod.F90
       Base/AMReX_fab_mod.F90
       Base/AMReX_init_fi.cpp
       Base/AMReX_box_fi.cpp
       Base/AMReX_boxarray_fi.cpp
       Base/AMReX_distromap_fi.cpp
       Base/AMReX_geometry_fi.cpp
       Base/AMReX_multifab_fi.cpp
       Base/AMReX_vismf_fi.cpp
       Base/AMReX_plotfile_fi.cpp
       Base/AMReX_multifabutil_fi.cpp
       Base/AMReX_physbc_fi.cpp
       Base/AMReX_FPhysBC.H
       Base/AMReX_FPhysBC.cpp
    )

    if (AMReX_MPI)
      target_sources(amrex_${D}d PRIVATE
        Base/AMReX_fi_mpi_mod.F90
        Base/AMReX_mpi_reduce_int.F90
        Base/AMReX_mpi_reduce_real.F90
      )
    endif ()

    #
    # AMRCORE subdir
    #
    target_include_directories(amrex_${D}d PUBLIC
       $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/AmrCore>)

    target_sources(amrex_${D}d PRIVATE
       AmrCore/AMReX_amrcore_fi.cpp
       AmrCore/AMReX_amrcore_mod.F90
       AmrCore/AMReX_amr_mod.F90
       AmrCore/AMReX_FAmrCore.cpp
       AmrCore/AMReX_FAmrCore.H
       AmrCore/AMReX_fillpatch_fi.cpp
       AmrCore/AMReX_fillpatch_mod.F90
       AmrCore/AMReX_FlashFluxRegister.cpp
       AmrCore/AMReX_flash_fluxregister_fi.cpp
       AmrCore/AMReX_FlashFluxRegister.H
       AmrCore/AMReX_flash_fluxregister_mod.F90
       AmrCore/AMReX_fluxregister_fi.cpp
       AmrCore/AMReX_fluxregister_mod.F90
       AmrCore/AMReX_interpolater_mod.F90
       AmrCore/AMReX_tagbox_fi.cpp
       AmrCore/AMReX_tagbox_mod.F90
    )


    #
    # OCTREE subdir
    #
    target_include_directories(amrex_${D}d PUBLIC
       $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/Octree>)

    target_sources(amrex_${D}d PRIVATE
       Octree/AMReX_octree_mod.F90
       Octree/AMReX_octree_fi.cpp
    )


    #
    # LINEARSOLVERS subdir
    #
    if (AMReX_LINEAR_SOLVERS)
       target_include_directories(amrex_${D}d PUBLIC
          $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/LinearSolvers>)

       target_sources(amrex_${D}d PRIVATE
          LinearSolvers/AMReX_abeclaplacian_fi.cpp
          LinearSolvers/AMReX_abeclaplacian_mod.F90
          LinearSolvers/AMReX_linear_solver_mod.F90
          LinearSolvers/AMReX_linop_mod.F90
          LinearSolvers/AMReX_multigrid_mod.F90
          LinearSolvers/AMReX_multigrid_fi.cpp
          LinearSolvers/AMReX_poisson_mod.F90
          LinearSolvers/AMReX_linop_fi.cpp
          LinearSolvers/AMReX_poisson_fi.cpp
          )
    endif ()

    #
    # PARTICLE subdir
    #
    if ( AMReX_PARTICLES )
       target_include_directories(amrex_${D}d PUBLIC
          $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/Particle>)
       target_sources(amrex_${D}d PRIVATE
          Particle/AMReX_particlecontainer_fi.cpp
          Particle/AMReX_particlecontainer_mod.F90
       )
    endif ()
endforeach()


#!/usr/bin/env python3

import sys
import os
import subprocess
import calendar
import time
import argparse

def compiletesting(arg_string):

    parser = argparse.ArgumentParser(description="compile tests")
    parser.add_argument("--redo_failed", action="store_true")
    parser.add_argument("--typecheck", action="store_true")
    parser.add_argument("--full", action="store_true")
    parser.add_argument("--make_flags", type=str, default="")
    if not arg_string is None:
        args = parser.parse_args(arg_string)
    else:
        args = parse.parse_args()

    if args.redo_failed:
        test_list = []
        f = open("failed_tests", 'r')
        for line in f.readlines():
            test_list.append(line[:-1])
        f.close()
    elif args.full:
        test_list = ['Tutorials/Basic/HelloWorld_C',
                     'Tutorials/Basic/HelloWorld_F',
                     'Tutorials/Basic/HeatEquation_EX1_C/Exec',
                     'Tutorials/Basic/HeatEquation_EX1_F',
                     'Tutorials/Amr/Advection_AmrCore/Exec/SingleVortex',
                     'Tutorials/Amr/Advection_F/Exec/SingleVortex',
                     'Tutorials/Amr/Advection_octree_F/Exec/SingleVortex',
                     'Tutorials/Amr/Advection_AmrLevel/Exec/SingleVortex',
                     'Tutorials/Amr/Advection_AmrLevel/Exec/UniformVelocity',
                     'Tutorials/EB/CNS/Exec/Combustor',
                     'Tutorials/EB/CNS/Exec/Pulse',
                     'Tutorials/EB/LevelSet/Exec',
                     'Tutorials/LinearSolvers/ABecLaplacian_C',
                     'Tutorials/LinearSolvers/ABecLaplacian_F',
                     'Tutorials/Particles/CellSortedParticles',
#                     'Tutorials/Particles/ElectromagneticPIC',
#                     'Tutorials/Particles/ElectrostaticPIC',
                     'Tutorials/Particles/NeighborList',
                     'Tests/DataServicesTest0',
                     'Tests/BBIOBenchmark',
                     'Tests/C_BaseLib',
                     'Tests/IOBenchmark',
                     'Tests/NoFort',
                     'Tests/SinglePrecision',
                     'Tests/Particles/ParticleMesh',
                     'Tests/LinearSolvers/CellEB',
                     'Tests/LinearSolvers/CellEB2',
                     'Tests/MKDir']

    else:
        test_list = ['Tutorials/Amr/Advection_AmrCore/Exec/SingleVortex',
                     'Tutorials/Amr/Advection_F/Exec/SingleVortex',
                     'Tutorials/EB/CNS/Exec/Pulse',
                     'Tutorials/LinearSolvers/ABecLaplacian_C',
                     'Tutorials/LinearSolvers/ABecLaplacian_F',
                     'Tutorials/Particles/NeighborList',
                     'Tests/NoFort',
                     'Tests/SinglePrecision',
                     'Tests/LinearSolvers/CellEB2']

    print("Test List: ", test_list)

    TOP = os.getcwd()

    start_time = calendar.timegm(time.gmtime())

    failed_tests = []
    for test in test_list:
        print("Compile", test)
        os.chdir(os.path.join(TOP,test))

        command = "make realclean"
        outfile = "makerealclean.ou"
        run(command, outfile)

        command = "make -j4 " + args.make_flags
        if args.typecheck:
            command += " typecheck"
        outfile = "make.ou"
        run(command, outfile)

        test_success = False
        if args.typecheck:
            f = open(outfile, 'r')
            for line in f.readlines():
                if "functions checked, 0 error" in line:
                    test_success = True
                    break
        else:
            os.chdir(os.path.join(TOP,test))
            for file in os.listdir('./'):
                if file.endswith(".ex") or file.endswith(".exe"):
                    t = os.path.getmtime(file)
                    test_success = t > start_time

        if test_success:
            print("    success")
        else:
            print("    failed")
            failed_tests.append(test)

    print("")

    os.chdir(TOP)
    if failed_tests:
        print("Failed tests: ", failed_tests)
        f = open("failed_tests", 'w')
        for t in failed_tests:
            f.write(t+"\n")
        f.close()
    else:
        print("Compile tests passed.")

def run(command, outfile=None):

    # shlex.split will preserve inner quotes
    p0 = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)

    stdout0, stderr0 = p0.communicate()
    rc = p0.returncode
    p0.stdout.close()
    p0.stderr.close()

    if outfile:
        try: cf = open(outfile, 'wb')
        except IOError:
            print("ERROR: unable to open file for writing")
        else:
            cf.write(stdout0)
            cf.write(stderr0)
            cf.close()
    else:
        print("    ", stdout0)
        if stderr0:
            print("    ", stderr0)

    return rc

if __name__ == "__main__":
    compiletesting(sys.argv[1:])


#!/usr/bin/env python3

import sys
import re
import subprocess
import shlex

if len(sys.argv) < 3:
  print("Usage: %s [exe-file] [backtrace-file]" % sys.argv[0])
  sys.exit(1)

exe_file = sys.argv[1]
bt_file = sys.argv[2]

with open(bt_file, 'rt') as f:
  lines = f.readlines()

for l in lines:

  m = re.search("libc\.so", l)
  if m:
    continue

  matched = False

  # gnu compiler
  m = re.match("\s*(\d+): .*\(\+(0x[\dabcdef]+)\)", l)
  if m:
    matched = True
    frame = m.group(1)
    addr = m.group(2)

  # intel compiler
  if not matched:
    m = re.match("\s*(\d+): .*\[(0x[\dabcdef]+)\]", l)
    if m:
      matched = True
      frame = m.group(1)
      addr = m.group(2)

  if matched:
    cmd = "addr2line -Cpfie %s %s" % (exe_file, addr)
    info = subprocess.check_output(shlex.split(cmd)).decode("utf-8")
    print("%s: %s" % (frame, info))


These scripts are used for various build functions

`dep.py` :

   This finds the dependencies among a group of Fortran 90 files.  It
   accepts preprocessor options and will first preprocess the files
   and then do the dependency checking.  This is used to output the
   f90.depends file in the C++ build system.


`find_files_vpath.py` :

   This script is used by the build system when we do

   ```
   make file_locations
   ```

   This will then output where in the make search path we find the
   source files, and will also report on any files that are not found.





#!/usr/bin/env python3

"""
Take a vpath and a list of files and find where in the first vpath the
first occurrence of the file.
"""

import sys
import os
import argparse

def find_files(vpath, files_in):

    files = []
    not_found = []

    if vpath is None:
        sys.exit("vpath is empty -- nothing to search")

    if files_in is None:
        sys.exit("files is empty -- nothing to search")

    filenames = [os.path.basename(f) for f in files_in.split()]
    vpath = vpath.split()

    for f in filenames:

        found = False

        for d in vpath:
            if os.path.isfile("{}/{}".format(d, f)):
                found = True
                files.append((f, d))
                break

        if not found:
            not_found.append(f)

    return files, not_found


def standalone_run():
    parser = argparse.ArgumentParser()

    parser.add_argument("--vpath", type=str, default=None,
                        metavar="'list of dirs in vpath'",
                        help="the list of directories that make will look at to find source files (e.g. the vpath)")

    parser.add_argument("--files", type=str, default=None,
                        metavar="'list of files'",
                        help="the list of source files")
    args = parser.parse_args()

    files, not_found = find_files(args.vpath, args.files)

    # output
    print("locations of source files:")
    for f, d in files:
        print("{} : {}".format(f, d))

    print("\n")
    print("files not found:")
    for f in not_found:
        print("{}".format(f))


if __name__ == "__main__":
    standalone_run()


import io
import os
import subprocess
import sys

def run(command, stdin=False, outfile=None):
    """ run a command in the unix shell """

    sin = None
    if stdin: sin = subprocess.PIPE
    p0 = subprocess.Popen(command, stdin=sin, stdout=subprocess.PIPE,
                          stderr=subprocess.STDOUT, shell=True)

    stdout0 = p0.communicate()
    if stdin: p0.stdin.close()
    rc = p0.returncode
    p0.stdout.close()

    if outfile is not None:
        try: cf = io.open(outfile, "w", encoding="latin-1")
        except IOError:
            sys.exit("ERROR: unable to open file for writing: {}".format(outfile))
        else:
            for line in stdout0:
                if line is not None:
                    cf.write(line.decode('latin-1'))
            cf.close()

    return stdout0, rc


class Preprocessor(object):
    """ hold the information about preprocessing """

    def __init__(self, temp_dir=None, cpp_cmd=None,
                 defines=None, f90_preprocess=None):

        self.temp_dir = temp_dir
        self.cpp_cmd = cpp_cmd
        self.defines = defines
        self.f90_preprocess = f90_preprocess

    def preprocess(self, sf, add_name="F90PP"):
        """ preprocess the file described by a SourceFile object sf """

        # we want to do:
        # $(FORT_CPP) $(CPPFLAGS) $< | $(F90PREP) > $(f77TempDir)/$*.f90
        # we output to the temporary directory

        processed_file = "{}/{}-{}".format(self.temp_dir, add_name,
                                           os.path.basename(sf.name))

        if self.f90_preprocess != "" and self.f90_preprocess is not None:
            command = "{} {} {} | {}".format(self.cpp_cmd, self.defines,
                                             sf.name, self.f90_preprocess)
        else:
            command = "{} {} {}".format(self.cpp_cmd, self.defines,
                                        sf.name)

        stdout, rc = run(command, outfile=processed_file)

        #if rc == 0:
        sf.cpp_name = processed_file
        #else:
        #    raise ValueError("cpp process failed for {}".format(sf.name))

        return command



#!/usr/bin/env python3

# automatically generate Makefile dependencies for Fortran 90 source.
#
# this will output all the dependency pairs amongst the source files.
#
# tips for debugging:
#
#   -- do `make > out` when building your code.  Any error messages
#      about modules not found will be sent to stderr, so you will
#      easily see them.  Usually this is a case of the regex not
#      capturing how the module is defined
#
#   -- add `--debug` to the `dep.py` commandline (e.g., in
#      `C_mk/Make.rules`).  This will output a file called
#      `dependencies.out` that shows details about what files are
#      parsed, what modules they define, and what modules they require.
#
#   -- a system-provided module won't be found in your file.
#      (e.g. iso_c_binding).  Add any system-provided modules to the
#      `IGNORES` list below

import sys
import io
import re
import os
import argparse
import preprocess

# modules to ignore in the dependencies
IGNORES = ["iso_c_binding", "iso_fortran_env", "omp_lib", "mpi", "cudafor", "openacc", "hdf"]

# regular expression for "{}module{}name", where {} can be any number
# of spaces.  We use 4 groups here, denoted by (), so the name of the
# module is the 4th group
module_re = re.compile(r"^(\s*)([Mm][Oo][Dd][Uu][Ll][Ee])(\s+)((?:[a-z][a-z_0-9]+))",
                       re.IGNORECASE|re.DOTALL)

# regular expression for "{}module{}procedure{}name"
module_proc_re = re.compile(r"(\s*)(module)(\s+)(procedure)(\s+)((?:[a-z][a-z_0-9]+))",
                            re.IGNORECASE|re.DOTALL)

# regular expression for "{}use{}modulename...".  Note this will work for
# use modulename, only: stuff, other stuff'
# see (txt2re.com)
use_re = re.compile(r"^(\s*)([Uu][Ss][Ee])(\s+)((?:[a-z_][a-z_0-9]+))",
                    re.IGNORECASE|re.DOTALL)


class SourceFile(object):
    """ hold information about one of the .f90/.F90 files """

    def __init__(self, filename):

        self.name = filename

        # do we need to be preprocessed?  We'll use the convention
        # that .F90 = yes, .f90 = no
        self.ext = os.path.splitext(filename)[1]

        self.preprocess = bool(self.ext in [".F90", ".F95", ".F03"])

        # when we preprocess, the output file has a different name
        self.cpp_name = None


    def search_name(self):
        """return the file name we use for searching -- this is the
        preprocessed file if it exists"""

        if self.cpp_name is not None:
            search_file = self.cpp_name
        else:
            search_file = self.name

        return search_file


    def obj(self):
        """ the name of the object file we expect to be produced -- this
        will always be based on the original name -- we do not compile the
        preprocessed files """
        return self.name.replace(self.ext, ".o")


    def defined_modules(self):
        """determine what modules this file provides -- we work off of the
        preprocessed file if it exists."""

        defines = []

        with io.open(self.search_name(), "r", encoding="latin-1") as f:

            for line in f:

                # strip off the comments
                idx = line.find("!")
                line = line[:idx]

                # we want a module definition itself, not a 'module procedure'
                # also, Fortran is case-insensitive
                rebreak = module_re.search(line)
                rebreak2 = module_proc_re.search(line)
                if rebreak and not rebreak2:
                    defines.append(rebreak.group(4).lower())

        return defines


    def needed_modules(self):
        """determine what modules this file needs.  Assume only one use
           statement per line.  Ignore any only clauses.  We work off
           of the preprocessed file if it exists."""

        depends = []

        with io.open(self.search_name(), "r", encoding="latin-1") as f:

            for line in f:

                # strip off the comments
                idx = line.find("!")
                line = line[:idx]

                rebreak = use_re.search(line)
                if rebreak:
                    used_module = rebreak.group(4)
                    if used_module.lower() not in IGNORES:
                        depends.append(used_module.lower())

        # remove duplicates
        depends = list(set(depends))

        return depends


def doit(prefix, search_path, files, cpp, debug=False):
    """ main routine that processes the files"""

    if debug:
        df = io.open("dependencies.out", "w", encoding="latin-1")


    # module_files is a dictionary where the keys are the name of the
    # module (as it appears in Fortran code) and the value associated
    # with the key is the name of the object file that provides the
    # module.
    module_files = {}

    # all_files is a list of SourceFile objects
    all_files = []

    # find the locations of all the files, given an (optional) search
    # path and preprocess them if necessary
    for cf in files:

        # find the file in the first part of the search path it exists
        if len(search_path) > 0:
            for p in search_path:
                full_file = "{}/{}".format(p, cf)
                if os.path.isfile(full_file):
                    break
        else:
            full_file = cf

        sf = SourceFile(full_file)

        # preprocess, if necessary
        if sf.preprocess and cpp is not None:
            command = cpp.preprocess(sf)

        if debug:
            df.write("source file: {}\n".format(sf.name))
            if sf.preprocess:
                df.write("preprocessed: {}\n".format(sf.cpp_name))
            df.write("\n")

        all_files.append(sf)

    # for each file, figure out what modules they define and add those to
    # the module_files dictionary -- the module provided is the "key" and
    # the value is the object file corresponding to the source file that
    # holds the module definition
    for sf in all_files:
        provides = sf.defined_modules()

        for p in provides:
            module_files[p] = sf.obj()

        if debug:
            df.write("source file: {}\n".format(sf.name))
            df.write("provides:\n")
            for p in provides:
                df.write("   {}\n".format(p))
            df.write("\n")

    # go back through the files now and look for the use statements
    # to figure out what modules each file requires
    for sf in all_files:
        depends = sf.needed_modules()

        for d in depends:
            try: provides_obj = module_files[d]
            except KeyError:
                print("warning: module {} required by {} not found".format(d, sf.name),
                      file=sys.stderr)
                print("$(warning module {} required by {} not found)".format(d, sf.name))
                continue

            # skip the case where a file provides the module it needs
            # on its own; otherwise output the dependency line
            if provides_obj != sf.obj():
                print("{}: {}".format(
                    prefix+os.path.basename(sf.obj()),
                    prefix+os.path.basename(provides_obj)))

        print(" ")

        if debug:
            df.write("source file: {}\n".format(sf.name))
            df.write("depends on:\n")
            for d in depends:
                df.write("   {}\n".format(d))
            df.write("\n")

    if debug:
        df.close()


if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--prefix",
                        help="prefix to prepend to each dependency pair, e.g., for a build directory",
                        default="")
    parser.add_argument("--search_path",
                        help="ordered path to search for the files",
                        default="")
    parser.add_argument("--cpp",
                        help="command to run C preprocessor on .F90 files first.  If omitted, then no preprocessing is done",
                        default="")
    parser.add_argument("--f90_preprocess",
                        help="command to pipe cpp output to for additional Fortran preprocessing",
                        default="")
    parser.add_argument("--temp_dir",
                        help="directory to put temporary preprocessed files",
                        default="")
    parser.add_argument("--defines",
                        help="defines to send to preprocess the files",
                        default="")
    parser.add_argument("--debug",
                        help="output a detailed log file describing each source file",
                        action="store_true")
    parser.add_argument("files", metavar="source files", type=str, nargs="*",
                        help="F90 source files to find dependencies amongst")

    args = parser.parse_args()

    if args.prefix != "":
        prefix_pass = "{}/".format(os.path.normpath(args.prefix))
    else:
        prefix_pass = "./"

    if args.temp_dir != "":
        temp_dir = args.temp_dir
    else:
        temp_dir = "./"

    # create a preprocessor object
    if args.cpp != "":
        cpp_pass = preprocess.Preprocessor(temp_dir=temp_dir, cpp_cmd=args.cpp,
                                           defines=args.defines,
                                           f90_preprocess=args.f90_preprocess)
    else:
        cpp_pass = None

    try:
        doit(prefix_pass, args.search_path.split(), args.files, cpp_pass, debug=args.debug)
    except:
        # something went wrong
        print("$(error something went wrong in dep.py.  Remake, adding the option 'DEP_CHECK_OPTS=--debug' to your make command and examine the 'dependencies.out' file)")


#!/usr/bin/env python3

import os
import sys
import argparse
from pycparser import parse_file, c_ast

def typechecker(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument("--workdir", required=True)
    parser.add_argument("--output", required=True)
    script_args = parser.parse_args()

    debug = True

    funcs_to_check = []

    # (1) let's collect all c functions we are going to check into a list
    class FuncDeclVisitor(c_ast.NodeVisitor):
        def visit_FuncDecl(self, node):
            funcs_to_check.append(node.type.declname.rstrip('_'))

    for f in os.listdir(script_args.workdir):
        if f.endswith('-cppd.h'):
            fname = os.path.join(script_args.workdir,f)
            if debug:
                print("Checking {0}...".format(f))
            ast = parse_file(fname)
            v = FuncDeclVisitor()
            v.visit(ast)

    # (2) find out which Fortran files have the functions
    func_src = {}
    findFortranSources(funcs_to_check, func_src, script_args.workdir)

    # (3) we visit each function declaration again
    fout = open(script_args.output,'w')

    aux_info = {'numerrors':0, 'numfuncs':0, 'current_c_header':''}

    class FuncDeclVisitor(c_ast.NodeVisitor):
        def visit_FuncDecl(self, node):
            check_doit(node, script_args.workdir, func_src, fout, aux_info)

    for f in os.listdir(script_args.workdir):
        if f.endswith('-cppd.h'):
            fname = os.path.join(script_args.workdir,f)
            fout.write("\nChecking "+fname+"...\n")
            aux_info['current_c_header'] = os.path.basename(fname.replace('-cppd.h','.H'))
            ast = parse_file(fname)
            v = FuncDeclVisitor()
            v.visit(ast)

    fout.close()

    print("{0} functions checked, {1} error(s) found.  More details can be found in {2}."
          .format(aux_info['numfuncs'],aux_info['numerrors'], script_args.output))


def check_doit(node, workdir, func_src, fout, aux_info):
    c_funcname = node.type.declname.rstrip('_')
    if not c_funcname in func_src.keys():
        return
    f_filename = func_src[c_funcname]
    f_ret_type, f_arg_type = getFortranArg(c_funcname, os.path.join(workdir,f_filename))

    if f_ret_type:
        # found a fortran function with that name
        c_ret_type = c_ast_get_type(node.type)
        c_arg_type = []
        if node.args:
            for param in node.args.params:
                typ = c_ast_get_type(param.type).split(' ')
                if len(typ) == 1:
                    c_arg_type.append([typ[0], 'value'])
                elif len(typ) == 2:
                    c_arg_type.append(typ)
                else:
                    print("check_doit: how did this happen? ", typ)
                    sys.exit(1)

        error_msg = []

        error_msg.append("\nFunction "+c_funcname+" in "+aux_info['current_c_header']+
                         " vs. Fortran procedure in "+f_filename.replace(".orig",'')+"\n")
        fout.write(error_msg[-1])

        if c_to_f_type(c_ret_type) == f_ret_type:
            fout.write("    C return type {0} matches Fortran {1}.\n"
                       .format(c_ret_type,f_ret_type))
        else:
            error_msg.append("    C return type {0} does NOT match Fortran {1}.\n"
                             .format(c_ret_type,f_ret_type))
            fout.write(error_msg[-1])

        if len(c_arg_type) == len(f_arg_type):
            fout.write("    number of arguments {0} matches {1}.\n"
                       .format(len(c_arg_type),len(f_arg_type)))
        else:
            error_msg.append("    number of arguments {0} does NOT match {1}.\n"
                             .format(len(c_arg_type),len(f_arg_type)))
            fout.write(error_msg[-1])

        cnt = 0
        for ctyp,ftyp in zip(c_arg_type, f_arg_type):
            cnt = cnt+1
            # exact match, or * == type(c_ptr), value, or void* == any Fortran 'reference'
            if c_to_f_type(ctyp[0]) == ftyp[0] and ctyp[1] == ftyp[1] or \
               ctyp[1] == "pointer" and ftyp[0] == "DERIVED c_ptr" and ftyp[1] == "value" or \
               ctyp[0] == "void" and ctyp[1] == "pointer" and ftyp[1] == "pointer":
                fout.write("    arg #{0}: C type {1} matches Fortran type {2}.\n"
                           .format(cnt, ctyp, ftyp))
            else:
                error_msg.append("    arg #{0}: C type {1} does NOT match Fortran type {2}.\n"
                                 .format(cnt, ctyp, ftyp))
                fout.write(error_msg[-1])

        if len(error_msg) > 1:
            aux_info['numerrors'] = aux_info['numerrors']+1
            for msg in error_msg:
                print(msg,end='')
        # note some C declarations may not have Fortran function defined
        # those don't count in numfuncs
        aux_info['numfuncs'] = aux_info['numfuncs']+1


def c_to_f_type(ctyp):
    # supported C types: char, short, int, long, float, double, void, _Bool
    if ctyp == 'char':
        return 'CHARACTER 1 1'
    elif ctyp == 'int8_t':
        return 'INTEGER 1'
    elif ctyp == 'short':
        return 'INTEGER 2'
    elif ctyp == 'int':
        return 'INTEGER 4'
    elif ctyp == 'long':
        return 'INTEGER 8'  # yes, this is our assumption
    elif ctyp == 'float':
        return 'REAL 4'
    elif ctyp == 'double':
        return 'REAL 8'
    elif ctyp == 'amrex_real':
        return 'REAL 8'
    elif ctyp == 'void':
        return 'void'
    elif ctyp == '_Bool':
        return 'LOGICAL 1'


def c_ast_get_type(decl):
    typ = type(decl)
    if typ == c_ast.IdentifierType:
        #return ' '.join(decl.names)
        return decl.names[0]
    elif typ == c_ast.PtrDecl or typ == c_ast.ArrayDecl:
        return c_ast_get_type(decl.type) + ' pointer'
    else:
        return c_ast_get_type(decl.type)


def findFortranSources(funcs, func_src, workdir):
    for fname in os.listdir(workdir):
        if fname.endswith('.orig'):
            f = open(os.path.join(workdir,fname), 'r')
            for line in f.readlines():
                if "procedure name = " in line:
                    pname = line.split('=')[1].strip()
                    if pname in funcs:
                        if pname in func_src.keys():
                            print("two sources for", pname, "in", func_src[pname],
                                  "and", fname)
                            sys.exit(1)
                        else:
                            func_src[pname] = fname


def getFortranArg(funcname, fortranfile):
    """given a function name and a gortran tree original file, return a
        tuple of function return type and list of arguments.  For
        example, (INTEGER 4, [('INTERGER 4', 'value'), ('REAL 8',
        'pointer')]).  Note that pointer here is not Fortran pointer.
    """

    debug = False

    module_tok = "symtree: '" + funcname + "'"
    proc_tok = "procedure name = " + funcname + "\n"
    this_func = []
    f = open(fortranfile, 'r')
    # let's collect the text of this function into a list of strings
    in_module_block = False
    ws_module_block = 0
    in_proced_block = False
    ws_proced_block = 0
    numblocks = 0
    for line in f.readlines():
        if line.isspace(): continue
        num_white_spaces = len(line) - len(line.lstrip())
        if module_tok in line and not in_proced_block:
            this_func.append(line)
            in_module_block = True
            ws_module_block = num_white_spaces
            in_proced_block = False
            ws_proced_block = 0
            numblocks = numblocks + 1
        elif proc_tok in line and not in_module_block:
            this_func.append(line)
            in_proced_block = True
            ws_proced_block = num_white_spaces
            in_module_block = False
            ws_module_block = 0
            numblocks = numblocks + 1
        elif in_module_block:
            if ws_module_block < num_white_spaces:
                this_func.append(line)
            else:
                in_module_block = False
                ws_module_block = 0
                if numblocks == 2:
                    break
        elif in_proced_block:
            if line.strip() != "code:" and ws_proced_block < num_white_spaces:
                this_func.append(line)
            else:
                in_proced_block = False
                ws_proced_block = 0
                if numblocks == 2:
                    break
    f.close()
    if not this_func:
        print(fortranfile, "doesn't contain", function)

    if debug:
        print(funcname, "this_func...")
        for line in this_func:
            print(line,)

    return_type = ''
    arguments_type = []
    found = False
    ws = 0
    arglist = []

    def parse_type_spec(line):
        # The line may look like, type spec : (REAL 8 C_INTEROP)
        #                     or  type spec : (UNKNOWN 0 C_INTEROP)
        #                     or  type spec : (INTEGER 4)
        #                     or  type spec : (CHARACTER 1 1 C_INTEROP ISO_C)
        if "UNKNOWN" in line:
            type_spec = 'void'
        else:
            type_spec = line.split('(')[1].split(')')[0].split('C_INTEROP')[0].strip()
        return type_spec

    for line in this_func:
        num_white_spaces = len(line) - len(line.lstrip())
        # searching for blocks like
        #   symtree: 'fort_fab_copy'|| symbol: 'fort_fab_copy'
        #     type spec : (UNKNOWN 0)
        #     attributes: (PROCEDURE MODULE-PROC  BIND(C) SUBROUTINE)
        #     Formal arglist: lo hi dst dlo dhi src slo shi sblo ncomp
        if "symtree: '"+funcname+"'" in line: # e.g.
            found = True
            ws = num_white_spaces
        elif found:
            if ws < num_white_spaces:
                if "type spec :" in line:
                    return_type = parse_type_spec(line)
                elif "Formal arglist:" in line:
                    arglist = line.replace("Formal arglist:", "").split()
            else:
                break

    if arglist:
        func_args = {}
        found = False
        argname = ''
        argtype = ''
        for line in this_func:
            # search for blocks like
            #   symtree: 'dhi'         || symbol: 'dhi'
            #     type spec : (INTEGER 4)
            #     attributes: (VARIABLE  DIMENSION DUMMY(IN))
            #     Array spec:(1 [0] AS_EXPLICIT 1 3 )
            if "symtree: '" in line:
                argname = line.split("'")[1]
                if argname in arglist:
                    found = True
            elif found:
                if "type spec :" in line:
                    argtype = parse_type_spec(line)
                elif "attributes:" in line: # attributes: (VARIABLE  VALUE DUMMY(IN))
                    if "VALUE" in line:
                        argattrib = 'value'
                    else:
                        argattrib = 'pointer'
                    found = False
                    func_args[argname] = (argtype, argattrib, argname)
                    if len(func_args) == len(arglist):
                        break
        if len(func_args) != len(arglist):
            print("getFortranArg: len != len", funcname, func_args, arglist)
            sys.exit(1)

        if debug:
            print ("-------")
            print(arglist)
            print(func_args)
            print ("-------")

        for a in arglist:
            arguments_type.append(func_args[a])

    return return_type, arguments_type

if __name__ == "__main__":
    typechecker(sys.argv)


See `Docs/Migration/`.


import numpy as np

def write_paraview_file_structmesh(fname,xp,yp,ccdata,ncdata):

    outfile=open(fname,'w')

    Npx=xp.shape[1]
    Npy=xp.shape[0]
    zero=0
    one=1

    outfile.write("<?xml version=\"1.0\"?>\n")
    outfile.write("<VTKFile type=\"StructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n")
    outfile.write("<StructuredGrid WholeExtent=\"%d %d %d %d %d %d\">\n"%(one,Npx,one,Npy,one,one))

    #piece extent is useful when writing in parallel
    #it corresponds to extents for each processor in global coordinates, eg: 1-2 is proc 0, 3-4 is proc 0
    outfile.write("<Piece Extent=\"%d %d %d %d %d %d\">\n"%(one,Npx,one,Npy,one,one))

    outfile.write("<PointData>\n")
    n_ncdata=ncdata.shape[0]
    if(n_ncdata > 0):
        for ndataset in range(n_ncdata):
            outfile.write("<DataArray type=\"Float32\" Name=\"node_data%d\" format=\"ascii\">\n"%(ndataset))
            for i in range(ncdata.shape[1]):
                outfile.write("%e\t"%(ncdata[ndataset][i]))
            outfile.write("\n</DataArray>\n")
    outfile.write("</PointData>\n")

    outfile.write("<CellData>\n")
    n_ccdata=ccdata.shape[0]
    if(n_ccdata > 0):
        for ndataset in range(n_ccdata):
            outfile.write("<DataArray type=\"Float32\" Name=\"cell_data%d\" format=\"ascii\">\n"%(ndataset))
            for i in range(ccdata.shape[1]):
                outfile.write("%e\t"%(ccdata[ndataset][i]))
            outfile.write("\n</DataArray>\n")
    outfile.write("</CellData>\n")

    outfile.write("<Points>\n")

    outfile.write("<DataArray type=\"Float32\" NumberOfComponents=\"3\" format=\"ascii\">\n")
    for j in range(Npy):
        for i in range(Npx):
            outfile.write("%e\t%e\t%e\t"%(xp[j][i],yp[j][i],zero))
    outfile.write("\n</DataArray>\n")

    outfile.write("</Points>\n")
    outfile.write("</Piece>\n")
    outfile.write("</StructuredGrid>\n")
    outfile.write("</VTKFile>")

def write_paraview_file_unst_trimesh(fname,pts,conn,ccdata,ncdata):

    outfile=open(fname,'w')

    Npts=pts.shape[0]
    Ntri=conn.shape[0]
    zero=0

    outfile.write("<?xml version=\"1.0\"?>\n")
    outfile.write("<VTKFile type=\"UnstructuredGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n")
    outfile.write("<UnstructuredGrid>\n")
    outfile.write("<Piece NumberOfPoints=\"%d\" NumberOfCells=\"%d\">\n"%(Npts,Ntri))

    outfile.write("<PointData>\n")
    n_ncdata=ncdata.shape[0]
    if(n_ncdata > 0):
        for ndataset in range(n_ncdata):
            outfile.write("<DataArray type=\"Float32\" Name=\"Point_data%d\" format=\"ascii\">\n"%(ndataset))
            for i in range(ncdata.shape[1]):
                outfile.write("%e "%(ncdata[ndataset][i]))
            outfile.write("\n</DataArray>\n")
    outfile.write("</PointData>\n")

    outfile.write("<CellData>\n")
    n_ccdata=ccdata.shape[0]
    if(n_ccdata > 0):
        for ndataset in range(n_ccdata):
            outfile.write("<DataArray type=\"Float32\" Name=\"Cell_data%d\" format=\"ascii\">\n"%(ndataset))
            for i in range(ccdata.shape[1]):
                outfile.write("%e "%(ccdata[ndataset][i]))
            outfile.write("\n</DataArray>\n")
    outfile.write("</CellData>\n")

    outfile.write("<Points>\n")
    outfile.write("<DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\">\n")
    for i in range(Npts):
        outfile.write("%e\t%e\t%e\t"%(pts[i][0],pts[i][1],zero))
    outfile.write("\n</DataArray>\n")
    outfile.write("</Points>\n")

    outfile.write("<Cells>\n")
    outfile.write("<DataArray type=\"Int64\" Name=\"connectivity\" format=\"ascii\">\n")
    for i in range(Ntri):
        for j in range(3):
            outfile.write("%d "%(conn[i][j]))
    outfile.write("\n</DataArray>\n")

    outfile.write("<DataArray type=\"Int64\" Name=\"offsets\" format=\"ascii\">\n")
    for i in range(Ntri):
        offs=3*(i+1)
        outfile.write("%d "%(offs))
    outfile.write("\n</DataArray>\n")
    outfile.write("<DataArray type=\"Int64\" Name=\"types\" format=\"ascii\">\n")
    for i in range(Ntri):
        tri_type=5
        outfile.write("%d "%(tri_type))
    outfile.write("\n</DataArray>\n")

#note, different types are
#triangle - 5
#quad     - 9
#tetrahedron - 10
#hexahedron  - 12
#prism       - 13
#pyramid     - 14

    outfile.write("</Cells>\n")
    outfile.write("</Piece>\n")
    outfile.write("</UnstructuredGrid>\n")
    outfile.write("</VTKFile>\n")

    outfile.close()

def write_paraview_file_cartmesh(fname,dx,prob_lo,N,ncdata,ccdata):

    one=1
    outfile=open(fname,'w')
    outfile.write("<?xml version=\"1.0\"?>\n")
    outfile.write("<VTKFile type=\"RectilinearGrid\" version=\"0.1\" byte_order=\"LittleEndian\">\n")
    outfile.write("<RectilinearGrid WholeExtent=\"%d\t%d\t%d\t%d\t%d\t%d\">\n"%(one,N[0],one,N[1],one,one))
    outfile.write("<Piece Extent=\"%d\t%d\t%d\t%d\t%d\t%d\">\n"%(one,N[0],one,N[1],one,one))

    outfile.write("<PointData>\n")
    n_ncdata=ncdata.shape[0]
    if(n_ncdata > 0):
        for ndataset in range(n_ncdata):
            outfile.write("<DataArray type=\"Float32\" Name=\"Point_data%d\" format=\"ascii\">\n"%(ndataset))

            for i in range(ncdata.shape[1]):
                outfile.write("%e "%(ncdata[ndataset][i]))
            outfile.write("\n</DataArray>\n")
    outfile.write("</PointData>\n")

    outfile.write("<CellData>\n")
    n_ccdata=ccdata.shape[0]
    if(n_ccdata > 0):
        for ndataset in range(n_ccdata):
            outfile.write("<DataArray type=\"Float32\" Name=\"Cell_data%d\" format=\"ascii\">\n"%(ndataset))
            for i in range(ccdata.shape[1]):
                outfile.write("%e "%(ccdata[ndataset][i]))
            outfile.write("\n</DataArray>\n")
    outfile.write("</CellData>\n")

    outfile.write("<Coordinates>\n")

    outfile.write("<DataArray type=\"Float32\" Name=\"X\"  format=\"ascii\">\n")
    for i in range(N[0]):
        outfile.write("%e\t"%(prob_lo[0]+i*dx[0]))
    outfile.write("\n</DataArray>\n")

    outfile.write("<DataArray type=\"Float32\" Name=\"Y\"  format=\"ascii\">\n")
    for i in range(N[1]):
        outfile.write("%e\t"%(prob_lo[1]+i*dx[1]))
    outfile.write("\n</DataArray>\n")

    outfile.write("<DataArray type=\"Float32\" Name=\"Z\"  format=\"ascii\">\n")
    outfile.write("%e\t"%(0.0))
    outfile.write("\n</DataArray>\n")

    outfile.write("</Coordinates>\n")
    outfile.write("</Piece>\n")
    outfile.write("</RectilinearGrid>\n")
    outfile.write("</VTKFile>")

    outfile.close()


def write_paraview_file_particles(fname,pts,ncdata):

    outfile=open(fname,'w')

    Npts=pts.shape[0]

    outfile.write("<?xml version=\"1.0\"?>\n")
    outfile.write("<VTKFile type=\"PolyData\" version=\"0.1\" byte_order=\"LittleEndian\">\n")
    outfile.write("<PolyData>\n")
    outfile.write("<Piece NumberOfPoints=\"%d\" NumberOfVerts=\"0\" NumberOfLines=\"0\" NumberOfStrips=\"0\" NumberOfPolys=\"0\">\n"%(Npts))

    outfile.write("<PointData>\n")
    n_ncdata=ncdata.shape[0]
    if(n_ncdata > 0):
        for ndataset in range(n_ncdata):
            outfile.write("<DataArray type=\"Float32\" Name=\"Point_data%d\" format=\"ascii\">\n"%(ndataset))
            for i in range(ncdata.shape[1]):
                outfile.write("%e "%(ncdata[ndataset][i]))
            outfile.write("\n</DataArray>\n")
    outfile.write("</PointData>\n")

    outfile.write("<Points>\n")
    outfile.write("<DataArray type=\"Float32\" Name=\"Points\" NumberOfComponents=\"3\" format=\"ascii\">\n")
    for i in range(Npts):
        outfile.write("%e\t%e\t%e\t"%(pts[i][0],pts[i][1],pts[i][2]))
    outfile.write("\n</DataArray>\n")
    outfile.write("</Points>\n")

    outfile.write("</Piece>\n")
    outfile.write("</PolyData>\n")
    outfile.write("</VTKFile>\n")

    outfile.close()


import numpy as np
from sys import argv
from write_pview_file import write_paraview_file_particles

def read_amrex_ascii_particle_file(fname):

    infile=open(fname,'r')
    line=infile.readline()
    nparticles=int(line.split()[0])

    line_ignore1=infile.readline()
    line_ignore2=infile.readline()
    line_ignore3=infile.readline()
    line_ignore4=infile.readline()

    particle_pos=np.zeros((nparticles,3))

    for i in range(nparticles):
        spltline=infile.readline().split()
        particle_pos[i][0]=float(spltline[0])
        particle_pos[i][1]=float(spltline[1])
        particle_pos[i][2]=float(spltline[2])

    return(particle_pos,nparticles)


if __name__ == "__main__":

    filenum_min=int(argv[1])
    filenum_max=int(argv[2])
    file_prefix=argv[3]

    nfiles=filenum_max-filenum_min+1
    ncdata=np.array([])
    for i in range(nfiles):
        filename=file_prefix+"%5.5d"%(filenum_min+i)
        (ppos,npart)=read_amrex_ascii_particle_file(filename)
        write_paraview_file_particles(filename+".vtp",ppos,ncdata)




import numpy as np
import sys
from write_pview_file import write_paraview_file_particles

class AMReXParticleHeader(object):
    '''

    This class is designed to parse and store the information
    contained in an AMReX particle header file.

    Usage:

        header = AMReXParticleHeader("plt00000/particle0/Header")
        print(header.num_particles)
        print(header.version_string)

    etc...

    '''

    def __init__(self, header_filename):

        self.real_component_names = []
        self.int_component_names = []
        with open(header_filename, "r") as f:
            self.version_string = f.readline().strip()

            particle_real_type = self.version_string.split('_')[-1]
            if particle_real_type == 'double':
                self.real_type = np.float64
            elif particle_real_type == 'single':
                self.real_type = np.float32
            else:
                raise RuntimeError("Did not recognize particle real type.")
            self.int_type = np.int32

            self.dim = int(f.readline().strip())
            self.num_int_base = 2
            self.num_real_base = self.dim
            self.num_real_extra = int(f.readline().strip())
            for i in range(self.num_real_extra):
                self.real_component_names.append(f.readline().strip())
            self.num_int_extra = int(f.readline().strip())
            for i in range(self.num_int_extra):
                self.int_component_names.append(f.readline().strip())
            self.num_int = self.num_int_base + self.num_int_extra
            self.num_real = self.num_real_base + self.num_real_extra
            self.is_checkpoint = bool(int(f.readline().strip()))
            self.num_particles = int(f.readline().strip())
            self.max_next_id = int(f.readline().strip())
            self.finest_level = int(f.readline().strip())
            self.num_levels = self.finest_level + 1

            if not self.is_checkpoint:
                self.num_int_base = 0
                self.num_int_extra = 0
                self.num_int = 0

            self.grids_per_level = np.zeros(self.num_levels, dtype='int64')
            for level_num in range(self.num_levels):
                self.grids_per_level[level_num] = int(f.readline().strip())

            self.grids = [[] for _ in range(self.num_levels)]
            for level_num in range(self.num_levels):
                for grid_num in range(self.grids_per_level[level_num]):
                    entry = [int(val) for val in f.readline().strip().split()]
                    self.grids[level_num].append(tuple(entry))


def read_amrex_binary_particle_file(fn, ptype="particle0"):
    '''

    This function returns the particle data stored in a particular
    plot file and particle type. It returns two numpy arrays, the
    first containing the particle integer data, and the second the
    particle real data. For example, if a dataset has 3000 particles,
    which have two integer and five real components, this function will
    return two numpy arrays, one with the shape (3000, 2) and the other
    with the shape (3000, 5).

    Usage:

        idata, rdata = read_particle_data("plt00000", "particle0")

    '''
    base_fn = fn + "/" + ptype
    header = AMReXParticleHeader(base_fn + "/Header")

    idtype = "(%d,)i4" % header.num_int
    if header.real_type == np.float64:
        fdtype = "(%d,)f8" % header.num_real
    elif header.real_type == np.float32:
        fdtype = "(%d,)f4" % header.num_real
    else:
        sys.exit(1)

    idata = np.empty((header.num_particles, header.num_int ))
    rdata = np.empty((header.num_particles, header.num_real))

    ip = 0
    for lvl, level_grids in enumerate(header.grids):
        for (which, count, where) in level_grids:
            if count == 0: continue
            fn = base_fn + "/Level_%d/DATA_%05d" % (lvl, which)

            with open(fn, 'rb') as f:
                f.seek(where)
                if header.is_checkpoint:
                    ints   = np.fromfile(f, dtype = idtype, count=count)
                    idata[ip:ip+count] = ints

                floats = np.fromfile(f, dtype = fdtype, count=count)
                rdata[ip:ip+count] = floats
            ip += count

    return idata, rdata


if __name__ == "__main__":
    import glob

    if len(sys.argv) < 3:
        print("Usage: python amrex_binary_particles_to_vtp.py <plotfile> <particle_type>")

    fn_pattern = sys.argv[1]
    ptype = sys.argv[2]

    fn_list = glob.glob(fn_pattern)
    fn_list.sort()

    for i, fn in enumerate(fn_list):
        idata, rdata = read_amrex_binary_particle_file(fn, ptype)
        ppos = rdata[:,0:3]   # assumes 3D
        ncdata = rdata[:,3:]
        write_paraview_file_particles(fn+".vtp",ppos,ncdata.T)


The build system requires GNU make >= 3.81 and python >= 2.7.

Typically an application will have its own `GNUmakefile`.  (See
`Tutorials/HelloWorld_C/` for a simple example, or
`Tutorials/AMR_Adv_C_v2/Exec/SingleVortex/` for a lightly more
complicated example.)  `Make.defs` is included near the beginning, and
`Make.rules` is included in the end.  Depending the need,
`GNUmakefile` includes a number of
`$(AMREX_HOME)/Src/xxx/Make.package`, where `xxx` is `Base` etc.
These `Make.package` files add sources to the make system.  An
application also has its own `Make.package`.  The make variables for
the sources are:

* `CEXE_sources` for C++ source files with `.cpp` extension.
* `CEXE_headers` for C++ headers with `.h` or `.H` extension.
* `cEXE_sources` for C source files with `.c` extension.
* `cEXE_headers` for C headers with `.h` or `.H` extension.
* `f90EXE_sources` for free format Fortran sources with `.f90` extension.
* `F90EXE_sources` for free format Fortran sources with `.F90` extension requiring preprocessing.
* `fEXE_sources` for fixed format Fortran sources with `.f` extension.
* `FEXE_sources` for fixed format Fortran sources with `.F` extension requiring preprocessing.

The variable `AMREX_HOME` points to the path to AMReX.  It must be
set either in the makefile or via the shell's environment variable.

Typically one types `make` to build an executable.  Other useful
commands include:

* `make cleanconfig` removes the executable, `.o` files, and the resulting files of preprocessing.
* `make clean` removes all files generated by the make system.
* `make help` shows the rules for compilation.
* `make print-xxx` shows the value of `xxx`.  This is very useful for
  debugging.
* `make file_locations` shows the path of each file.
* `make tags` and `make TAGS` generate tag files using `ctags` and `etags`, respectively.

The `Make.defs` includes the following files in the listed order:

* `Make.machines`: This file defines three variables, `which_site`,
  `which_computer`, and `host_name`.  For example, `which_site` is
  `nersc` and `which_computer` is `cori` on NERSC's Cori system.  If
  the machine is unknown to the build system, `which_site` and
  `which_computer` are defined as `unknown`.  The `host_name` variable
  is set to the environment variable `HOSTNAME` if defined.
  Otherwise, it is set to the environment variable `HOST`.  If neither
  `HOSTNAME` nor `HOST` is defined, `host_name` is defined to the
  result of `hostname -f` shell command.

* `comps/xxx.mak`: Here `xxx` is either `gnu`, or `intel`, or `pgi`,
  or `cray` depending on the make variable `COMP`, which must be set
  either in `GNUmakefile` or via command line (e.g., `make COMP=gNu`).
  Note that the compiler name is case insensitive.  This file defines
  compiler specific variables.   Usually it must define:

  * `CXX`: C++ compiler.
  * `CC`: C compiler.
  * `FC`: Fortran compiler for fixed format files.
  * `F90`: Fortran compiler for free format files.
  * `CXXFLAGS`: Flags for C++ compiler.
  * `CFLAGS`: Flags for C compiler.
  * `FFLAGS`: Flags for fixed format Fortran compiler.
  * `F90FLAGS`: Flags for free format Fortran compiler.
  * `DEFINES`: This defines the macros passed the compilers.

  Type `make help` for more details on the compilation rules.

* `tools/Make.xxx`: Here `xxx` is an optional tool such as VTune, if
  it is used.

* `packages/Make.xxx`: Here `xxx` is an optional external package such
  as HPGMG, if it is used.

* `sites/Make.xxx`: Here which file to include is resolved as follows.
  If a file `$(AMREX_HOME)/Tools/GNUMake/sites/Make.$(host_name)`
  exists, it is included.  Otherwise,
  `$(AMREX_HOME)/Tools/GNUMake/sites/Make.$(which_site)` is included.
  Note that both `host_name` and `which_site` are defined in
  `Make.machines`.  This file is used for site specific setup.
  Typically this is used for MPI related setup.  The file
  `sites/Make.unknown` contains a generic setup for using MPI
  wrappers.  Note that when MPI is used Fortran 90 MPI library may
  also need to be linked to because it is used in parts of AMReX.

* `Make.local`: This file is not in the AMReX repository.  It is the
  last file included in `Make.defs`, if it exists.  It is meant for a
  purely local setup that can override the setup in previously
  included files.  See `Make.local.template` for examples.

The build system uses the `vpath` directive to specify a list of
directories to be searched for files.  The list of directories is
defined in the `VPATH_LOCATIONS` variables.  An application code
should add its own source directories to the variable.  The build system
also implicitly adds the current directory to the top of the list.  So
a file in the current directory will hide a file with the same name
but stored in different a directory.

The `INCLUDE_LOCATIONS` variable specifies for the compilers a list
directories to be searched for header files.  Each directory specified
in `INCLUDE_LOCATIONS` will be passed to the compilers with a `-I`
prefix.  An application code should add its own header file
directories to the variable.

The C++ compiler specified in the variable `CXX` is used for linking.
The variables `LIBRARIES` and `XTRALIBS` are used to form a variable
called `libraries`, which is used to specify the libraries to be
linked.  The locations for searching the libraries are specified in
variable `LIBRARY_LOCATIONS`.  Each directory in `LIBRARY_LOCATIONS`
will be prefixed with `-L` and passed to the compilers.

See User's Guide for more information on various build options (e.g.,
`USE_MPI`).


project(AMReX-PlotfileTools
   DESCRIPTION "AMReX tools to postprocess plot files"
   )

# Plotfile tools requires only AMReX sources from Src/Base which get always
# compiled, so no need to check which part of AMReX is enabled by user

# List of plotfile targets
set(_exe_names
   fboxinfo
   fcompare
   fextract
   fextrema
   fgradient
   fnan
   fsnapshot
   ftime
   fvarnames
   fvolumesum
   )

# Build targets one by one
foreach( _exe IN LISTS _exe_names)
   add_executable(${_exe} ${_exe}.cpp)
   add_executable(AMReX::${_exe} ALIAS ${_exe})
   target_link_libraries(${_exe} PRIVATE amrex)
   if (AMReX_CUDA)
      set_source_files_properties(${_exe}.cpp PROPERTIES LANGUAGE CUDA)
   endif()

    # Add prefix to each tool's name to make them unique when installed.
    # This avoids potential collisions of names on user systems, e.g., in
    # software packages (Spack/Conda/Debian/...).
    set_target_properties(${_exe} PROPERTIES OUTPUT_NAME "amrex_${_exe}")
endforeach()


# target snapshot needs a special treatment
target_include_directories(fsnapshot PRIVATE ${CMAKE_CURRENT_SOURCE_DIR})
target_sources(fsnapshot PRIVATE AMReX_PPMUtil.H AMReX_PPMUtil.cpp)
if (AMReX_CUDA)
   set_source_files_properties(AMReX_PPMUtil.cpp PROPERTIES LANGUAGE CUDA)
   target_compile_features(fsnapshot PUBLIC cxx_std_17)
endif()


#!/usr/bin/env python3

import argparse

import os
import datetime
import subprocess


source = """
namespace amrex {

const char* buildInfoGetBuildDate() {

  static const char BUILD_DATE[] = "@@BUILD_DATE@@";
  return BUILD_DATE;
}

const char* buildInfoGetBuildDir() {

  static const char BUILD_DIR[] = "@@BUILD_DIR@@";
  return BUILD_DIR;
}

const char* buildInfoGetBuildMachine() {

  static const char BUILD_MACHINE[] = "@@BUILD_MACHINE@@";
  return BUILD_MACHINE;
}

const char* buildInfoGetAMReXDir() {

  static const char AMREX_DIR[] = "@@amrex_home@@";
  return AMREX_DIR;
}

const char* buildInfoGetComp() {

  static const char COMP[] = "@@COMP@@";
  return COMP;
}

const char* buildInfoGetCompVersion() {

  static const char COMP_VERSION[] = "@@COMP_VERSION@@";
  return COMP_VERSION;
}

// deprecated
const char* buildInfoGetFcomp() {

  static const char FCOMP[] = "@@FCOMP@@";
  return FCOMP;
}

// deprecated
const char* buildInfoGetFcompVersion() {

  static const char FCOMP_VERSION[] = "@@FCOMP_VERSION@@";
  return FCOMP_VERSION;
}

const char* buildInfoGetCXXName() {

  static const char CXX_comp_name[] = "@@CXX_comp_name@@";
  return CXX_comp_name;
}

const char* buildInfoGetFName() {

  static const char F_comp_name[] = "@@F_comp_name@@";
  return F_comp_name;
}

const char* buildInfoGetCXXFlags() {

  static const char CXX_flags[] = "@@CXX_flags@@";
  return CXX_flags;
}

const char* buildInfoGetFFlags() {

  static const char F_flags[] = "@@F_flags@@";
  return F_flags;
}

const char* buildInfoGetLinkFlags() {

  static const char link_flags[] = "@@link_flags@@";
  return link_flags;
}

const char* buildInfoGetLibraries() {

  static const char libraries[] = "@@libraries@@";
  return libraries;
}

const char* buildInfoGetAux(int i) {

  //static const char AUX1[] = "${AUX[1]}";
  @@AUX_DECLS@@
  static const char EMPT[] = "";

  switch(i)
  {
    @@AUX_CASE@@
    default: return EMPT;
  }
}

int buildInfoGetNumModules() {
  // int const num_modules = X;
  @@NUM_MODULES@@
  return num_modules;
}

const char* buildInfoGetModuleName(int i) {

  //static const char MNAME1[] = "${MNAME[1]}";
  @@MNAME_DECLS@@
  static const char EMPT[] = "";

  switch(i)
  {
    @@MNAME_CASE@@
    default: return EMPT;
  }
}

const char* buildInfoGetModuleVal(int i) {

  //static const char MVAL1[] = "${MVAL[1]}";
  @@MVAL_DECLS@@
  static const char EMPT[] = "";

  switch(i)
  {
    @@MVAL_CASE@@
    default: return EMPT;
  }
}

const char* buildInfoGetGitHash(int i) {

  //static const char HASH1[] = "${GIT[1]}";
  @@GIT_DECLS@@
  static const char EMPT[] = "";

  switch(i)
  {
    @@GIT_CASE@@
    default: return EMPT;
  }
}

const char* buildInfoGetBuildGitHash() {

  //static const char HASH[] = "${GIT}";
  @@BUILDGIT_DECLS@@

  return HASH;
}

const char* buildInfoGetBuildGitName() {

  //static const char NAME[] = "";
  @@BUILDGIT_NAME@@

  return NAME;
}

#ifdef AMREX_USE_CUDA
const char* buildInfoGetCUDAVersion() {

  static const char CUDA_VERSION[] = "@@CUDA_VERSION@@";
  return CUDA_VERSION;
}
#endif

}
"""

def runcommand(command):
    p = subprocess.Popen(command.split(), stdout=subprocess.PIPE)
    out = p.stdout.read()
    return out.strip().decode("ascii")

def get_git_hash(d, git_style):
    cwd = os.getcwd()
    os.chdir(d)
    try:
        ghash = runcommand("git describe " + git_style)
    except:
        ghash = ""
    os.chdir(cwd)
    return ghash


if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    parser.add_argument("--amrex_home", help="path to the AMReX source",
                        type=str, default="")

    parser.add_argument("--COMP",
                        help="Compiler system defined in AMReX's build system",
                        type=str, default="")

    parser.add_argument("--COMP_VERSION", help="Compiler version",
                        type=str, default="")

    parser.add_argument("--CXX_comp_name",
                        help="C++ compiler command", type=str, default="")

    parser.add_argument("--CXX_flags",
                        help="C++ compiler flags", type=str, default="")

    parser.add_argument("--FCOMP",
                        help="Fortran compiler as defined by AMReX's build system (deprecated)",
                        type=str, default="")

    parser.add_argument("--FCOMP_VERSION",
                        help="Fortran compiler version (deprecated)",
                        type=str, default="")

    parser.add_argument("--F_comp_name", help="Fortran compiler command",
                        type=str, default="")

    parser.add_argument("--F_flags", help="Fortran compiler flags",
                        type=str, default="")

    parser.add_argument("--CUDA_VERSION", help="CUDA version",
                        type=str, default="")

    parser.add_argument("--link_flags", help="linker flags", type=str, default="")

    parser.add_argument("--libraries", help="libraries linked", type=str, default="")

    parser.add_argument("--AUX",
                        help="auxiliary information (EOS, network path) (deprecated)",
                        type=str, default="")

    parser.add_argument("--MODULES",
                       help="module information in the form of key=value (e.g., EOS=helmeos)",
                       type=str, default="")

    parser.add_argument("--GIT",
                        help="the directories whose git hashes we should capture",
                        type=str, default="")


    parser.add_argument("--build_git_name",
                        help="the name of the build directory if different from the main source -- we'll get the git hash of this.",
                        type=str, default="")

    parser.add_argument("--build_git_dir",
                        help="the full path to the build directory that corresponds to build_git_name",
                        type=str, default="")

    parser.add_argument("--GIT_STYLE",
                        help="style options for the 'git describe' command used to construct hash strings",
                        type=str, default="--always --tags --dirty")


    # parse and convert to a dictionary
    args = parser.parse_args()

    # build stuff
    build_date = str(datetime.datetime.now())
    build_dir = os.getcwd()
    build_machine = runcommand("uname -a")


    # git hashes
    running_dir = os.getcwd()

    if args.GIT == "":
        GIT = []
    else:
        GIT = args.GIT.split()

    git_hashes = []
    for d in GIT:
        if d and os.path.isdir(d):
            git_hashes.append(get_git_hash(d, args.GIT_STYLE))
        else:
            git_hashes.append("")

    if args.build_git_dir != "":
        try:
            os.chdir(args.build_git_dir)
        except:
            build_git_hash = "directory not valid"
        else:
            build_git_hash = get_git_hash(args.build_git_dir, args.GIT_STYLE)
            os.chdir(running_dir)
    else:
        build_git_hash = ""


    # modules
    if args.MODULES == "":
        MODULES = []
    else:
        MODULES = args.MODULES.split()

    if len(MODULES) > 0:
        mod_dict = {}
        for m in MODULES:
            k, v = m.split("=")
            mod_dict[k] = v


    # auxiliary info
    if args.AUX == "":
        AUX = []
    else:
        AUX = args.AUX.split()


    fout = open("AMReX_buildInfo.cpp", "w")

    # dictionary view of the args
    dargs = vars(args)

    for line in source.splitlines():

        index = line.find("@@")

        if index >= 0:
            index2 = line.rfind("@@")
            keyword = line[index+len("@@"):index2]

            if keyword == "BUILD_DATE":
                newline = line.replace("@@BUILD_DATE@@", build_date)
                fout.write(newline)

            elif keyword == "BUILD_DIR":
                newline = line.replace("@@BUILD_DIR@@", build_dir)
                fout.write(newline)

            elif keyword == "BUILD_MACHINE":
                newline = line.replace("@@BUILD_MACHINE@@", build_machine)
                fout.write(newline)

            elif keyword == "AUX_DECLS":
                indent = index
                aux_str = ""
                for n, a in enumerate(AUX):
                    aux_str += '{}static const char AUX{:1d}[] = "{}";\n'.format(
                        indent*" ", n+1, a)

                fout.write(aux_str)

            elif keyword == "AUX_CASE":
                indent = index
                aux_str = ""
                for i in range(len(AUX)):
                    aux_str += '{}case {:1d}: return AUX{:1d};\n'.format(
                        indent*" ", i+1, i+1)

                fout.write(aux_str)

            elif keyword == "NUM_MODULES":
                num_modules = len(MODULES)
                indent = index
                fout.write("{}int const num_modules = {};\n".format(
                    indent*" ", num_modules))

            elif keyword == "MNAME_DECLS":
                indent = index
                aux_str = ""
                if len(MODULES) > 0:
                    for i, m in enumerate(list(mod_dict.keys())):
                        aux_str += '{}static const char AUX{:1d}[] = "{}";\n'.format(
                            indent*" ", i+1, m)

                fout.write(aux_str)

            elif keyword == "MNAME_CASE":
                indent = index
                aux_str = ""
                if len(MODULES) > 0:
                    for i, m in enumerate(list(mod_dict.keys())):
                        aux_str += '{}case {:1d}: return AUX{:1d};\n'.format(
                            indent*" ", i+1, i+1)

                fout.write(aux_str)

            elif keyword == "MVAL_DECLS":
                indent = index
                aux_str = ""
                if len(MODULES) > 0:
                    for i, m in enumerate(list(mod_dict.keys())):
                        aux_str += '{}static const char AUX{:1d}[] = "{}";\n'.format(
                            indent*" ", i+1, mod_dict[m])

                fout.write(aux_str)

            elif keyword == "MVAL_CASE":
                indent = index
                aux_str = ""
                if len(MODULES) > 0:
                    for i, m in enumerate(list(mod_dict.keys())):
                        aux_str += '{}case {:1d}: return AUX{:1d};\n'.format(
                            indent*" ", i+1, i+1)

                fout.write(aux_str)

            elif keyword == "GIT_DECLS":
                indent = index
                git_str = ""
                for i, gh in enumerate(git_hashes):
                    git_str += '{}static const char HASH{:1d}[] = "{}";\n'.format(
                        indent*" ", i+1, gh)

                fout.write(git_str)

            elif keyword == "GIT_CASE":
                indent = index
                git_str = ""
                for i in range(len(git_hashes)):
                    git_str += '{}case {:1d}: return HASH{:1d};\n'.format(
                        indent*" ", i+1, i+1)

                fout.write(git_str)

            elif keyword == "BUILDGIT_DECLS":
                indent = index
                git_str = '{}static const char HASH[] = "{}";\n'.format(
                    indent*" ", build_git_hash)
                fout.write(git_str)

            elif keyword == "BUILDGIT_NAME":
                indent = index
                git_str = '{}static const char NAME[] = "{}";\n'.format(
                    indent*" ", args.build_git_name)
                fout.write(git_str)

            elif keyword in dargs:
                # simple replacement using the commandline arguments
                newline = line.replace(f"@@{keyword}@@",
                                       dargs[keyword].replace('"', r'\"'))
                fout.write(newline)

        else:
            fout.write(line)

        fout.write("\n")

    fout.close()


#!/usr/bin/env python3

import argparse
import os
import subprocess


def runcommand(command):
    p = subprocess.Popen(command.split(), stdout=subprocess.PIPE)
    out = p.stdout.read()
    return out.strip().decode("ascii")


def get_git_hash(d):
    cwd = os.getcwd()
    os.chdir(d)
    try:
        hash = runcommand("git describe --always --tags --dirty")
    except:
        hash = ""
    os.chdir(cwd)
    return hash


if __name__ == "__main__":

    parser = argparse.ArgumentParser()

    parser.add_argument("--git_dirs",
                        help="the directories whose git hashes we should capture",
                        type=str, default="")

    parser.add_argument("--git_names",
                        help="the names corresponding to the directories we hash",
                        type=str, default="")

    # parse and convert to a dictionary
    args = parser.parse_args()

    # git hashes
    if args.git_dirs == "":
        git_dirs = []
    else:
        git_dirs = args.git_dirs.split()

    if args.git_names == "":
        git_names = []
    else:
        git_names = args.git_names.split()

    git_hashes = []
    for d in git_dirs:
        if d and os.path.isdir(d):
            git_hashes.append(get_git_hash(d))
        else:
            git_hashes.append("")

    print("\nsource git hashes:")
    for name, ghash in zip(git_names, git_hashes):
        print("  {:20}: {}".format(name, ghash))
    print("\n")


#!/usr/bin/env python3

import sys, os, glob, operator

if __name__ == "__main__":
    dt = float(sys.argv[3])-float(sys.argv[2])
    hours, rem = divmod(dt, 3600)
    minutes, seconds = divmod(rem, 60)
    dtstr = str(int(seconds)) + " seconds"
    if minutes > 0:
        dtstr = str(int(minutes)) + " minutes " + dtstr
    if hours > 0:
        dtstr = str(int(hours)) + " hours " + dtstr
    print("Total build time is", dtstr)
    print("More details are available at", sys.argv[1])
    log_file_name = sys.argv[1]
    log_file_dir = os.path.dirname(log_file_name)
    log_files = glob.glob(os.path.join(log_file_dir,"*.log"))
    build_time_results = {}
    for logf in log_files:
        f = open(logf,'r')
        t0 = float(f.readline())
        t1 = float(f.readline())
        build_time_results[os.path.basename(logf)[:-4]] = t1-t0
        f.close()
    f = open(log_file_name,'w')
    f.write("# (File Name, Built Time in seconds)\n")
    for it in sorted(build_time_results.items(), key=operator.itemgetter(1),reverse=True):
        f.write(str(it)+'\n')
    f.close()


#!/usr/bin/env python3

"""
A script processing ccache log file to make Make file for Clang-Tidy

This generates a makefile for clang-tidying ccache-cache-missing files. This
could be used to speed up clang-tidy in CIs.
"""

import argparse, re, sys

def mmclt(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument("--input",
                        help="Ccache log file",
                        default="ccache.log.txt")
    parser.add_argument("--identifier",
                        help="Unique identifier for finding compilation line in the log file",
                        default="Src/Base")
    # We assume Src/Base can be used as an identifier to distinguish amrex code
    # from cmake's temporary files like build/CMakeFiles/CMakeScratch/TryCompile-hw3x4m/test_mpi.cpp
    parser.add_argument("--output",
                        help="Make file for clang-tidy",
                        default="clang-tidy-ccache-misses.mak")
    args = parser.parse_args()

    fin = open(args.input, "r")
    fout = open(args.output, "w")

    fout.write("CLANG_TIDY ?= clang-tidy\n")
    fout.write("override CLANG_TIDY_ARGS += --extra-arg=-Wno-unknown-warning-option --extra-arg-before=--driver-mode=g++\n")
    fout.write("\n")

    fout.write(".SECONDEXPANSION:\n")
    fout.write("clang-tidy: $$(all_targets)\n")
    fout.write("\t@echo SUCCESS\n\n")

    exe_re = re.compile(r" Executing .*? (-.*{}.*) -c .* -o .* (\S*)".format(args.identifier))

    count = 0
    for line in fin.readlines():
        ret_exe_re = exe_re.search(line)
        if (ret_exe_re):
            fout.write("target_{}: {}\n".format(count, ret_exe_re.group(2)))
            fout.write("\t$(CLANG_TIDY) $(CLANG_TIDY_ARGS) $< -- {}\n".format
                       (ret_exe_re.group(1)))
            fout.write("\ttouch target_{}\n\n".format(count))
            count = count + 1

    fout.write("all_targets =")
    for i in range(count):
        fout.write(" target_{}".format(i))
    fout.write("\n\n")

    fout.write("clean:\n\t$(RM) $(all_targets)\n\n")

    fout.close()
    fin.close()

if __name__ == "__main__":
    mmclt(sys.argv)


'''
Author: Michael Kieburtz (MichaelKieburtz@gmail.com)
Copyright (C) 2021, Modern Electron Inc

Description:
    This script parses the saved stdout output from a simulation run and parses
    the TinyProfile portion at the end. It saves this output in a JSON file that
    can be interpreted by Hatchet (https://github.com/hatchet/hatchet).

Usage:
    python profileparser.py path_to_stdout_file [write_dir]

    Where 'write_dir' is an optional parameter for the directory where the JSON file
    will be saved. If this is not specified the JSON file will be written to the same
    directory as the stdout file.

'''

import os
import re
import json
import argparse


class FullProfile(object):
    """
    Class for parsing, storing and writing the full profile data
    """
    def __init__(self, lines, stdout_path, write_dir=None):
        self.lines = lines
        self.stdout_path = stdout_path
        self.write_dir = write_dir

        if self.write_dir is None:
            self.write_dir = os.path.dirname(self.stdout_path)
            print("write dir", self.write_dir)

        self.profile_dicts = []

    def parse_full_profiling_output(self):
        print("Parsing profiling output...")

        self.function_profiles = []
        # The first 5 lines are not needed for parsing
        del self.lines[0:5]
        excl_count = self.parse_section_of_profiling_output("excl")
        del self.lines[0:excl_count + 5]
        incl_count = self.parse_section_of_profiling_output("incl")

        self.profile_dicts.append({
            "frame" : {"name" : "function_profiles"},
            "metrics" : {},
            "children" : self.function_profiles
        })

        total_count = excl_count + incl_count

        print(f"Finished parsing profile output! Parsed {total_count} profiling strings.")

    def parse_section_of_profiling_output(self, section):
        '''
        Parses either the exclusive or inclusive sections of the TinyProfiler output

        Parameters
        ----------

        section (string): The section to parse the profiling output,
            either 'excl' for exclusive or 'incl' for inclusive.

        Returns
        -------

        The number of lines that were parsed
        '''
        if section != "excl" and section != "incl":
            raise RuntimeError(f"'section' was not either 'excl' or 'incl', instead was {section}")

        count = 0

        for line in self.lines:
            if "------" in line:
                break
            # these lines are of the form "Function()  ncalls  min  avg  max  max_percent"
            # with more spaces than are here

            # replace the multiple spaces with a single space
            line = re.sub(" +", " ", line)
            values = line.split(" ")

            # work backwards through the values in order to capture function names with spaces.
            max_percent = float(values[-1].replace("%", ""))
            max_time = float(values[-2])
            avg = float(values[-3])
            min_time = float(values[-4])
            n_calls = int(values[-5])
            name = "_".join(values[0:-5])

            dict = {
                "frame" : {"name" : name},
                "metrics" : {
                    "n_calls" : n_calls,
                    f"{section}_min" : min_time,
                    f"{section}_avg" : avg,
                    f"{section}_max" : max_time,
                    f"{section}_max_percent" : max_percent
                }
            }

            self.function_profiles.append(dict)
            count = count + 1

        return count

    def write_file(self):
        if not self.profile_dicts:
            raise RuntimeError("write_file called before profile data was parsed!")

        print("Writing profile data json file...")
        with open(os.path.join(self.write_dir, "profile_data.json"), "w") as data_file:
            data_file.write(json.dumps(self.profile_dicts, indent=4))

        print(f"Finished writing json file as '{self.write_dir}/profile_data.json'.")

def main(stdout_path, write_dir=None):
    print(f"Path to stdout file: {stdout_path}")

    output_file = open(stdout_path, "r")

    profile_lines = []
    reached_profile = False
    print("Parsing stdout file...")
    count = 0
    while True:
        line = output_file.readline()

        if not line:
            break

        if reached_profile:
            profile_lines.append(line.strip())
            count = count + 1
        elif "TinyProfiler total time across processes" in line:
            reached_profile = True
            profile_lines.append(line.strip())
            count = count + 1

    print(f"Finished parsing stdout file! Found {count} lines from TinyProfiler.")

    full_profile = FullProfile(profile_lines, stdout_path, write_dir)

    full_profile.parse_full_profiling_output()
    full_profile.write_file()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("stdout_path", type=str, metavar="stdout_path", help="The path to the stdout file")
    parser.add_argument(
        "write_dir", type=str, metavar="write_dir",
        default=None, nargs='?',
        help="The JSON file is written to the specified directory. The default is the directory of the stdout file."
    )
    args = vars(parser.parse_args())
    path = args["stdout_path"]
    write_dir = args["write_dir"]

    main(path, write_dir)


import vtk
from vtk import *
import sys

f = open(sys.argv[1],'r')
outfile = sys.argv[2]

l = f.readline()
l.strip()
tokens = l.split(' ')

Nnodes = int(tokens[0])
Nelts = int(tokens[1])

Points = vtk.vtkPoints()

print("Reading %d nodes..." % Nnodes)
for i in range(Nnodes):
    line = f.readline()
    line.strip()
    d = line.split(' ')
    id = Points.InsertNextPoint(float(d[0]),float(d[1]),float(d[2]))

print("Done")

Triangles = vtk.vtkCellArray()
Triangle = vtk.vtkTriangle()

print("Reading %d elements..." % Nelts)
for i in range(Nelts):
    line = f.readline()
    d = line.split()
    Triangle.GetPointIds().SetId(0,int(d[0])-1)
    Triangle.GetPointIds().SetId(1,int(d[1])-1)
    Triangle.GetPointIds().SetId(2,int(d[2])-1)
    Triangles.InsertNextCell(Triangle)

print("Done")
f.close()


polydata = vtk.vtkPolyData()
polydata.SetPoints(Points)
polydata.SetPolys(Triangles)
polydata.Modified()
if vtk.VTK_MAJOR_VERSION <= 5:
    polydata.Update()

writer = vtk.vtkXMLPolyDataWriter();
writer.SetFileName(outfile);
if vtk.VTK_MAJOR_VERSION <= 5:
    writer.SetInput(polydata)
else:
    writer.SetInputData(polydata)
writer.SetDataModeToBinary()
writer.Write()


#!/usr/bin/env python3

# simple script showing how to make plots of particles using the parseparticles
# module
#

import parseparticles
import pylab

def main(fileList):
    """
    This script shows how to make plots using the parseparticles module.

    usage: ./test.py particleFile1 [particleFile2 particleFile3 ... ]
    """

    # this returns a dict whose keys are a unique identifier (based on
    # id and CPU) and values are the actual particle objects
    particlesDict = parseparticles.parseParticleFile(fileList)

    # get just the particle objects
    particles = particlesDict.values()

    print "there are %d unique particles" % len(particles)

    # plots - this is based on the plotting done in the original
    # parseparticles.py script, which has since become a module for importing
    pylab.clf()

    # global domain extrema
    xmin = 1.e33
    xmax = -1e33
    ymin = 1.e33
    ymax = -1.e33

    # loop over the particle objects and create the particle paths
    for particle in particles:
        coords, time = particle.flatten()

        # find the extrema of the particles over time to make all frames the
        # same size
        xmin = min(xmin,min(coords[0,:]))
        xmax = max(xmax,max(coords[0,:]))
        ymin = min(ymin,min(coords[1,:]))
        ymax = max(ymax,max(coords[1,:]))

        pylab.scatter([coords[0,0]], [coords[1,0]], marker="x")
        pylab.plot(coords[0,:], coords[1,:])

    pylab.xlabel("x")
    pylab.ylabel("y")

    pylab.savefig("particle_paths.png")

    # make an animation -- note: this assumes that all particles exist at all
    # timesteps


    # grab the total number of timesteps from the first particle's history
    # totalSteps = len(particles[0].history)

    # nstep = 0
    # while (nstep < totalSteps):
    #     pylab.clf()

    #     for particle in particles:
    #         pylab.scatter([particle.history[nstep].xyz[0]],
    #                       [particle.history[nstep].xyz[1]],
    #                       marker="o", s=1.0, edgecolor="None")

    #     pylab.xlabel("x")
    #     pylab.ylabel("y")

    #     pylab.axis([xmin,xmax,ymin,ymax])
    #     a = pylab.gca()
    #     a.set_aspect("equal")

    #     pylab.savefig("particles_%04d.png" % nstep)

    #     nstep += 1

if __name__ == "__main__":
    import sys
#    import cProfile

    if len(sys.argv) == 1:
        print main.__doc__
        sys.exit()

    # pass in the particle files as arguments to this function
    main(sys.argv[1:])

# this is for profiling
#    cProfile.run("main(sys.argv[1:])","profile.tmp2")


"""
 a module for parsing MAESTRO particle files

  Particle histories in MAESTRO are stored in a set of files, e.g.
  timestamp_#, where the # in the file name is the number of the CPU
  (actually MPI process) with particles.  As particles advect, they
  may jump to different CPUs, so a given particle's history may
  initially be written out in one file and then switch to a different
  file.  This module sorts the particle data to be in proper time
  order.

  This module should be imported in your own python script, for example:

    >>> import parseparticles
    >>> myparticles = parseparticles.parseParticleFile(myParticleFiles)

    where myParticleFiles is a list of the timestamp files containing
    the particle data.

    This returns a dictionary whose keys are internal ids (comprised
    of the particle's id and its origin CPU) and values are particle
    objects, which contain all of the associated information about a
    particle's history


  Usually we don't care about the original particle ID information, so
  we just strip out the particle objects into a list:

    >>> particles = myparticles.values()

    Here, each item in the list is a particle object.


  Each particle object contains data describing the particle
  identity, as well as a history.  The history itself is a list of
  particleInstance objects.  Each particleInstance object stores
  the state of the particle at an instance in time.  For example:

    >>> time = particles[n].history[i].t

    is the time associated with particleInstance i of particle n.
    There is a unique particleInstance for particle n for every
    timestep of this particle's existence.

    Coordinate information is accessed as:

    >>> x = particles[n].history[i].xyz[0]

    for the x-coordinate (xyz[1] would be y, etc.).

    State data is stored in a numpy array.  The state names
    corresponding to each data element are stored in the main particle
    object and can be looked-up via the getVarIndex() method.  For
    example, to store the density of particle n at timestep i into the
    dens variable, we would do:

    >>> idens = particles[n].getVarIndex("density")
    >>> dens = particles[n].history[i].data[idens]

    Any field that was stored in the original timestamp file would be
    present in the data array (and the name should be available
    via getVarIndex())


  The total number of particles can be found simply as len(particles),
  and the number of particleInstances for a given particle can be
  found as len(particles[n].history)
"""

import sys
import string
import numpy


# a global dictionary to store the particle objects.  Each unique
# particle stored with its own key:value pair -- the key is the unique
# particle ID and the value is the particle object itself.  The
# particle objects in turn contain many particleInstance objects in
# the history.
_particleDict = {}


# this works for < 1000 MPI processes, but should ultimately be something
# dynamic to work for all cases
_idFactor = 1000

#------------------------------------------------------------------------
class particleInstance(object):
    """
       a particleInstance object represents a single instance of a
       particle, and will carry the position, time, and associated
       data.
    """
    __slots__ = ['xyz', 't', 'data']    # memory management

    def __init__(self, xyz, t, data):
        self.xyz = xyz
        self.t = t
        self.data = data



    def __str__(self):
        """
           string representation of the particleInstance for printing
        """
        string = "particle pos:  (%g, %g, %g) \n" %  \
            (self.xyz[0], self.xyz[1], self.xyz[2]) + \
            "         time: %g \n" % (self.t)

        return string



    def value(self):
        """
           return the value of a particleInstance for comparison
           purposes.  The value is simply the time.
        """
        return self.t

    def __cmp__(self, other):
        return cmp(self.value(), other.value())



#------------------------------------------------------------------------
class particle(object):
    """
       a particle object stores a history of a single particle, each
       element of which is a particleInstance object.
    """

    __slots__ = ["pid", "originCPU", "dim", "finalized",
                 "history", "dataNames", "numInstances"]

    def __new__(cls, pid=None, originCPU=None, *args, **kwargs):
        """
           Create a new particle instance in the global _particleDict
           dictionary.
        """

        # before building a new particle, make sure it isn't already
        # built by checking the global _particleDict
        id = pid*_idFactor + originCPU
        if id not in _particleDict:
            obj = object.__new__(cls)
            _particleDict[id] = obj
        return _particleDict[id]



    def __init__(self, pid, originCPU, dim, dataNames):
        """
           initialize a particle object
        """

        # a MAESTRO particle is identified by 2 numbers, the pid and
        # the CPU that it was created on.  Together, these uniquely
        # identify the particle.
        self.pid = pid
        self.originCPU = originCPU

        # dimensionality of particle data
        self.dim = dim

        # finalized is 1 when we have finished adding data and sorted
        # the history in time-order
        self.finalized = 0

        # the history list will store instances of the particle at
        # different times.
        self.history = []

        # the dataNames will store the names of the data associated
        # with each particle instance
        self.dataNames = list(dataNames)

        # keep track of the number of particle history instances we've
        # stored
        self.numInstances = 0



    def addInstance(self, xyz=[-1.0,-1.0,-1.0],t=0.0,
                    dataValues=[]):
        """
           add a particleInstance object to the particle history to
           store a single instance (in time) of this particle
        """

        if (self.finalized == 1):
            print "ERROR: particle data finalized before addInstance call"
            sys.exit(2)


        xyz = numpy.array(xyz)
        dataValues = numpy.array(dataValues)


        # add this particle instance to the particle history
        self.history.append(particleInstance(xyz,t,dataValues))

        self.numInstances += 1



    def finalize(self):
        """
           sort the particle histories in time order (since they may
           have been spread across multiple processors / files.

           finalize() should only be called after all particle data
           has been read in
        """

        # sort the history by time -- the particleInstance objects use
        # time as their value for comparison, so sort() should handle
        # this nicely for us.
        self.history.sort()

        self.finalized = 1



    def flatten(self):
        """
           return numpy arrays with the coordinates and time for all
           instances of this particle
        """

        if (not self.finalized == 1):
            print "ERROR: particle data not finalized before flatten call"
            sys.exit(2)

        coords = numpy.zeros((self.dim, self.numInstances), dtype=numpy.float64)
        time   = numpy.zeros((self.numInstances), dtype=numpy.float64)

        n = 0
        while (n < len(self.history)):
            coords[:,n] = self.history[n].xyz[:self.dim]

            time[n] = self.history[n].t

            n += 1

        return coords, time


    def getVarIndex(self, varname):
        """
           returns the index into the history[].data array corresponding
           to the variable varname
        """

        index = self.dataNames.index(varname)

        return index



    def __str__(self):
        string = "particle ID:           %d \n" % (self.pid) + \
                 "particle origin CPU:   %d \n" % (self.originCPU) + \
                 "dimensionality:        %d \n" % (self.dim) + \
                 "num. stored instances: %d \n" % (self.numInstances) + \
                 "associated data: \n"

        for item in self.dataNames:
            string += "  %s" % (item)

        string += "\n"

        return string


#------------------------------------------------------------------------
def ensure_list(obj):
    """
       make sure an object is a list; used, for example, when a single
       file is passed into the parseParticleFile method
    """

    import types

    if obj is None:
        return [obj]
    if not isinstance(obj, types.ListType):
        return [obj]
    return obj



#-----------------------------------------------------------------------------
def parseParticleFile(maestroParticleFiles):
    """
       read in all the particle data from a file and add each particle
       instance to the _particleDict dictionary, grouping all of the
       history for a unique particle (identified by the pid and
       originCPU) together in a particle object in the dictionary
    """

    haveHeader = 0

    for maestroParticleFile in ensure_list(maestroParticleFiles):

        # read the file line by line
        mf = open(maestroParticleFile, "r")

        for line in mf:

            # skip blank lines
            if line.isspace(): continue

            # look for a header information
            if (line.startswith("#")):

                # store old header, if it exists
                if (haveHeader == 1):
                    oldHeader = list(dataNames)  # list() makes a copy


                fields = string.split(line[1:])

                # make sure we know what we are doing -- the first 2
                # fields should be the particle ID and origin CPU
                if (fields[0] == "part-ID" and fields[1] == "origin-CPU"):
                    ipid = 0
                    ioCPU = 1

                else:
                    print "ERROR: particle file columns not in expected order"
                    sys.exit(2)


                # the next fields should be x, y, and z, depending on the
                # dimensionality
                if (fields[2] == "x" and fields[3] == "y" and
                    fields[4] == "z"):
                    dim = 3
                    ix = 2

                elif (fields[2] == "x" and fields[3] == "y"):
                    dim = 2
                    ix = 2

                elif (fields[2] == "x"):
                    dim = 1
                    ix = 2

                else:
                    print "ERROR: particle file columns not in expected order"
                    sys.exit(2)


                # then comes time
                if (fields[2 + dim] == "time"):
                    it = 2 + dim

                else:
                    print "ERROR: particle file columns not in expected order"
                    sys.exit(2)


                # everything else is associated data
                if (len(fields) > 3 + dim):
                    idata = 3 + dim
                    dataNames = fields[idata:]


                # did the header change?
                if (haveHeader == 1):
                    if (not oldHeader == dataNames):
                        print "ERROR: header changed while parsing files"
                        sys.exit(2)


                # done with the header
                haveHeader = 1
                numData = len(dataNames)
                continue


            # normal particle data -- first find the required particle data
            fields = map(float,string.split(line))

            pid = int(fields[ipid])
            originCPU = int(fields[ioCPU])

            id = pid*_idFactor + originCPU

            xyz = fields[ix:ix+dim]
            time = fields[it]
            dataValues = fields[idata:]

            if (not len(dataValues) == numData):
                print "ERROR: number of data values not equal to number of names"
                sys.exit(2)


            if not id in _particleDict:
                particle(pid, originCPU, dim, dataNames)

            _particleDict[id].addInstance(xyz=xyz,
                                          t=time,
                                          dataValues=dataValues)


    # finish up by making sure that each particle's history is
    # in proper time-order
    for id in _particleDict:
        _particleDict[id].finalize()


    return _particleDict


#!/usr/bin/env python3

# a simple routine to parse particle files and dump out the particle
# histories into separate files (1 file per particle) so that they can
# be plotted elsewhere

import sys
import parseparticles


#-----------------------------------------------------------------------------
def main(files):

    # this returns a dict whose keys are a unique identifier (based on
    # id and CPU) and values are the actual particle objects
    particlesDict = parseparticles.parseParticleFile(files)

    # get just the particle objects
    particles = particlesDict.values()


    # print out some info and test the routines
    print "number of unique particles = ", len(particles)


    # output particle instance info (debugging)
    #n = 0
    #while (n < len(particles)):
    #    print n
    #    print particles[n]
    #    print " "
    #    n += 1


    # dump out the data, particle-by-particle
    n = 0
    while (n < len(particles)):

        # get numpy arrays containing the time and coordinate
        # information for particle 0
        coords, time = particles[n].flatten()
        dim = particles[n].dim

        # output to a file
        of = open("particle_history.%03d" % (n), 'w')

        # header
        #   first the particle id information
        idstuff = str(particles[n])
        for line in idstuff.split("\n"):
            of.write("# %s\n" % (line))

        #   next the column labels
        if (dim == 1):
            of.write("# %20s %20s\n" % ("time", "x"))
        elif (dim == 2):
            of.write("# %20s %20s %20s\n" % ("time", "x", "y"))
        elif (dim == 3):
            of.write("# %20s %20s %20s %20s\n" % ("time", "x", "y", "z"))


        # t, x, [y, [z]] in columns
        i = 0
        while (i < len(particles[n].history)):

            if (dim == 1):
                of.write("  %20.10f %20.10f\n" %
                         (time[i], coords[0,i]))
            elif (dim == 2):
                of.write("  %20.10f %20.10f %20.10f\n" %
                         (time[i], coords[0,i], coords[1,i]))
            elif (dim == 3):
                of.write("  %20.10f %20.10f %20.10f %20.10f\n" %
                         (time[i], coords[0,i], coords[1,i], coords[2,i]))

            i += 1


        of.close()


        n += 1






#-----------------------------------------------------------------------------
if __name__== "__main__":

    if (len(sys.argv) == 1):
        print "ERROR: no particle data files specified\n"
        sys.exit(2)

    main(sys.argv[1:])


#!/usr/bin/env python3

import sys, re
import argparse

def doit(defines, undefines, comp, allow_diff_comp):
    print("#ifndef AMREX_HAVE_NO_CONFIG_H")
    print("#define AMREX_HAVE_NO_CONFIG_H")

    # Remove -I from input
    defines = re.sub(r'-I.*?(-D|$)', r'\1', defines)

    defs = defines.split("-D")
    for d in defs:
        dd = d.strip()
        if dd:
            v = dd.split("=")
            print("#ifndef",v[0])
            if len(v) == 2:
                print("#define",v[0],v[1])
            else:
                print("#define",v[0],1)
            print("#endif")

    for ud in undefines:
        print("#undef",ud)

    print("#ifdef __cplusplus");

    if allow_diff_comp == "FALSE":
        if comp == "gnu" or comp == "nag":
            comp_macro = "__GNUC__"
            comp_id    = "GNU"
        elif comp == "intel" or comp == "intel-classic":
            comp_macro = "__INTEL_COMPILER"
            comp_id    = "Intel"
        elif comp == "intel-llvm":
            comp_macro = "__INTEL_LLVM_COMPILER"
            comp_id    = "Intel"
        elif comp == "cray":
            comp_macro = "_CRAYC"
            comp_id    = "Cray"
        elif comp == "pgi":
            comp_macro = "__PGI"
            comp_id    = "PGI"
        elif comp == "nvhpc":
            comp_macro = "__NVCOMPILER"
            comp_id    = "NVHPC"
        elif comp == "llvm":
            comp_macro = "__llvm__"
            comp_id    = "Clang/LLVM"
        elif comp == "nec":
            comp_macro = "__NEC__"
            comp_id    = "NEC"
        elif comp == "ibm":
            comp_macro = "__ibmxl__"
            comp_id    = "IBM"
        elif comp == "armclang":
            comp_macro = "__armclang_version__"
            comp_id    = "ArmClang"
        elif comp == "hip":
            comp_macro = "__HIP__"
            comp_id    = "HIP"
        elif comp == "sycl":
            comp_macro = "__INTEL_CLANG_COMPILER"
            comp_id    = "SYCL"
        else:
            sys.exit("ERROR: unknown compiler "+comp+" to mkconfig.py")

        msg = "#error libamrex was built with " + comp_id + ". "
        msg = msg + "To avoid this error, reconfigure with --allow-different-compiler=yes"
        print("#ifndef " + comp_macro )
        print(msg)
        print("#endif")

    print("#endif") #  ifdef __cplusplus

    # hipcc does not necessarily set the _OPENMP macro
    # https://rocmdocs.amd.com/en/latest/Programming_Guides/HIP-FAQ.html?highlight=_openmp#openmp-is-undefined-when-compiling-with-fopenmp
    print("#if defined(AMREX_USE_OMP) && !defined(_OPENMP) && !defined(AMREX_USE_HIP)")
    print('#error libamrex was built with OpenMP')
    print("#endif")

    print("#endif")

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--defines",
                        help="preprocessing macros: -Dxx -Dyy",
                        default="")
    parser.add_argument("--undefines",
                        help="preprocessing macros to be undefined",
                        default="")
    parser.add_argument("--comp",
                        help="compiler",
                        choices=["gnu","intel","intel-llvm","intel-classic","cray","pgi","nvhpc","llvm","nag","nec","ibm",
                                 "armclang","hip","sycl"])
    parser.add_argument("--allow-different-compiler",
                        help="allow an application to use a different compiler than the one used to build libamrex",
                        choices=["TRUE","FALSE"])
    args = parser.parse_args()

    try:
        doit(defines=args.defines, undefines=args.undefines, comp=args.comp,
             allow_diff_comp=args.allow_different_compiler)
    except:
        # something went wrong
        print("$(error something went wrong in mkconfig.py)")


#!/usr/bin/env python3

import argparse

def doit(prefix, version, cflags, libs, libpriv, fflags):
    print("# AMReX Version: "+version)
    print("")
    print("prefix="+prefix)
    print("exec_prefix=${prefix}")
    print("libdir=${prefix}/lib")
    print("includedir=${prefix}/include")
    print("")
    print("fflags="+fflags);
    print("")
    print("Name: amrex")
    print("Description: Software Framework for Block Structured AMR")
    print("Version:")
    print("URL: https://github.com/AMReX-Codes/amrex")
    print("Requires:")
    print("Cflags: -I${includedir}", cflags)
    print("Libs: -L${libdir} -lamrex", libs)
    print("Libs.private:", libpriv)

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--prefix",
                        help="prefix",
                        default="")
    parser.add_argument("--version",
                        help="version",
                        default="")
    parser.add_argument("--cflags",
                        help="cflags",
                        default="")
    parser.add_argument("--libs",
                        help="libs",
                        default="")
    parser.add_argument("--libpriv",
                        help="libpriv",
                        default="")
    parser.add_argument("--fflags",
                        help="fflags",
                        default="")
    args = parser.parse_args()

    try:
        doit(prefix=args.prefix, version=args.version, cflags=args.cflags,
             libs=args.libs, libpriv=args.libpriv, fflags=args.fflags)
    except:
        # something went wrong
        print("$(error something went wrong in mkpkgconfig.py)")


#!/usr/bin/env python3

import re
import argparse

def doit(code, defines):
    print("#ifndef "+code+"_VERSION_H_")
    print("#define "+code+"_VERSION_H_")

    # Remove -I from input
    defines = re.sub(r'-I.*?(-D|$)', r'\1', defines)

    defs = defines.split("-D")
    for d in defs:
        dd = d.strip()
        if dd:
            v = dd.split("=")
            print("#ifndef",v[0])
            if len(v) == 2:
                print("#define",v[0],v[1])
            else:
                print("#define",v[0],1)
            print("#endif")

    print("#endif // "+code+"_VERSION_H_")

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument("--code",
                        help="code name",
                        default="AMREX")
    parser.add_argument("--defines",
                        help="preprocessing macros: -Dxx -Dyy",
                        default="")
    args = parser.parse_args()

    try:
        doit(code=args.code, defines=args.defines)
    except:
        # something went wrong
        print("$(error something went wrong in mkversionheader.py)")


#!/usr/bin/env python3

import sys
import argparse

def configure(argv):
    argv[0] = "configure" # So the help message print it
    parser = argparse.ArgumentParser()
    parser.add_argument("--prefix",
                        help="Install libamrex, headers and Fortran modules in PREFIX directory [default=tmp_install_dir]",
                        default="tmp_install_dir")
    parser.add_argument("--dim",
                        help="Dimension [default=3]",
                        choices=['1','2','3'],
                        default="3")
    parser.add_argument("--with-fortran",
                        help="Use Fortran [default=yes]",
                        choices=["yes","no"],
                        default="yes")
    parser.add_argument("--with-mpi",
                        help="Use MPI [default=yes]",
                        choices=["yes","no"],
                        default="yes")
    parser.add_argument("--with-omp",
                        help="Use OpenMP [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--with-cuda",
                        help="Use CUDA [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--with-hip",
                        help="Use HIP [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--with-sycl",
                        help="Use SYCL [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--with-acc",
                        help="Use OpenACC [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--comp",
                        help="Compiler [default=gnu]",
                        choices=["gnu","intel","intel-llvm","intel-classic","cray","pgi","llvm","nag","nec","ibm","armclang"],
                        default="gnu")
    parser.add_argument("--debug",
                        help="Debug build [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--enable-particle",
                        help="Enable AMReX particle classes [default=yes]",
                        choices=["yes","no"],
                        default="yes")
    parser.add_argument("--enable-fortran-api",
                        help="Enable AMReX Fortran API [default=yes]",
                        choices=["yes","no"],
                        default="yes")
    parser.add_argument("--enable-linear-solver",
                        help="Enable AMReX linear solvers [default=yes]",
                        choices=["yes","no"],
                        default="yes")
    parser.add_argument("--enable-hypre",
                        help="Enable Hypre as an option for bottom solver of AMReX linear solvers [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--enable-petsc",
                        help="Enable PETSc as an option for bottom solver of AMReX linear solvers [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--enable-eb",
                        help="Enable AMReX embedded boundary capability [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--single-precision",
                        help="Define amrex::Real as float [default=no (i.e., double)]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--single-precision-particles",
                        help="Define amrex::ParticleReal as float [default=no (i.e., double)]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--enable-xsdk-defaults",
                        help="Enable XSDK mode [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--allow-different-compiler",
                        help="Allow an application to use a different compiler than the one used to build libamrex [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--with-sensei-insitu",
                        help="Enables the SENSEI in situ integration. [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--sensei-amr-inst",
                        help="Enables the SENSEI instrumentation in amrex::Amr. [default=yes]",
                        choices=["yes","no"],
                        default="yes")
    parser.add_argument("--with-omp-offload",
                        help="Use OpenMP-offload [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--enable-tiny-profile",
                        help="Enable tiny profile [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--enable-pic",
                        help="Enable position independent code [default=no]",
                        choices=["yes","no"],
                        default="no")
    parser.add_argument("--cuda-arch",
                        help="Specify CUDA architecture [default=70]",
                        default="70")
    parser.add_argument("--enable-probinit",
                        help="Only relevant to Amr/AmrLevel based codes that need to read probin file or call amrex_probinit",
                        choices=["yes","no"],
                        default="yes")
    parser.add_argument("--enable-bittree",
                        help="Enable Bittree mode [default=no]",
                        choices=["yes","no"],
                        default="no")
    args = parser.parse_args()

    if args.with_fortran == "no":
        args.enable_fortran_api = "no";
        if args.enable_hypre == "yes":
            sys.exit("ERROR: must have --with-fortran=yes to use hypre")
        if args.enable_petsc == "yes":
            sys.exit("ERROR: must have --with-fortran=yes to use petsc")

    f = open("GNUmakefile","w")
    f.write("AMREX_INSTALL_DIR = " + args.prefix.strip() + "\n")
    f.write("DIM = " + args.dim.strip() + "\n")
    f.write("BL_NO_FORT = {}\n".format("TRUE" if args.with_fortran == "no" else "FALSE"))
    f.write("USE_MPI = {}\n".format("FALSE" if args.with_mpi == "no" else "TRUE"))
    f.write("USE_OMP = {}\n".format("FALSE" if args.with_omp == "no" else "TRUE"))
    f.write("USE_CUDA = {}\n".format("FALSE" if args.with_cuda == "no" else "TRUE"))
    f.write("USE_HIP = {}\n".format("FALSE" if args.with_hip == "no" else "TRUE"))
    f.write("USE_SYCL = {}\n".format("FALSE" if args.with_sycl == "no" else "TRUE"))
    f.write("USE_ACC = {}\n".format("FALSE" if args.with_acc == "no" else "TRUE"))
    f.write("COMP = " + args.comp.strip() + "\n")
    f.write("DEBUG = {}\n".format("TRUE" if args.debug == "yes" else "FALSE"))
    f.write("USE_PARTICLES = {}\n".format("FALSE" if args.enable_particle == "no" else "TRUE"))
    f.write("USE_FORTRAN_INTERFACE = {}\n".format("FALSE" if args.enable_fortran_api == "no" else "TRUE"))
    f.write("USE_LINEAR_SOLVERS = {}\n".format("FALSE" if args.enable_linear_solver == "no" else "TRUE"))
    f.write("USE_HYPRE = {}\n".format("TRUE" if args.enable_hypre == "yes" else "FALSE"))
    f.write("USE_PETSC = {}\n".format("TRUE" if args.enable_petsc == "yes" else "FALSE"))
    f.write("USE_EB = {}\n".format("TRUE" if args.enable_eb == "yes" else "FALSE"))
    f.write("PRECISION = {}\n".format("FLOAT" if args.single_precision == "yes" else "DOUBLE"))
    f.write("USE_SINGLE_PRECISION_PARTICLES = {}\n".format("TRUE" if args.single_precision_particles == "yes" else "FALSE"))
    f.write("AMREX_XSDK = {}\n".format("TRUE" if args.enable_xsdk_defaults == "yes" else "FALSE"))
    f.write("ALLOW_DIFFERENT_COMP = {}\n".format("FALSE" if args.allow_different_compiler == "no" else "TRUE"))
    f.write("USE_SENSEI_INSITU = {}\n".format("FALSE" if args.with_sensei_insitu == "no" else "TRUE"))
    f.write("NO_SENSEI_AMR_INST = {}\n".format("FALSE" if args.sensei_amr_inst == "yes" else "TRUE"))
    f.write("USE_OMP_OFFLOAD = {}\n".format("FALSE" if args.with_omp_offload == "no" else "TRUE"))
    f.write("TINY_PROFILE = {}\n".format("FALSE" if args.enable_tiny_profile == "no" else "TRUE"))
    f.write("USE_COMPILE_PIC = {}\n".format("FALSE" if args.enable_pic == "no" else "TRUE"))
    f.write("CUDA_ARCH = " + args.cuda_arch.strip() + "\n")
    f.write("AMREX_NO_PROBINIT = {}\n".format("TRUE" if args.enable_probinit == "no" else "FALSE"))
    f.write("USE_BITTREE = {}\n".format("TRUE" if args.enable_bittree == "yes" else "FALSE"))
    f.write("\n")

    fin = open("GNUmakefile.in","r")
    for line in fin.readlines():
        f.write(line)
    fin.close()

    f.close()

if __name__ == "__main__":
    configure(sys.argv)


The AMReX Tutorials are now found at https://github.com/AMReX-Codes/amrex-tutorials

#
# Function to setup the tutorials
#
function (setup_test _dim _srcs  _inputs)

   cmake_parse_arguments( "" "HAS_FORTRAN_MODULES"
      "BASE_NAME;RUNTIME_SUBDIR;EXTRA_DEFINITIONS;CMDLINE_PARAMS;NTASKS;NTHREADS" "" ${ARGN} )

   if (_BASE_NAME)
      set(_base_name ${_BASE_NAME}_${_dim}d)
   else ()
      string(REGEX REPLACE ".*Tests/" "" _base_name ${CMAKE_CURRENT_LIST_DIR})
      string(REPLACE "/" "_" _base_name ${_base_name})
      set(_base_name ${_base_name}_${_dim}d)
   endif()

   if (_RUNTIME_SUBDIR)
      set(_exe_dir ${CMAKE_CURRENT_BINARY_DIR}/${_RUNTIME_SUBDIR}_${_dim}d)
   else ()
      set(_exe_dir ${CMAKE_CURRENT_BINARY_DIR}/${_dim}d)
   endif ()

   set( _exe_name  Test_${_base_name} )
   set( _test_name ${_base_name} )

   add_executable( ${_exe_name} )
   target_sources( ${_exe_name} PRIVATE ${${_srcs}} )
   set_target_properties( ${_exe_name} PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${_exe_dir} )

   if (_EXTRA_DEFINITIONS)
      target_compile_definitions(${_exe_name} PRIVATE ${_EXTRA_DEFINITIONS})
   endif ()

   # Find out which include directory is needed
   set(_includes ${${_srcs}})
   list(FILTER _includes INCLUDE REGEX "\\.H")
   foreach(_item IN LISTS _includes)
      get_filename_component( _include_dir ${_item} DIRECTORY )
      target_include_directories( ${_exe_name} PRIVATE  ${_include_dir} )
   endforeach()

   if (_HAS_FORTRAN_MODULES)
      target_include_directories(${_exe_name}
         PRIVATE
         ${CMAKE_CURRENT_BINARY_DIR}/${_exe_name}_mod_files_${_dim}d)
      set_target_properties( ${_exe_name}
         PROPERTIES
         Fortran_MODULE_DIRECTORY
         ${CMAKE_CURRENT_BINARY_DIR}/${_exe_name}_mod_files_${_dim}d)
   endif ()

   target_link_libraries( ${_exe_name} AMReX::amrex_${_dim}d )

   if (AMReX_CUDA)
      setup_target_for_cuda_compilation( ${_exe_name} )
   endif ()

   #
   # Assemble the commands sequence to launch the test
   #
   set(_cmd ${_exe_dir}/${_exe_name})

   if (_CMDLINE_PARAMS)
      list(APPEND _cmd ${_CMDLINE_PARAMS})
   endif ()

   if (${_inputs})
      file( COPY ${${_inputs}} DESTINATION ${_exe_dir} )
      list(GET ${_inputs} 0 _first_inputs)
      get_filename_component( _inputs_filename ${_first_inputs} NAME )
      list(APPEND _cmd ${_inputs_filename})
   endif ()

   #
   # Add the test
   #
   if (AMReX_OMP)
      add_test(
         NAME               ${_test_name}
         COMMAND            ${_cmd}
         WORKING_DIRECTORY  ${_exe_dir}
      )
      set_tests_properties(${_test_name} PROPERTIES ENVIRONMENT OMP_NUM_THREADS=2)
   elseif (AMReX_MPI)
      add_test(
         NAME               ${_test_name}
         COMMAND            mpiexec -n 2 ${_cmd}
         WORKING_DIRECTORY  ${_exe_dir}
      )
   else ()
      add_test(
         NAME               ${_test_name}
         COMMAND            ${_cmd}
         WORKING_DIRECTORY  ${_exe_dir}
      )
   endif ()

endfunction ()

if (AMReX_TEST_TYPE STREQUAL "Small")

   add_subdirectory("Amr/Advection_AmrCore")

   if (AMReX_PARTICLES)
      add_subdirectory("Particles/Redistribute")
   endif ()

   if (AMReX_EB)
      add_subdirectory("EB/CNS")
   endif()

   if (AMReX_LINEAR_SOLVERS)
      add_subdirectory("LinearSolvers/ABecLaplacian_C")
   endif()

else()
   #
   # List of subdirectories to search for CMakeLists.
   #
   set( AMREX_TESTS_SUBDIRS AsyncOut MultiBlock Reinit Amr CLZ Parser Parser2 CTOParFor RoundoffDomain)

   if (AMReX_PARTICLES)
     list(APPEND AMREX_TESTS_SUBDIRS Particles)
   endif ()

   if (AMReX_EB)
      list(APPEND AMREX_TESTS_SUBDIRS EB)
   endif ()

   if (AMReX_LINEAR_SOLVERS)
      list(APPEND AMREX_TESTS_SUBDIRS LinearSolvers)
   endif ()

   if (AMReX_HDF5)
      list(APPEND AMREX_TESTS_SUBDIRS HDF5Benchmark)
   endif ()

   if (AMReX_FORTRAN_INTERFACES)
      list(APPEND AMREX_TESTS_SUBDIRS FortranInterface)
   endif ()

   if (AMReX_CUDA)
      list(APPEND AMREX_TESTS_SUBDIRS GPU)
   endif ()

   list(TRANSFORM AMREX_TESTS_SUBDIRS PREPEND "${CMAKE_CURRENT_LIST_DIR}/")

   #
   # Loop over subdirs and add to the build those containing CMakeLists.txt
   #
   foreach (_subdir IN LISTS AMREX_TESTS_SUBDIRS)

      file( GLOB_RECURSE _tests "${_subdir}/*CMakeLists.txt" )

      foreach ( _item  IN LISTS _tests)
         get_filename_component(_dir ${_item} DIRECTORY )
         add_subdirectory(${_dir})
      endforeach ()

   endforeach ()
endif()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources main.cpp)
    set(_input_files)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp fn.cpp)
    set(_input_files fn.cpp)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


if (NOT AMReX_CUDA)
    foreach(D IN LISTS AMReX_SPACEDIM)
        if(D EQUAL 1)
            continue()
        endif()

        set(_sources main.cpp MyTest.cpp MyTest.H MyTestPlotfile.cpp)
        set(_input_files)

        setup_test(${D} _sources _input_files )

        unset(_sources)
        unset(_input_files)
    endforeach()
endif ()


if ( (NOT AMReX_EB) OR NOT (3 IN_LIST AMReX_SPACEDIM))
   return()
endif ()

set(_sources main.cpp)
set(_input_files inputs_3d)

setup_test(3 _sources _input_files)

unset(_sources)
unset(_input_files)


foreach(D IN LISTS AMReX_SPACEDIM)
    if (D EQUAL 1)
       continue()
    endif ()

    set(_sources
       main.cpp
       MyTest.cpp
       initProb.cpp
       MyTestPlotfile.cpp
       MyTest.H
       initProb_K.H)

    set(_input_files inputs)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    if ( (D EQUAL 1) OR (NOT AMReX_FORTRAN_INTERFACES) )
        continue()
    endif ()

    set(_sources main.F90 mytest.F90 init_prob.F90)

    file( GLOB_RECURSE _input_files LIST_DIRECTORIES false ${CMAKE_CURRENT_LIST_DIR}/input*)

    setup_test(${D} _sources _input_files HAS_FORTRAN_MODULES)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    if (D EQUAL 1)
       return()
    endif ()

    set(_sources
       main.cpp
       MyTest.cpp
       initProb.cpp
       MyTestPlotfile.cpp
       MyTest.H
       initProb_K.H)

    set(_input_files  inputs-rt-poisson-lev )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    if(D EQUAL 1)
       continue()
    endif()

    set(_sources main.cpp MyTest.cpp MyTest.H MyTestPlotfile.cpp)

    set(_input_files inputs-ci)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


# Least Squares Tests
## Overview
This directory contains tests for:
1. Slope computation on face centroids using the Least Square method,
2. Laplacian operator computation when applying the explicit stencil,

Given a function defined on cell centroids.

# Building & Running
1. Build using `make`
   ```
   $ make DIM=<dim>
   ```
2. Run specifying an inputs file. Eg:
   ```
   $ ./main2d.gnu.DEBUG.MPI.ex inputs.2d.askew-y
   ```
3. View the resulting plot files through `amrvis` visualization tool. Eg:
   ```
   $ amrvis2d plot-askew-y
   $ amrvis2d plot-askew-y-analytic
   ```
4. Compare numerical solution against analytical solution using `fcompare`. Eg:
   ```
   $ fcompare plot-askew-y plot-askew-y-analytic
   ```

## Tests
There are several input files which correspond to different 2D & 3D configurations of `Poisueille Flow through a Channel`. For eg: `inputs.3d.poiseuille.aligned.xy-x` corresponds to the flow through a 3D channel where the walls are along the xy plane and the flow is along the x direction, and the grid is aligned with the walls (does not cut the wall at an angle). Additionally, there is a test corresponding to a periodic triangle wave function in 2D `inputs.2d.trianglewave`.


# This tests requires particle support
if (NOT AMReX_PARTICLES)
   return()
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


#
# Test the amrex installation by
# building and running the code
# in Tests/Amr/Advection_AmrCore/
#
cmake_minimum_required(VERSION 3.18)

project(amrex-test-install)

if(DEFINED CMAKE_Fortran_COMPILER)
    enable_language(Fortran)
endif()

get_filename_component(_base_dir ${CMAKE_CURRENT_LIST_DIR} DIRECTORY)

set(_base_dir  ${_base_dir}/Amr/Advection_AmrCore)
set(_src_dir   ${_base_dir}/Source)
set(_input_dir ${_base_dir}/Exec)


find_package(AMReX REQUIRED)

foreach(D IN LISTS AMReX_SPACEDIM)
    if (D EQUAL 1)
       continue()
    endif ()

    add_executable(install_test_${D}d)

    target_link_libraries(install_test_${D}d PUBLIC AMReX::amrex_${D}d)

    target_include_directories(install_test_${D}d
       PUBLIC
       ${_src_dir}
       ${_src_dir}/Src_K/
       ${_input_dir}
    )

    target_sources(install_test_${D}d
       PRIVATE
       ${_src_dir}/AdvancePhiAllLevels.cpp
       ${_src_dir}/AdvancePhiAtLevel.cpp
       ${_src_dir}/AmrCoreAdv.cpp
       ${_src_dir}/AmrCoreAdv.H
       ${_src_dir}/bc_fill.H
       ${_src_dir}/DefineVelocity.cpp
       ${_src_dir}/face_velocity.H
       ${_src_dir}/Kernels.H
       ${_src_dir}/main.cpp
       ${_src_dir}/Tagging.H
       ${_src_dir}/Src_K/Adv_K.H
       ${_src_dir}/Src_K/compute_flux_2D_K.H
       ${_src_dir}/Src_K/slope_K.H
       ${_input_dir}/Prob.H
    )

    add_custom_command(
       TARGET install_test_${D}d
       POST_BUILD
       COMMAND ${CMAKE_COMMAND} -E echo "Running test project"
       COMMAND ${PROJECT_BINARY_DIR}/install_test_${D}d ${_input_dir}/inputs max_step=1 > out_${D}d.txt
       WORKING_DIRECTORY ${PROJECT_BINARY_DIR}
    )
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources main.cpp CNS_advance.cpp CNS_advance_box.cpp CNS_advance_box_eb.cpp CNS_bcfill.cpp
       CNSBld.cpp CNS.cpp CNS.H CNS_derive.cpp CNS_derive.H CNS_index_macros.H CNS_init_eb2.cpp CNS_io.cpp
       CNS_K.H CNS_parm.cpp CNS_parm.H CNS_setup.cpp CNS_tagging.H )

    set(_diffusion_sources CNS_diffusion_K.H CNS_diffusion_eb_K.H )
    list(TRANSFORM _diffusion_sources PREPEND diffusion/)

    set(_hydro_sources CNS_divop_K.H CNS_flux_redistribute.cpp CNS_hydro_eb_K.H CNS_hydro_K.H )
    list(TRANSFORM _hydro_sources PREPEND hydro/)

    list(APPEND _sources ${_diffusion_sources} ${_hydro_sources})
    list(TRANSFORM _sources PREPEND Source/)

    unset(_diffusion_sources)
    unset(_hydro_sources)

    ##########################################################################################
    #
    # Combustor tutorial
    #
    ##########################################################################################
    set(_combustor_sources Exec/Combustor/cns_prob.H  Exec/Combustor/cns_prob.cpp
                           Exec/Combustor/cns_prob_parm.H  Exec/Combustor/cns_prob_parm.cpp
                           Exec/Combustor/CNS_bcfill.cpp ${_sources})
    set(_input_files Exec/Combustor/inputs Exec/Combustor/inputs-ci)

    setup_test(${D} _combustor_sources _input_files
       BASE_NAME CNS_Combustor
       RUNTIME_SUBDIR Combustor)

    unset(_combustor_sources)

    #
    # Clean-up
    #
    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    if (D EQUAL 1)
       continue()
    endif ()

    if (WIN32)
      continue()
    endif ()

    #
    # This test works for both 2D and 3D builds
    # There are two different tutorials here:
    #
    # 1) Single Vortex
    # 2) Uniform Velocity
    #


    #
    # Sources common to both cases
    #
    set(_sources Adv.cpp
                 AmrLevelAdv.cpp
                 AmrLevelAdv.H
                 bc_nullfill.cpp
                 Kernels.H
                 LevelBldAdv.cpp
                 main.cpp
                 Tagging_params.cpp)

    list(APPEND _sources  Src_K/slope_K.H
                          Src_K/flux_${D}d_K.H
                          Src_K/Adv_K.H
                          Src_K/tagging_K.H)

    list(TRANSFORM _sources PREPEND Source/)


    ###############################################################################
    #
    # Single Vortex tutorial ------------------------------------------------------
    #
    ###############################################################################
    set(_sv_exe_dir Exec/SingleVortex/)

    set(_sv_sources face_velocity_${D}d_K.H Prob_Parm.H Adv_prob.cpp Prob.cpp Prob.H)
    list(TRANSFORM _sv_sources PREPEND ${_sv_exe_dir})
    list(APPEND _sv_sources ${_sources})

    set(_input_files inputs-ci)
    list(TRANSFORM _input_files PREPEND ${_sv_exe_dir})

    setup_test(${D} _sv_sources _input_files
       BASE_NAME Advection_AmrLevel_SV
       RUNTIME_SUBDIR SingleVortex)

    unset(_sv_sources)
    unset(_sv_exe_dir)


    ###############################################################################
    #
    # Uniform Velocity tutorial ---------------------------------------------------
    #
    ###############################################################################
    set(_uv_exe_dir Exec/UniformVelocity/)

    set(_uv_sources face_velocity_${D}d_K.H Prob_Parm.H Adv_prob.cpp Prob.cpp Prob.H)
    list(TRANSFORM _uv_sources PREPEND ${_uv_exe_dir})
    list(APPEND _uv_sources ${_sources})

    set(_input_files inputs-ci)
    list(TRANSFORM _input_files PREPEND ${_uv_exe_dir})

    setup_test(${D} _uv_sources _input_files
       BASE_NAME Advection_AmrLevel_UV
       RUNTIME_SUBDIR UniformVelocity)

    unset(_uv_sources)
    unset(_uv_exe_dir)


    # Final clean up
    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    if (D EQUAL 1)
       continue()
    endif ()

    # List of source files
    set(_sources AdvancePhiAllLevels.cpp  AdvancePhiAtLevel.cpp  AmrCoreAdv.cpp  AmrCoreAdv.H bc_fill.H)
    list(APPEND _sources DefineVelocity.cpp  face_velocity.H  Kernels.H  main.cpp  Tagging.H)
    list(APPEND _sources Src_K/Adv_K.H  Src_K/compute_flux_${D}D_K.H  Src_K/slope_K.H)
    list(TRANSFORM _sources PREPEND Source/)
    list(APPEND _sources Exec/Prob.H)

    # List of input files
    set(_input_files inputs-ci)
    list(TRANSFORM _input_files PREPEND "Exec/")

    setup_test(${D} _sources _input_files)

    unset( _sources )
    unset( _input_files   )
endforeach()


 use_math: true

##  Multi-Level Scalar Advection

### What Features Are We Using

* Mesh data
* Dynamic AMR with and without subcycling

### The Problem

Consider a drop of dye (we'll define $$\phi$$ to be the concentration of dye)
in a thin incompressible fluid that is spinning
clock-wise then counter-clockwise with a prescribed motion.  We consider the dye to be a
passive tracer that is advected by the fluid velocity.  The fluid is thin enough that we can model
this as two-dimensional motion; here we have the option of solving in a 2D or 3D computational domain.

In other words, we want to solve for $$\phi(x,y,t)$$ by evolving

$$\frac{\partial \phi}{\partial t} + \nabla \cdot (\bf{u^{spec}} \phi)  = 0$$

in time ($$t$$), where the velocity $${\bf{u^{spec}}} = (u,v)$$ is a divergence-free field computed by defining

$$\psi(i,j) = \sin^2(\pi x) \sin^2(\pi y)  \cos (\pi t / 2) / \pi $$

and defining

$$u = -\frac{\partial \psi}{\partial y},  v = \frac{\partial \psi}{\partial x}.$$

Note that because $${\bf{u^{spec}}}$$ is defined as the curl of a scalar field, it is analytically divergence-free

In this example we'll be using AMR to resolve the scalar field since the location of the dye is
what we care most about.

### The AMR Algorithm

To update the solution in a patch at a given level, we compute fluxes ($${\bf u^{spec}} \phi$$)
on each face, and difference the fluxes to create the update to phi.   The update routine
in the code looks like

```cplusplus
  // Do a conservative update
  {
    phi_out(i,j,k) = phi_in(i,j,k) +
                ( AMREX_D_TERM( (flxx(i,j,k) - flxx(i+1,j,k)) * dtdx[0],
                              + (flxy(i,j,k) - flxy(i,j+1,k)) * dtdx[1],
                              + (flxz(i,j,k) - flxz(i,j,k+1)) * dtdx[2] ) );
  }
```

In this routine we use the macro AMREX_D_TERM so that we can write dimension-independent code;
in 3D this returns the flux differences in all three directions, but in 2D it does not include
the z-fluxes.

Knowing how to synchronize the solution at coarse/fine boundaries is essential in an AMR algorithm;
here having the algorithm written in flux form allows us to either make the fluxes consistent between
coarse and fine levels in a no-subcycling algorithm, or "reflux" after the update in a subcycling algorithm.

The subcycling algorithm can be written as follows
```C++
void
AmrCoreAdv::timeStepWithSubcycling (int lev, Real time, int iteration)
{

    // Advance a single level for a single time step, and update flux registers
    Real t_nph = 0.5 * (t_old[lev] + t_new[lev]);
    DefineVelocityAtLevel(lev, t_nph);
    AdvancePhiAtLevel(lev, time, dt[lev], iteration, nsubsteps[lev]);

    ++istep[lev];

    if (lev < finest_level)
    {
        // recursive call for next-finer level
        for (int i = 1; i <= nsubsteps[lev+1]; ++i)
        {
            timeStepWithSubcycling(lev+1, time+(i-1)*dt[lev+1], i);
        }

        if (do_reflux)
        {
            // update lev based on coarse-fine flux mismatch
            flux_reg[lev+1]->Reflux(phi_new[lev], 1.0, 0, 0, phi_new[lev].nComp(), geom[lev]);
        }

        AverageDownTo(lev); // average lev+1 down to lev
    }

}
```

while the no-subcycling algorithm looks like
```C++
void
AmrCoreAdv::timeStepNoSubcycling (Real time, int iteration)
{
    DefineVelocityAllLevels(time);
    AdvancePhiAllLevels (time, dt[0], iteration);

    // Make sure the coarser levels are consistent with the finer levels
    AverageDown ();

    for (int lev = 0; lev <= finest_level; lev++)
        ++istep[lev];
}
```

### Running the Code

First git clone amrex.  Then from within the amrex repo,

```
cd Tests/Advection_AmrCore/Exec
```
Note that you can choose to work entirely in 2D or in 3D ... whichever you prefer.
The instructions below will be written for 3D but you can substitute the 2D executable.

To build in 2d, type
```
make DIM = 2
```

To build in 3d, type
```
make DIM = 3
```

In this directory you'll see


```
inputs -- an inputs file for both 2D and 3D
```

To run in serial,

```
./main3d.gnu.MPI.ex inputs
```

To run in parallel, for example on 4 ranks:

```
mpiexec -n 4 ./main3d.gnu.MPI.ex inputs
```

The following parameters can be set at run-time -- these are currently set in the inputs
file but you can also set them on the command line.

```
stop_time          =  2.0                # the final time (if we have not exceeded number of steps)
max_step           = 1000000             # the maximum number of steps (if we have not exceeded stop_time)

amr.n_cell         =  64  64   8         # number of cells at the coarsest AMR level in each coordinate direction

amr.max_grid_size  = 16                  # the maximum number of cells in any direction in a single grid

amr.plot_int       = 10                  # frequency of writing plotfiles

adv.cfl            = 0.9                 # cfl number to be used for computing the time step

adv.phierr = 1.01  1.1  1.5              # regridding criteria  at each level

```

The base grid here is a square of 64 x 64 x 8 cells, made up of 16 subgrids each of size 16x16x8 cells.
The problem is periodic in all directions.

We have hard-wired the code here to refine based on the magnitude of $$\phi$$.    Here we set the
threshold level by level.  If $$\phi > 1.01$$ then we want to refine at least once; if $$\phi > 1.1$$ we
want to resolve $$\phi$$ with two levels of refinement, and if $$\phi > 1.5$$ we want even more refinement.

Note that you can see the total runtime by looking at the line at the end of your run that says

```
Total Time:
```

and you can check conservation of $$\phi$$ by checking the line that prints, e.g.

```
Coarse STEP 8 ends. TIME = 0.007031485953 DT = 0.0008789650903 Sum(Phi) = 540755.0014
```

Here Sum(Phi) is the sum of $$\phi$$ over all the cells at the coarsest level.

Questions to answer:

```
1. How do the subcycling vs no-subycling calculations compare?
    a.   How many steps did each take at the finest level? Why might this not be the same?
    b.   How many cells were at the finest level in each case? Why might this number not be the same?

2  What was the total run time for each calculation?  Was this what you expected?

3. Was phi conserved (over time) in each case?
      a.  If you set do_refluxing = 0 for the subcycling case, was phi still conserved?
      b.  How in the algorithm is conservation enforced differently between subcycling and not?

4. How did the runtimes vary with 1 vs. 4 MPI processes?
   We suggest you use a big enough problem here -- try running

   mpiexec -n 1 ./main3d.gnu.MPI.ex inputs_for_scaling

   mpiexec -n 4 ./main3d.gnu.MPI.ex inputs_for_scaling

5. Why could we check conservation by just adding up the values at the coarsest level?
```

### Visualizing the Results

Here is a sample slice through a 3D run with 64x64x8 cells at the coarsest level and three finer levels (4 total levels).

![Sample solution](amr101_3D.gif)

After you run the code you will have a series of plotfiles.  To visualize these
we will use ParaView 5.8, which has native support for AMReX Grid, Particle,
and Embedded Boundary data (in the AMR 101 exercise we only have grid data).

#### Make a Movie with the ParaView 5.8 Script

To use the ParaView 5.8 python script, simply do the following to generate `amr101_3D.gif`:

```
$ make movie3D
```

If you run the 2D executable, make the 2D movie using:

```
$ make movie2D
```

Notes:

- To delete old plotfiles before a new run, do `rm -rf plt*`

- You will need `+ffmpeg`.

#### Using ParaView 5.8 Manually

To do the same thing with ParaView 5.8 manually,

```
1. Start Paraview 5.8
2. File --> Open ... and select the collection of directories named "plt.." --> [OK]
3. From the "Open Data With..." dialog that pops up, select "AMReX/BoxLib Grid Reader" --> [OK]
4. Check the "phi" box in the "Cell Array Status" menu that appears
5. Click green Apply button
6. Click on the "slice" icon -- three to the right of the calculator
   This will create "Slice 1" in the Pipeline Browser which will be highlighted.
7. Click on "Z Normal"
8. Unclick the "Show Plane" button
9. Click green Apply button
10. Change the drop-down menu option (above the calculator row) from "vtkBlockColors" to "phi"
```

You are now ready to play the movie!  See the "VCR-like" controls at the top. Click the play button.

### Additional Topics to Explore

* What happens as you change the max grid size for decomposition?

* What happens as you change the refinement criteria (i.e. use different values of $$\phi$$)?
  (You can edit these in inputs)


# based on traces generated using paraview version 5.8.0
#
# To ensure correct image size when batch processing, please search
# for and uncomment the line `# renderView*.ViewSize = [*,*]`

#### import the simple module from the paraview
from paraview.simple import *

import subprocess
import glob
import argparse

parser = argparse.ArgumentParser()
parser.add_argument('-f', '--frame_rate', type=int, default=15, help="Frame rate for generating movies, i.e. number of plots per second in the movie.")
parser.add_argument('-r', '--resolution', type=int, default=1024, help="(Square) resolution of output movie.")
parser.add_argument('-d', '--spacedim', type=int, default=3, help="Dimensionality of the problem: 2 or 3")
args = parser.parse_args()

def generate_movie_3D(AllPlotFiles):
    #### disable automatic camera reset on 'Show'
    paraview.simple._DisableFirstRenderCameraReset()

    # create a new 'AMReX/BoxLib Grid Reader'
    plt00 = AMReXBoxLibGridReader(FileNames=AllPlotFiles)
    plt00.CellArrayStatus = []

    # get animation scene
    animationScene1 = GetAnimationScene()

    # get the time-keeper
    timeKeeper1 = GetTimeKeeper()

    # update animation scene based on data timesteps
    animationScene1.UpdateAnimationUsingDataTimeSteps()

    # Properties modified on plt00
    plt00.CellArrayStatus = ['phi']

    # get active view
    renderView1 = GetActiveViewOrCreate('RenderView')
    renderView1.ViewSize = [1200, 1200]

    # get layout
    layout1 = GetLayout()

    # show data in view
    plt00Display = Show(plt00, renderView1, 'AMRRepresentation')

    # trace defaults for the display properties.
    plt00Display.Representation = 'Outline'
    plt00Display.ColorArrayName = [None, '']
    plt00Display.OSPRayScaleFunction = 'PiecewiseFunction'
    plt00Display.SelectOrientationVectors = 'None'
    plt00Display.ScaleFactor = 0.1
    plt00Display.SelectScaleArray = 'None'
    plt00Display.GlyphType = 'Arrow'
    plt00Display.GlyphTableIndexArray = 'None'
    plt00Display.GaussianRadius = 0.005
    plt00Display.SetScaleArray = [None, '']
    plt00Display.ScaleTransferFunction = 'PiecewiseFunction'
    plt00Display.OpacityArray = [None, '']
    plt00Display.OpacityTransferFunction = 'PiecewiseFunction'
    plt00Display.DataAxesGrid = 'GridAxesRepresentation'
    plt00Display.PolarAxes = 'PolarAxesRepresentation'
    plt00Display.ScalarOpacityUnitDistance = 0.030761993184097912

    # reset view to fit data
    renderView1.ResetCamera()

    # get the material library
    materialLibrary1 = GetMaterialLibrary()

    # update the view to ensure updated data information
    renderView1.Update()

    # change solid color
    plt00Display.AmbientColor = [0.0, 1.0, 0.0]
    plt00Display.DiffuseColor = [0.0, 1.0, 0.0]

    # create a new 'Slice'
    slice1 = Slice(Input=plt00)
    slice1.SliceType = 'Plane'
    slice1.HyperTreeGridSlicer = 'Plane'
    slice1.SliceOffsetValues = [0.0]

    # init the 'Plane' selected for 'SliceType'
    slice1.SliceType.Origin = [0.5, 0.5, 0.0625]

    # init the 'Plane' selected for 'HyperTreeGridSlicer'
    slice1.HyperTreeGridSlicer.Origin = [0.5, 0.5, 0.0625]

    # toggle 3D widget visibility (only when running from the GUI)
    Hide3DWidgets(proxy=slice1.SliceType)

    # Properties modified on slice1.SliceType
    slice1.SliceType.Normal = [0.0, 0.0, 1.0]

    # show data in view
    slice1Display = Show(slice1, renderView1, 'GeometryRepresentation')

    # trace defaults for the display properties.
    slice1Display.Representation = 'Surface'
    slice1Display.ColorArrayName = [None, '']
    slice1Display.OSPRayScaleFunction = 'PiecewiseFunction'
    slice1Display.SelectOrientationVectors = 'None'
    slice1Display.ScaleFactor = 0.1
    slice1Display.SelectScaleArray = 'None'
    slice1Display.GlyphType = 'Arrow'
    slice1Display.GlyphTableIndexArray = 'None'
    slice1Display.GaussianRadius = 0.005
    slice1Display.SetScaleArray = [None, '']
    slice1Display.ScaleTransferFunction = 'PiecewiseFunction'
    slice1Display.OpacityArray = [None, '']
    slice1Display.OpacityTransferFunction = 'PiecewiseFunction'
    slice1Display.DataAxesGrid = 'GridAxesRepresentation'
    slice1Display.PolarAxes = 'PolarAxesRepresentation'

    # update the view to ensure updated data information
    renderView1.Update()

    # set scalar coloring
    ColorBy(slice1Display, ('FIELD', 'vtkBlockColors'))

    # get color transfer function/color map for 'vtkBlockColors'
    vtkBlockColorsLUT = GetColorTransferFunction('vtkBlockColors')

    # get opacity transfer function/opacity map for 'vtkBlockColors'
    vtkBlockColorsPWF = GetOpacityTransferFunction('vtkBlockColors')

    # set scalar coloring
    ColorBy(slice1Display, ('CELLS', 'phi'))

    # rescale color and/or opacity maps used to include current data range
    slice1Display.RescaleTransferFunctionToDataRange(True, False)

    # get color transfer function/color map for 'phi'
    phiLUT = GetColorTransferFunction('phi')

    # get opacity transfer function/opacity map for 'phi'
    phiPWF = GetOpacityTransferFunction('phi')

    # show color bar/color legend
    slice1Display.SetScalarBarVisibility(renderView1, True)

    # get color legend/bar for phiLUT in view renderView1
    phiLUTColorBar = GetScalarBar(phiLUT, renderView1)

    # change scalar bar placement
    phiLUTColorBar.WindowLocation = 'AnyLocation'
    phiLUTColorBar.Position = [0, 0.75]
    phiLUTColorBar.ScalarBarLength = 0.2

    # current camera placement for renderView1
    renderView1.CameraPosition = [0.5, 0.5, 2.3291959654285184]
    renderView1.CameraFocalPoint = [0.5, 0.5, 0.0625]
    renderView1.CameraParallelScale = 0.7098635432250342

    # save animation
    output_movie_base = "amr101_3D"
    output_movie = output_movie_base + ".avi"
    SaveAnimation(output_movie,
                  renderView1,
                  ImageResolution=[1200, 1200],
                  FrameRate=args.frame_rate,
                  FrameWindow=[0, len(AllPlotFiles)-1])

    return output_movie_base, output_movie

def generate_movie_2D(AllPlotFiles):
    #### disable automatic camera reset on 'Show'
    paraview.simple._DisableFirstRenderCameraReset()

    # create a new 'AMReX/BoxLib Grid Reader'
    plt00 = AMReXBoxLibGridReader(FileNames=AllPlotFiles)
    plt00.CellArrayStatus = []

    # get animation scene
    animationScene1 = GetAnimationScene()

    # get the time-keeper
    timeKeeper1 = GetTimeKeeper()

    # update animation scene based on data timesteps
    animationScene1.UpdateAnimationUsingDataTimeSteps()

    # Properties modified on plt00
    plt00.CellArrayStatus = ['phi']

    # get active view
    renderView1 = GetActiveViewOrCreate('RenderView')
    # uncomment following to set a specific view size
    # renderView1.ViewSize = [1309, 923]
    renderView1.ViewSize = [1200, 1200]

    # get layout
    layout1 = GetLayout()

    # show data in view
    plt00Display = Show(plt00, renderView1, 'AMRRepresentation')

    # trace defaults for the display properties.
    plt00Display.Representation = 'Outline'
    plt00Display.ColorArrayName = [None, '']
    plt00Display.OSPRayScaleFunction = 'PiecewiseFunction'
    plt00Display.SelectOrientationVectors = 'None'
    plt00Display.ScaleFactor = 0.1
    plt00Display.SelectScaleArray = 'None'
    plt00Display.GlyphType = 'Arrow'
    plt00Display.GlyphTableIndexArray = 'None'
    plt00Display.GaussianRadius = 0.005
    plt00Display.SetScaleArray = [None, '']
    plt00Display.ScaleTransferFunction = 'PiecewiseFunction'
    plt00Display.OpacityArray = [None, '']
    plt00Display.OpacityTransferFunction = 'PiecewiseFunction'
    plt00Display.DataAxesGrid = 'GridAxesRepresentation'
    plt00Display.PolarAxes = 'PolarAxesRepresentation'
    plt00Display.ScalarOpacityUnitDistance = 0.0701538780193358

    # reset view to fit data
    renderView1.ResetCamera()

    #changing interaction mode based on data extents
    renderView1.InteractionMode = '2D'
    renderView1.CameraPosition = [0.5, 0.5, 10000.0]
    renderView1.CameraFocalPoint = [0.5, 0.5, 0.0]

    # get the material library
    materialLibrary1 = GetMaterialLibrary()

    # update the view to ensure updated data information
    renderView1.Update()

    # change representation type
    plt00Display.SetRepresentationType('Surface')

    # set scalar coloring
    ColorBy(plt00Display, ('CELLS', 'phi'))

    # rescale color and/or opacity maps used to include current data range
    plt00Display.RescaleTransferFunctionToDataRange(True, False)

    # get color transfer function/color map for 'phi'
    phiLUT = GetColorTransferFunction('phi')

    # get opacity transfer function/opacity map for 'phi'
    phiPWF = GetOpacityTransferFunction('phi')

    # show color bar/color legend
    plt00Display.SetScalarBarVisibility(renderView1, True)

    # create a new 'AMReX/BoxLib Grid Reader'
    plt00_1 = AMReXBoxLibGridReader(FileNames=AllPlotFiles)
    plt00_1.CellArrayStatus = []

    # show data in view
    plt00_1Display = Show(plt00_1, renderView1, 'AMRRepresentation')

    # trace defaults for the display properties.
    plt00_1Display.Representation = 'Outline'
    plt00_1Display.ColorArrayName = [None, '']
    plt00_1Display.OSPRayScaleFunction = 'PiecewiseFunction'
    plt00_1Display.SelectOrientationVectors = 'None'
    plt00_1Display.ScaleFactor = 0.1
    plt00_1Display.SelectScaleArray = 'None'
    plt00_1Display.GlyphType = 'Arrow'
    plt00_1Display.GlyphTableIndexArray = 'None'
    plt00_1Display.GaussianRadius = 0.005
    plt00_1Display.SetScaleArray = [None, '']
    plt00_1Display.ScaleTransferFunction = 'PiecewiseFunction'
    plt00_1Display.OpacityArray = [None, '']
    plt00_1Display.OpacityTransferFunction = 'PiecewiseFunction'
    plt00_1Display.DataAxesGrid = 'GridAxesRepresentation'
    plt00_1Display.PolarAxes = 'PolarAxesRepresentation'
    plt00_1Display.ScalarOpacityUnitDistance = 0.0701538780193358

    # update the view to ensure updated data information
    renderView1.Update()

    # change solid color
    plt00_1Display.AmbientColor = [0.0, 1.0, 0.0]
    plt00_1Display.DiffuseColor = [0.0, 1.0, 0.0]

    # get color legend/bar for phiLUT in view renderView1
    phiLUTColorBar = GetScalarBar(phiLUT, renderView1)

    # change scalar bar placement
    phiLUTColorBar.WindowLocation = 'AnyLocation'
    phiLUTColorBar.Position = [0, 0.75]
    phiLUTColorBar.ScalarBarLength = 0.2

    # current camera placement for renderView1
    renderView1.InteractionMode = '2D'
    renderView1.CameraPosition = [0.5, 0.5, 10000.0]
    renderView1.CameraFocalPoint = [0.5, 0.5, 0.0]
    renderView1.CameraParallelScale = 0.5843857695756589

    # save animation
    output_movie_base = "amr101_2D"
    output_movie = output_movie_base + ".avi"
    SaveAnimation(output_movie,
                  renderView1,
                  ImageResolution=[1200, 1200],
                  FrameRate=args.frame_rate,
                  FrameWindow=[0, len(AllPlotFiles)-1])

    return output_movie_base, output_movie

def convert_avi_to_gif(output_movie_base, output_movie):
    # use ffmpeg to convert the avi movie into an animated gif
    ffmpeg_convert_to_gif = 'ffmpeg -y -i {} -vf "fps=35,scale={}:-1:flags=lanczos,split[s0][s1];[s0]palettegen[p];[s1][p]paletteuse" -loop 0 {}.gif'.format(output_movie, args.resolution, output_movie_base)
    subprocess.run(ffmpeg_convert_to_gif, shell=True)

if __name__ == "__main__":
    if not (args.spacedim == 2 or args.spacedim == 3):
        print("Please specify --spacedim D (with D=2 or D=3)")
        exit()

    if args.frame_rate <= 0:
        print("Please specify --frame_rate F (with F > 0)")
        exit()

    if args.resolution <= 0:
        print("Please specify --resolution R (with R > 0)")
        exit()

    # get all the plotfiles
    PlotFiles = sorted(glob.glob("plt" + "[0-9]"*5))

    # call the 2D or 3D vis function
    output_movie_base = None
    output_movie = None

    if args.spacedim == 3:
        output_movie_base, output_movie = generate_movie_3D(PlotFiles)
    elif args.spacedim == 2:
        output_movie_base, output_movie = generate_movie_2D(PlotFiles)

    # convert the avi movie into an animated gif
    convert_avi_to_gif(output_movie_base, output_movie)


if (NOT 2 IN_LIST AMReX_SPACEDIM)
   return ()
endif ()

set(_sources advect_2d_mod.F90 compute_flux_2d.f90 slope_2d.f90)
list(TRANSFORM _sources PREPEND Src_2d/ )

list(APPEND _sources amr_data_mod.F90 averagedown_mod.F90 bc_mod.F90
   compute_dt_mod.F90 evolve_mod.F90 fillpatch_mod.F90 fmain.F90
   initdata.F90 my_amr_mod.F90 plotfile_mod.F90 tagging_mod.F90)

list(TRANSFORM _sources PREPEND Source/ )

list(APPEND _sources
   Exec/SingleVortex/face_velocity_2d.F90
   Exec/SingleVortex/Prob.f90
   )

file(GLOB_RECURSE _input_files LIST_DIRECTORIES false
   ${CMAKE_CURRENT_LIST_DIR}/input* )


setup_test(2 _sources _input_files HAS_FORTRAN_MODULES)

unset(_sources)
unset(_input_files)


foreach(D IN LISTS AMReX_SPACEDIM)
    if ( NOT AMReX_PARTICLES OR (D EQUAL 1) )
       continue()
    endif ()

    set(_sources advect_${D}d_mod.F90 compute_flux_${D}d.f90 slope_${D}d.f90 )
    list(TRANSFORM _sources PREPEND Src_${D}d/ )

    list(APPEND _sources amr_data_mod.F90 averagedown_mod.F90 bc_mod.F90 compute_dt_mod.F90
       evolve_mod.F90 fillpatch_mod.F90 fmain.F90 initdata.F90 Make.package my_amr_mod.F90
       plotfile_mod.F90 tagging_mod.F90)

    list(TRANSFORM _sources PREPEND Source/ )

    list(APPEND _sources
       Exec/SingleVortex/face_velocity_${D}d.F90
       Exec/SingleVortex/Prob_${D}d.f90
       )

    file( GLOB_RECURSE _input_files LIST_DIRECTORIES false
       ${CMAKE_CURRENT_LIST_DIR}/input* )

    setup_test(${D} _sources _input_files HAS_FORTRAN_MODULES)

    unset(_sources)
    unset(_input_files)
endforeach()


if (NOT (3 IN_LIST AMReX_SPACEDIM) OR NOT CMAKE_Fortran_COMPILER_LOADED)
   return()
endif ()


set(_sources main.cpp CNS_advance.cpp CNSBld.cpp CNS.cpp CNS_F.H CNS.H CNS_init_eb2.cpp CNS_io.cpp
   CNS_setup.cpp )

set(_diffusion_sources cns_diff_mod.F90 cns_eb_diff_mod.F90 cns_eb_diff_wall.F90 diff_coef_mod.F90)
list(TRANSFORM _diffusion_sources PREPEND diffusion/)

set(_fortran_sources bc_fill_nd.F90 CNS_derive.F90 CNS_divop.F90 CNS_dudt.F90 CNS_f.F90 CNS_nd.F90
   CNS_physics.F90 CNS_tagging.F90 )
list(TRANSFORM _fortran_sources PREPEND fortran/)

set(_hydro_sources analriem3d.F90 cns_eb_hyp_wall.F90 Hyp_gamma_MOL_EB.F90 Hyp_gamma_MOL.F90
   slope_mol_3d_gamma_EB.F90 slope_mol_3d_gamma.F90)
list(TRANSFORM _hydro_sources PREPEND hydro/)

list(APPEND _sources ${_diffusion_sources} ${_fortran_sources} ${_hydro_sources})
list(TRANSFORM _sources PREPEND Source/)

unset(_diffusion_sources)
unset(_fortran_sources)
unset(_hydro_sources)


##########################################################################################
#
# Sod tutorial
#
##########################################################################################
set(_sod_sources Exec/Sod/cns_prob.F90 ${_sources})
set(_input_files Exec/Sod/inputs-ci)

setup_test(3 _sod_sources _input_files
   HAS_FORTRAN_MODULES
   BASE_NAME CNS_Sod
   RUNTIME_SUBDIR Sod)

unset(_sod_sources)


#
# Clean-up
#
unset(_sources)
unset(_input_files)


# This is a stand-alone test developed for Spack. In Spack,
# this CMakeLists.txt file is used to build the test when the
# command, `spack test run amrex` is called.
#
# This CMake script builds the test, Tests/Amr/Advection_AmrCore,
# against a currently installed version of AMReX. The resulting
# executable can then be ran to test functionality.

cmake_minimum_required(VERSION 3.18)

project(amrex-test-install)

get_filename_component(_base_dir ${CMAKE_CURRENT_LIST_DIR} DIRECTORY)

set(_base_dir  ${_base_dir}/Amr/Advection_AmrCore)
set(_src_dir   ${_base_dir}/Source)
set(_input_dir ${_base_dir}/Exec)


if (AMReX_FORTRAN_INTERFACES)
    enable_language(Fortran)
endif()

if (AMReX_GPU_BACKEND STREQUAL "CUDA")
    enable_language(CUDA)
    find_package(AMReX REQUIRED CUDA)

elseif(AMReX_GPU_BACKEND STREQUAL "HIP")
    if(CMAKE_VERSION VERSION_LESS 3.20)
        message(FATAL_ERROR "HIP requires CMake version 3.20 or newer")
    endif()
    find_package(AMReX REQUIRED HIP)
    find_package(rocrand REQUIRED CONFIG)
    find_package(rocprim REQUIRED CONFIG)
    find_package(hiprand REQUIRED CONFIG)

else()
   # Use installed version of AMReX
   find_package(AMReX REQUIRED)
endif()

if (AMReX_3D_FOUND)
    set(_dim 3)
elseif (AMReX_2D_FOUND)
    set(_dim 2)
else ()
    message(FATAL_ERROR "Cannot find a 2D or 3D version of AMReX")
endif ()


add_executable(install_test)

target_include_directories(install_test
    PUBLIC
    ${_src_dir}
    ${_src_dir}/Src_K/
    ${_input_dir}
    )

target_sources(install_test
    PRIVATE
    ${_src_dir}/AdvancePhiAllLevels.cpp
    ${_src_dir}/AdvancePhiAtLevel.cpp
    ${_src_dir}/AmrCoreAdv.cpp
    ${_src_dir}/AmrCoreAdv.H
    ${_src_dir}/bc_fill.H
    ${_src_dir}/DefineVelocity.cpp
    ${_src_dir}/face_velocity.H
    ${_src_dir}/Kernels.H
    ${_src_dir}/main.cpp
    ${_src_dir}/Tagging.H
    ${_src_dir}/Src_K/Adv_K.H
    ${_src_dir}/Src_K/compute_flux_2D_K.H
    ${_src_dir}/Src_K/slope_K.H
    ${_input_dir}/Prob.H
    )

target_link_libraries(install_test PUBLIC AMReX::amrex)

# Additional CUDA configuration commands
if (AMReX_GPU_BACKEND STREQUAL "CUDA")
    set_target_properties(install_test PROPERTIES
        LANGUAGE CUDA
        CUDA_ARCHITECTURES "${AMREX_CUDA_ARCHS}"
        CUDA_SEPARABLE_COMPILATION  ON)

    get_target_property(Source_Files install_test SOURCES)
    list(FILTER Source_Files INCLUDE REGEX "\\.cpp$")
    set_source_files_properties(${Source_Files} PROPERTIES LANGUAGE CUDA)
endif()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    if(D EQUAL 1)
        continue()
    endif()

    set(_sources     main.cpp)
    set(_input_files )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    if(D EQUAL 1)
        continue()
    endif()
    set(_sources     main.cpp)
    set(_input_files )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


if (NOT 3 IN_LIST AMReX_SPACEDIM)
   return()
endif ()

set(_sources main.cpp CNS_advance.cpp CNS_bcfill.cpp CNSBld.cpp CNS.cpp CNS_derive.cpp CNS_derive.H CNS.H
   CNS_index_macros.H CNS_io.cpp CNS_K.H CNS_parm.cpp CNS_parm.H CNS_setup.cpp CNS_tagging.H
   hydro/CNS_hydro_K.H diffusion/CNS_diffusion_K.H)
list(TRANSFORM _sources PREPEND Source/)

##########################################################################################
#
# Sod tutorial
#
##########################################################################################
set(_sod_sources Exec/Sod/cns_prob.cpp Exec/Sod/cns_prob.H Exec/Sod/cns_prob_parm.H ${_sources})
set(_input_files Exec/Sod/inputs-ci)

setup_test(3 _sod_sources _input_files
   BASE_NAME GPU_CNS_Sod
   RUNTIME_SUBDIR Sod)

unset(_sod_sources)


#
# Clean-up
#
unset(_sources)
unset(_input_files)


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    if (AMReX_CUDA)
      set(_input_files inputs.rt.cuda  )
    else ()
      set(_input_files inputs.rt  )
    endif ()

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources CheckPair.H Constants.H main.cpp  MDParticleContainer.cpp MDParticleContainer.H )

    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


This unit test

(1) initializes particles,

(2) counts how many particles with which grid id it "owns" (only for grid 0) -- here it only owns the
    particles it started with, e.g. 512 = 8^3 if num_ppc = 1

(3) calls FillNeighbors

(4) counts how many particles with which grid id it "owns" (only for grid 0) -- here it should have
    its original particles plus particles from every other grid, e.g. 8^3 , 6x8^2 , 12x8 , 8x1 from grids
    0 to 26 (if num_ppc = 1)

(5) calls UpdateNeighbors

(6) counts how many particles with which grid id it "owns" (only for grid 0) -- answer should be identical to previous call

(7) calls reset_test_id which sets the "test_id" of every particle (including "ghosts") to the (local)grid id

(8) counts how many particles with which grid id it "owns" (only for grid 0) -- should be
    e.g. 1000 = 8^3 + 6x8^2 + 12x8 + 8x1  (if num_ppc = 1) from grid 0 and no others

(9) calls UpdateNeighbors

(10) counts how many particles with which grid id it "owns" (only for grid 0) -- answer should revert back to that in (4)


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


if ( NOT AMReX_SENSEI )
   return ()
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs.rt  )

    setup_test(${D} _sources _input_files NTASKS 2)

    unset(_sources)
    unset(_input_files)
endforeach()


if (AMReX_MPI)
   return ()
endif()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources main.cpp)

    setup_test(${D} _sources FALSE)

    unset(_sources)
endforeach()


# This tests requires particle support
if (NOT AMReX_PARTICLES)
   return()
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources main.cpp)

    setup_test(${D} _sources FALSE)

    unset(_sources)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


if ( NOT (3 IN_LIST AMReX_SPACEDIM) OR AMReX_MPI
     OR AMReX_PRECISION STREQUAL "SINGLE"
     OR AMReX_PARTICLES_PRECISION STREQUAL "SINGLE" )
   return ()
endif ()

set(_sources     main.cpp)
set(_input_files inputs  particle_file.init  fixed_grids.init)

setup_test(3 _sources _input_files)

unset(_sources)
unset(_input_files)


if ( NOT AMReX_ASCENT )
   return ()
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs.rt  )

    setup_test(${D} _sources _input_files NTASKS 2)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


# This tests requires particle support
if (NOT AMReX_PARTICLES)
   return()
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs)

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


# This tests requires particle support
if (NOT AMReX_PARTICLES)
   return()
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp     mypc.H     trilinear_deposition_K.H)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


if ( NOT (3 IN_LIST AMReX_SPACEDIM) OR AMReX_MPI )
   return ()
endif ()

set(_sources     main.cpp)
set(_input_files inputs  )

setup_test(3 _sources _input_files)

file(COPY particles.txt DESTINATION ${CMAKE_CURRENT_BINARY_DIR}/3d)

unset(_sources)
unset(_input_files)


8
 0.1  0.1 16.2 1000.0 4.0 1.0 6.0
 8.1  0.1 16.2 1000.0 -5 0.0 -7.0
16.1  0.1 16.2 1000.0 6.0 -8.0 2.0
24.1  0.1 16.2 1000.0 9.0 4.0 8.0
 0.1  8.1 16.2 1000.0 -8.0 -3.0 -10.0
 8.1  8.1 16.2 1000.0 2.0 1.0 0.0
16.1  8.1 16.2 1000.0 0.0 2.0 3.0
24.1  8.1 16.2 1000.0 -9.0 7.0 5.0


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources main.cpp)

    setup_test(${D} _sources FALSE)

    unset(_sources)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    #set(_input_files)
    #set(_input_files inputs)

    setup_test(${D} _sources _input_files NTHREADS 2)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    if (AMReX_CUDA)
      set(_input_files inputs.rt.cuda  )
    else ()
      set(_input_files inputs.rt  )
    endif ()

    setup_test(${D} _sources _input_files NTASKS 2)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    if (AMReX_CUDA)
      set(_input_files inputs.rt.cuda  )
    else ()
      set(_input_files inputs.rt  )
    endif ()

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


# This tests requires particle support
if (NOT AMReX_PARTICLES)
   return()
endif ()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


if (AMReX_MPI)
   return()
endif()

foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files inputs  )

    setup_test(${D} _sources _input_files)

    unset(_sources)
    unset(_input_files)
endforeach()


foreach(D IN LISTS AMReX_SPACEDIM)
    set(_sources     main.cpp)
    set(_input_files ba.max)

    setup_test(${D} _sources _input_files CMDLINE_PARAMS nrounds=1)

    unset(_sources)
    unset(_input_files)
endforeach()