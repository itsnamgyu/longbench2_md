HASURA_GRAPHQL_JWT_SECRET={"type":"HS256", "key": "<your-secret>"}


# https://github.com/hasura/graphql-engine/blob/stable/install-manifests/docker-compose/docker-compose.yaml
services:
  postgres:
    image: postgres:15
    restart: always
    volumes:
      - /data/postgresql:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: mypostgrespassword
  graphql-engine:
    image: hasura/graphql-engine:v2.40.0
    ports:
      - 20247:8080
    restart: always
    environment:
      ## postgres database to store Hasura metadata
      HASURA_GRAPHQL_METADATA_DATABASE_URL: postgres://postgres:mypostgrespassword@postgres:5432/postgres
      ## this env var can be used to add the above postgres database to Hasura as a data source. this can be removed/updated based on your needs
      PG_DATABASE_URL: postgres://postgres:mypostgrespassword@postgres:5432/postgres
      ## enable the console served by server
      HASURA_GRAPHQL_ENABLE_CONSOLE: "true" # set to "false" to disable console
      ## enable debugging mode. It is recommended to disable this in production
      # HASURA_GRAPHQL_DEV_MODE: "true"
      HASURA_GRAPHQL_ENABLED_LOG_TYPES: startup, http-log, webhook-log, websocket-log, query-log
      ## uncomment next line to run console offline (i.e load console assets from server instead of CDN)
      # HASURA_GRAPHQL_CONSOLE_ASSETS_DIR: /srv/console-assets
      ## uncomment next line to set an admin secret
      HASURA_GRAPHQL_ADMIN_SECRET: myhasuragraphqladminsecret
    env_file:
      # JWT secret, optional. Use https://jwtsecret.com/generate to generate a base64 secret
      - .local.env


HASURA_GRAPHQL_ENDPOINT=<address>:<port>/v1/graphql
HASURA_GRAPHQL_ADMIN_SECRET=<secret>

JWT_SECRET=<same as in the hasura environment variable>

EMAIL_HOST=smtp.163.com
EMAIL_PORT=465
EMAIL_SECURE=true
EMAIL_ADDRESS=
EMAIL_PASSWORD=

FILE_DIR=/data/upload


services:
  backend:
    image: <your-docker-tag>
    restart: always
    ports:
      - 20248:8888
    env_file:
      - .local.env
    volumes:
      - /data/upload:/data/upload


events {
  worker_connections 1024;
}

http {
  server {
    listen 443 ssl; # listen to IPv4, with SSL
    listen [::]:443 ssl; # listen to IPv6, with SSL

    server_name <your-domain>; # domain name

    ssl_certificate /etc/letsencrypt/live/<your-domain>/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/<your-domain>/privkey.pem;

    location / {
      proxy_pass http://<ip-address>:20248; # proxy to backend server
      client_max_body_size 100M; # allow large file upload
    }

    location /v1/graphql {
      proxy_pass http://<ip-address>:20247; # proxy to hasura graphql endpoint
      # Important: Do not add / to the end of URL, ref: https://blog.csdn.net/q1298252589/article/details/120729989
      proxy_set_header Upgrade $http_upgrade; # enable websocket
      proxy_set_header Connection "upgrade"; # enable websocket
    }
  }
}


services:
  nginx:
    image: nginx:stable-alpine
    ports:
      - 443:443
    restart: always
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - /etc/letsencrypt:/etc/letsencrypt


import dotenv from "dotenv";
import path from "path";

dotenv.config({
  path: path.resolve(process.cwd(), ".local.env"),
});

const config = {
  schema: [
    {
      [process.env.HASURA_GRAPHQL_ENDPOINT!]: {
        headers: {
          "x-hasura-admin-secret": process.env.HASURA_GRAPHQL_ADMIN_SECRET!,
        },
      },
    },
  ],
  documents: ["./graphql/**/*.graphql"],
  generates: {
    "../frontend/src/graphql.tsx": {
      plugins: [
        "typescript",
        "typescript-operations",
        "typescript-react-apollo",
      ],
    },
    "../backend/src/graphql.ts": {
      plugins: [
        "typescript",
        "typescript-operations",
        "typescript-graphql-request",
      ],
      config: {
        gqlImport: "graphql-request#gql",
      },
    },
  },
};

export default config;


-- PostgreSQL
create table if not exists public.user_room (
  user_uuid uuid not null,
  room_uuid uuid not null,
  primary key (user_uuid, room_uuid),
  foreign key (user_uuid) references public.user (uuid) on update cascade on delete cascade,
  foreign key (room_uuid) references public.room (uuid) on update cascade on delete cascade
);

insert into public.user_room (user_uuid, room_uuid) values
('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-100000000001'),
('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-100000000002'),
('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-100000000003'),
('00000000-0000-0000-0000-000000000000', '00000000-0000-0000-0000-100000000004'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000001'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000002'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000003'),
('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-100000000001'),
('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-100000000002'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000001'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000003'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000001'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000003'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000004');


-- PostgreSQL
create table if not exists public.user (
  uuid uuid default gen_random_uuid() not null,
  username text not null unique,
  password text not null,
  primary key (uuid)
);

insert into public.user (uuid, username, password) values
('00000000-0000-0000-0000-000000000000', 'admin', md5('123456')),
('00000000-0000-0000-0000-000000000001', '张三', md5('张三')),
('00000000-0000-0000-0000-000000000002', '李四', md5('李四')),
('00000000-0000-0000-0000-000000000003', '王五', md5('王五')),
('00000000-0000-0000-0000-000000000004', '赵六', md5('赵六'));


-- PostgreSQL
create table if not exists public.room (
  uuid uuid default gen_random_uuid() not null,
  name text not null unique,
  intro text not null,
  invite_code text not null unique,
  created_at timestamp default current_timestamp not null,
  primary key (uuid)
);

insert into public.room (uuid, name, intro, invite_code) values
('00000000-0000-0000-0000-100000000001', '公共聊天室', '欢迎加入公共聊天室', 'gD9jE4'),
('00000000-0000-0000-0000-100000000002', '聊天室1', '这是一个聊天室', 'oC3kY5'),
('00000000-0000-0000-0000-100000000003', '聊天室2', '这是一个聊天室', 'uE8aY9'),
('00000000-0000-0000-0000-100000000004', '聊天室3', '这是一个聊天室', 'aF2jR6');


-- PostgreSQL
create table if not exists public.message (
  uuid uuid default gen_random_uuid() not null,
  user_uuid uuid not null,
  room_uuid uuid not null,
  content text not null,
  created_at timestamp default current_timestamp not null,
  primary key (uuid)
);
alter table public.message
add constraint message_user_uuid_fkey foreign key (user_uuid) references public.user (uuid) on update cascade on delete cascade;
alter table public.message
add constraint message_room_uuid_fkey foreign key (room_uuid) references public.room (uuid) on update cascade on delete cascade;

insert into public.message (user_uuid, room_uuid, content) values
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000001', '大家好，我叫张三'),
('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-100000000001', '大家好，我是李四'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000001', '大家好，叫我王五'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000001', '大家好，俺叫赵六'),
('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-100000000001', '今天天气真好'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000001', '吃了吗您'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000001', 'How are you'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000001', 'I am fine, thank you'),

('00000000-0000-0000-0000-000000000002', '00000000-0000-0000-0000-100000000002', '这是我们俩的私聊哦'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000002', '好的'),

('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000003', '成语接龙：心安理得'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000003', '得过且过'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000003', '过目不忘'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000003', '忘恩负义'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000003', '义无反顾'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000003', '顾全大局'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000003', '局促不安'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000003', '安然无恙'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000003', '恙无伤大'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000003', '大有可为'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000003', '为民除害'),
('00000000-0000-0000-0000-000000000001', '00000000-0000-0000-0000-100000000003', '害人不浅'),
('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-100000000003', '浅尝辄止'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000003', '止于至善'),
('00000000-0000-0000-0000-000000000004', '00000000-0000-0000-0000-100000000003', '好了，今天就到这里吧');

update public.message set created_at = '2021-01-01 00:00:00' where room_uuid = '00000000-0000-0000-0000-100000000002';


mutation addUser($username: String!, $password: String!) {
  insert_user_one(object: {username: $username, password: $password}) {
    uuid
  }
}

query getUsersByUsername($username: String!) {
  user(where: {username: {_eq: $username}}) {
    uuid
    password
  }
}

mutation updateUserPassword($uuid: uuid!, $password: String!){
  update_user_by_pk(pk_columns:{uuid: $uuid},_set:{password: $password}){
    uuid
    password
  }
}

mutation deleteUser($uuid: uuid!){
  delete_user_by_pk(uuid: $uuid){
    uuid
    username
  }
}

mutation deleteUserRoom($uuid: uuid!){
  delete_user_room(where:{user_uuid:{_eq:$uuid}}){
    affected_rows
  }
}

mutation deleteUserMessage($uuid: uuid!){
  delete_message(where:{user_uuid:{_eq: $uuid}}){
    affected_rows
  }
}


mutation addRoom($name: String!, $intro: String!, $invite_code: String!) {
  insert_room_one(object: {name: $name, intro: $intro, invite_code: $invite_code}) {
    uuid
  }
}

query getJoinedRooms($user_uuid: uuid!) {
  user_room(where: {user_uuid: {_eq: $user_uuid}}) {
    room {
      uuid
      name
      intro
      invite_code
      created_at
    }
  }
}

query getRoomByInviteCode($invite_code: String!) {
  room(where: {invite_code: {_eq: $invite_code}}) {
    uuid
  }
}

mutation joinRoom($user_uuid: uuid!, $room_uuid: uuid!) {
  insert_user_room_one(object: {user_uuid: $user_uuid, room_uuid: $room_uuid}) {
    user_uuid
    room_uuid
  }
}


mutation addMessage($user_uuid: uuid!, $room_uuid: uuid!, $content: String!, $reply_to: uuid) {
  insert_message_one(object: {user_uuid: $user_uuid, room_uuid: $room_uuid, content: $content, reply_to: $reply_to}) {
    uuid
  }
}

subscription getMessagesByRoom($room_uuid: uuid!) {
  message(where: {room_uuid: {_eq: $room_uuid}}) {
    uuid
    user {
      uuid
      username
    }
    reply_to
    content
    created_at
  }
}


import express from "express";
import multer from "multer";
import fs from "fs";
import path from "path";
import authenticate from "./authenticate";

const router = express.Router();

const baseDir = process.env.FILE_DIR || path.resolve(process.cwd(), "upload");

const limits = {
  parts: 2, // 1 file and 0 fields
  fileSize: 10 * 1024 * 1024, // 10 MB
};
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    try {
      const room = req.params.room;
      const dir = path.resolve(baseDir, room);
      fs.mkdirSync(dir, { recursive: true });
      return cb(null, dir);
    } catch (err) {
      return cb(err as Error, "");
    }
  },
  filename: (req, file, cb) => {
    return cb(null, file.originalname);
  }
})
const upload = multer({ storage, limits });

router.post("/upload/:room", authenticate, upload.single("file"), (req, res) => {
  const file = req.file;
  if (!file) {
    return res.status(422).send("422 Unprocessable Entity: Missing file");
  }
  return res.send("File uploaded successfully");
});

router.get("/list", authenticate, (req, res) => {
  const room = req.query.room;
  if (!room) {
    return res.status(422).send("422 Unprocessable Entity: Missing room");
  }
  const dir = path.resolve(baseDir, room as string);
  try {
    let fileList: string[] = [];
    if (fs.existsSync(dir)) {
      fileList = fs.readdirSync(dir);
    }
    return res.json({ fileList });
  } catch (err) {
    console.error(err);
    return res.sendStatus(500);
  }
});

router.get("/download", authenticate, (req, res) => {
  const room = req.query.room;
  const filename = req.query.filename;
  if (!room || !filename) {
    return res.status(422).send("422 Unprocessable Entity: Missing room or filename");
  }
  const dir = path.resolve(baseDir, room as string, filename as string);
  try {
    if (fs.existsSync(dir)) {
      return res.download(dir);
    } else {
      return res.status(404).send("404 Not Found: File does not exist");
    }
  } catch (err) {
    console.error(err);
    return res.sendStatus(500);
  }
});

router.post("/delete",authenticate,(req,res)=>{
  const {room,filename} = req.body;
  if(!room || !filename){
    return res.status(422).send("422 Unprocessable Entity: Missing room or filename");
  }
  const filePath =path.resolve(baseDir, room, filename);
  try{
    if(fs.existsSync(filePath)){
      fs.unlinkSync(filePath);
      return res.status(200).send("File Deleted Successfully");
    }else{
      return res.status(404).send("404 Not Found: File does not exist");
    }
  }catch(err){
    console.error(err);
    return res.status(500).send("500 Internal Server Error");
  }
});

export default router;


import { GraphQLClient, RequestOptions } from 'graphql-request';
import { gql } from 'graphql-request';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
type GraphQLClientRequestHeaders = RequestOptions['requestHeaders'];
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  timestamp: { input: any; output: any; }
  uuid: { input: any; output: any; }
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "message" */
export type Message = {
  __typename?: 'message';
  content: Scalars['String']['output'];
  created_at: Scalars['timestamp']['output'];
  reply_to?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  room: Room;
  room_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "message" */
export type Message_Aggregate = {
  __typename?: 'message_aggregate';
  aggregate?: Maybe<Message_Aggregate_Fields>;
  nodes: Array<Message>;
};

export type Message_Aggregate_Bool_Exp = {
  count?: InputMaybe<Message_Aggregate_Bool_Exp_Count>;
};

export type Message_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Message_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Message_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "message" */
export type Message_Aggregate_Fields = {
  __typename?: 'message_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Message_Max_Fields>;
  min?: Maybe<Message_Min_Fields>;
};


/** aggregate fields of "message" */
export type Message_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Message_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "message" */
export type Message_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Message_Max_Order_By>;
  min?: InputMaybe<Message_Min_Order_By>;
};

/** input type for inserting array relation for remote table "message" */
export type Message_Arr_Rel_Insert_Input = {
  data: Array<Message_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Message_On_Conflict>;
};

/** Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'. */
export type Message_Bool_Exp = {
  _and?: InputMaybe<Array<Message_Bool_Exp>>;
  _not?: InputMaybe<Message_Bool_Exp>;
  _or?: InputMaybe<Array<Message_Bool_Exp>>;
  content?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  reply_to?: InputMaybe<Uuid_Comparison_Exp>;
  room?: InputMaybe<Room_Bool_Exp>;
  room_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "message" */
export enum Message_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  MessagePkey = 'message_pkey'
}

/** input type for inserting data into table "message" */
export type Message_Insert_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
  room?: InputMaybe<Room_Obj_Rel_Insert_Input>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Message_Max_Fields = {
  __typename?: 'message_max_fields';
  content?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamp']['output']>;
  reply_to?: Maybe<Scalars['uuid']['output']>;
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "message" */
export type Message_Max_Order_By = {
  content?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  reply_to?: InputMaybe<Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Message_Min_Fields = {
  __typename?: 'message_min_fields';
  content?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamp']['output']>;
  reply_to?: Maybe<Scalars['uuid']['output']>;
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "message" */
export type Message_Min_Order_By = {
  content?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  reply_to?: InputMaybe<Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "message" */
export type Message_Mutation_Response = {
  __typename?: 'message_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Message>;
};

/** on_conflict condition type for table "message" */
export type Message_On_Conflict = {
  constraint: Message_Constraint;
  update_columns?: Array<Message_Update_Column>;
  where?: InputMaybe<Message_Bool_Exp>;
};

/** Ordering options when selecting data from "message". */
export type Message_Order_By = {
  content?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  reply_to?: InputMaybe<Order_By>;
  room?: InputMaybe<Room_Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: message */
export type Message_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "message" */
export enum Message_Select_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ReplyTo = 'reply_to',
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "message" */
export type Message_Set_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "message" */
export type Message_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Message_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Message_Stream_Cursor_Value_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "message" */
export enum Message_Update_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ReplyTo = 'reply_to',
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Message_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Message_Set_Input>;
  /** filter the rows which have to be updated */
  where: Message_Bool_Exp;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "message" */
  delete_message?: Maybe<Message_Mutation_Response>;
  /** delete single row from the table: "message" */
  delete_message_by_pk?: Maybe<Message>;
  /** delete data from the table: "room" */
  delete_room?: Maybe<Room_Mutation_Response>;
  /** delete single row from the table: "room" */
  delete_room_by_pk?: Maybe<Room>;
  /** delete data from the table: "user" */
  delete_user?: Maybe<User_Mutation_Response>;
  /** delete single row from the table: "user" */
  delete_user_by_pk?: Maybe<User>;
  /** delete data from the table: "user_room" */
  delete_user_room?: Maybe<User_Room_Mutation_Response>;
  /** delete single row from the table: "user_room" */
  delete_user_room_by_pk?: Maybe<User_Room>;
  /** insert data into the table: "message" */
  insert_message?: Maybe<Message_Mutation_Response>;
  /** insert a single row into the table: "message" */
  insert_message_one?: Maybe<Message>;
  /** insert data into the table: "room" */
  insert_room?: Maybe<Room_Mutation_Response>;
  /** insert a single row into the table: "room" */
  insert_room_one?: Maybe<Room>;
  /** insert data into the table: "user" */
  insert_user?: Maybe<User_Mutation_Response>;
  /** insert a single row into the table: "user" */
  insert_user_one?: Maybe<User>;
  /** insert data into the table: "user_room" */
  insert_user_room?: Maybe<User_Room_Mutation_Response>;
  /** insert a single row into the table: "user_room" */
  insert_user_room_one?: Maybe<User_Room>;
  /** update data of the table: "message" */
  update_message?: Maybe<Message_Mutation_Response>;
  /** update single row of the table: "message" */
  update_message_by_pk?: Maybe<Message>;
  /** update multiples rows of table: "message" */
  update_message_many?: Maybe<Array<Maybe<Message_Mutation_Response>>>;
  /** update data of the table: "room" */
  update_room?: Maybe<Room_Mutation_Response>;
  /** update single row of the table: "room" */
  update_room_by_pk?: Maybe<Room>;
  /** update multiples rows of table: "room" */
  update_room_many?: Maybe<Array<Maybe<Room_Mutation_Response>>>;
  /** update data of the table: "user" */
  update_user?: Maybe<User_Mutation_Response>;
  /** update single row of the table: "user" */
  update_user_by_pk?: Maybe<User>;
  /** update multiples rows of table: "user" */
  update_user_many?: Maybe<Array<Maybe<User_Mutation_Response>>>;
  /** update data of the table: "user_room" */
  update_user_room?: Maybe<User_Room_Mutation_Response>;
  /** update single row of the table: "user_room" */
  update_user_room_by_pk?: Maybe<User_Room>;
  /** update multiples rows of table: "user_room" */
  update_user_room_many?: Maybe<Array<Maybe<User_Room_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootDelete_MessageArgs = {
  where: Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Message_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RoomArgs = {
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UserArgs = {
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_RoomArgs = {
  where: User_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Room_By_PkArgs = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootInsert_MessageArgs = {
  objects: Array<Message_Insert_Input>;
  on_conflict?: InputMaybe<Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Message_OneArgs = {
  object: Message_Insert_Input;
  on_conflict?: InputMaybe<Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomArgs = {
  objects: Array<Room_Insert_Input>;
  on_conflict?: InputMaybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_OneArgs = {
  object: Room_Insert_Input;
  on_conflict?: InputMaybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserArgs = {
  objects: Array<User_Insert_Input>;
  on_conflict?: InputMaybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OneArgs = {
  object: User_Insert_Input;
  on_conflict?: InputMaybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_RoomArgs = {
  objects: Array<User_Room_Insert_Input>;
  on_conflict?: InputMaybe<User_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Room_OneArgs = {
  object: User_Room_Insert_Input;
  on_conflict?: InputMaybe<User_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootUpdate_MessageArgs = {
  _set?: InputMaybe<Message_Set_Input>;
  where: Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Message_By_PkArgs = {
  _set?: InputMaybe<Message_Set_Input>;
  pk_columns: Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Message_ManyArgs = {
  updates: Array<Message_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RoomArgs = {
  _set?: InputMaybe<Room_Set_Input>;
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_By_PkArgs = {
  _set?: InputMaybe<Room_Set_Input>;
  pk_columns: Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ManyArgs = {
  updates: Array<Room_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UserArgs = {
  _set?: InputMaybe<User_Set_Input>;
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_By_PkArgs = {
  _set?: InputMaybe<User_Set_Input>;
  pk_columns: User_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_ManyArgs = {
  updates: Array<User_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_RoomArgs = {
  _set?: InputMaybe<User_Room_Set_Input>;
  where: User_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Room_By_PkArgs = {
  _set?: InputMaybe<User_Room_Set_Input>;
  pk_columns: User_Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Room_ManyArgs = {
  updates: Array<User_Room_Updates>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "message" */
  message: Array<Message>;
  /** fetch aggregated fields from the table: "message" */
  message_aggregate: Message_Aggregate;
  /** fetch data from the table: "message" using primary key columns */
  message_by_pk?: Maybe<Message>;
  /** fetch data from the table: "room" */
  room: Array<Room>;
  /** fetch aggregated fields from the table: "room" */
  room_aggregate: Room_Aggregate;
  /** fetch data from the table: "room" using primary key columns */
  room_by_pk?: Maybe<Room>;
  /** fetch data from the table: "user" */
  user: Array<User>;
  /** fetch aggregated fields from the table: "user" */
  user_aggregate: User_Aggregate;
  /** fetch data from the table: "user" using primary key columns */
  user_by_pk?: Maybe<User>;
  /** fetch data from the table: "user_room" */
  user_room: Array<User_Room>;
  /** fetch aggregated fields from the table: "user_room" */
  user_room_aggregate: User_Room_Aggregate;
  /** fetch data from the table: "user_room" using primary key columns */
  user_room_by_pk?: Maybe<User_Room>;
};


export type Query_RootMessageArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Query_RootMessage_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Query_RootMessage_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootRoomArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Query_RootRoom_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Query_RootRoom_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUserArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Query_RootUser_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Query_RootUser_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_RoomArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Query_RootUser_Room_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Query_RootUser_Room_By_PkArgs = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "room" */
export type Room = {
  __typename?: 'room';
  created_at: Scalars['timestamp']['output'];
  intro: Scalars['String']['output'];
  invite_code: Scalars['String']['output'];
  /** An array relationship */
  messages: Array<Message>;
  /** An aggregate relationship */
  messages_aggregate: Message_Aggregate;
  name: Scalars['String']['output'];
  /** An array relationship */
  user_rooms: Array<User_Room>;
  /** An aggregate relationship */
  user_rooms_aggregate: User_Room_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "room" */
export type RoomMessagesArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "room" */
export type RoomMessages_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "room" */
export type RoomUser_RoomsArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


/** columns and relationships of "room" */
export type RoomUser_Rooms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};

/** aggregated selection of "room" */
export type Room_Aggregate = {
  __typename?: 'room_aggregate';
  aggregate?: Maybe<Room_Aggregate_Fields>;
  nodes: Array<Room>;
};

/** aggregate fields of "room" */
export type Room_Aggregate_Fields = {
  __typename?: 'room_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Room_Max_Fields>;
  min?: Maybe<Room_Min_Fields>;
};


/** aggregate fields of "room" */
export type Room_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Room_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "room". All fields are combined with a logical 'AND'. */
export type Room_Bool_Exp = {
  _and?: InputMaybe<Array<Room_Bool_Exp>>;
  _not?: InputMaybe<Room_Bool_Exp>;
  _or?: InputMaybe<Array<Room_Bool_Exp>>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  intro?: InputMaybe<String_Comparison_Exp>;
  invite_code?: InputMaybe<String_Comparison_Exp>;
  messages?: InputMaybe<Message_Bool_Exp>;
  messages_aggregate?: InputMaybe<Message_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  user_rooms?: InputMaybe<User_Room_Bool_Exp>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "room" */
export enum Room_Constraint {
  /** unique or primary key constraint on columns "invite_code" */
  RoomInviteCodeKey = 'room_invite_code_key',
  /** unique or primary key constraint on columns "name" */
  RoomNameKey = 'room_name_key',
  /** unique or primary key constraint on columns "uuid" */
  RoomPkey = 'room_pkey'
}

/** input type for inserting data into table "room" */
export type Room_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  intro?: InputMaybe<Scalars['String']['input']>;
  invite_code?: InputMaybe<Scalars['String']['input']>;
  messages?: InputMaybe<Message_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  user_rooms?: InputMaybe<User_Room_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Room_Max_Fields = {
  __typename?: 'room_max_fields';
  created_at?: Maybe<Scalars['timestamp']['output']>;
  intro?: Maybe<Scalars['String']['output']>;
  invite_code?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Room_Min_Fields = {
  __typename?: 'room_min_fields';
  created_at?: Maybe<Scalars['timestamp']['output']>;
  intro?: Maybe<Scalars['String']['output']>;
  invite_code?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "room" */
export type Room_Mutation_Response = {
  __typename?: 'room_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Room>;
};

/** input type for inserting object relation for remote table "room" */
export type Room_Obj_Rel_Insert_Input = {
  data: Room_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Room_On_Conflict>;
};

/** on_conflict condition type for table "room" */
export type Room_On_Conflict = {
  constraint: Room_Constraint;
  update_columns?: Array<Room_Update_Column>;
  where?: InputMaybe<Room_Bool_Exp>;
};

/** Ordering options when selecting data from "room". */
export type Room_Order_By = {
  created_at?: InputMaybe<Order_By>;
  intro?: InputMaybe<Order_By>;
  invite_code?: InputMaybe<Order_By>;
  messages_aggregate?: InputMaybe<Message_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: room */
export type Room_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "room" */
export enum Room_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Intro = 'intro',
  /** column name */
  InviteCode = 'invite_code',
  /** column name */
  Name = 'name',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "room" */
export type Room_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  intro?: InputMaybe<Scalars['String']['input']>;
  invite_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "room" */
export type Room_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Room_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Room_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  intro?: InputMaybe<Scalars['String']['input']>;
  invite_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "room" */
export enum Room_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Intro = 'intro',
  /** column name */
  InviteCode = 'invite_code',
  /** column name */
  Name = 'name',
  /** column name */
  Uuid = 'uuid'
}

export type Room_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Room_Set_Input>;
  /** filter the rows which have to be updated */
  where: Room_Bool_Exp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "message" */
  message: Array<Message>;
  /** fetch aggregated fields from the table: "message" */
  message_aggregate: Message_Aggregate;
  /** fetch data from the table: "message" using primary key columns */
  message_by_pk?: Maybe<Message>;
  /** fetch data from the table in a streaming manner: "message" */
  message_stream: Array<Message>;
  /** fetch data from the table: "room" */
  room: Array<Room>;
  /** fetch aggregated fields from the table: "room" */
  room_aggregate: Room_Aggregate;
  /** fetch data from the table: "room" using primary key columns */
  room_by_pk?: Maybe<Room>;
  /** fetch data from the table in a streaming manner: "room" */
  room_stream: Array<Room>;
  /** fetch data from the table: "user" */
  user: Array<User>;
  /** fetch aggregated fields from the table: "user" */
  user_aggregate: User_Aggregate;
  /** fetch data from the table: "user" using primary key columns */
  user_by_pk?: Maybe<User>;
  /** fetch data from the table: "user_room" */
  user_room: Array<User_Room>;
  /** fetch aggregated fields from the table: "user_room" */
  user_room_aggregate: User_Room_Aggregate;
  /** fetch data from the table: "user_room" using primary key columns */
  user_room_by_pk?: Maybe<User_Room>;
  /** fetch data from the table in a streaming manner: "user_room" */
  user_room_stream: Array<User_Room>;
  /** fetch data from the table in a streaming manner: "user" */
  user_stream: Array<User>;
};


export type Subscription_RootMessageArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Subscription_RootMessage_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Subscription_RootMessage_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootMessage_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Message_Stream_Cursor_Input>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Subscription_RootRoomArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Subscription_RootRoom_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Subscription_RootRoom_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootRoom_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Room_Stream_Cursor_Input>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Subscription_RootUserArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Subscription_RootUser_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Subscription_RootUser_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_RoomArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Subscription_RootUser_Room_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Subscription_RootUser_Room_By_PkArgs = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Room_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Room_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Subscription_RootUser_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Bool_Exp>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']['input']>;
  _gt?: InputMaybe<Scalars['timestamp']['input']>;
  _gte?: InputMaybe<Scalars['timestamp']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamp']['input']>;
  _lte?: InputMaybe<Scalars['timestamp']['input']>;
  _neq?: InputMaybe<Scalars['timestamp']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};

/** columns and relationships of "user" */
export type User = {
  __typename?: 'user';
  /** An array relationship */
  messages: Array<Message>;
  /** An aggregate relationship */
  messages_aggregate: Message_Aggregate;
  password: Scalars['String']['output'];
  /** An array relationship */
  user_rooms: Array<User_Room>;
  /** An aggregate relationship */
  user_rooms_aggregate: User_Room_Aggregate;
  username: Scalars['String']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "user" */
export type UserMessagesArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserMessages_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_RoomsArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Rooms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};

/** aggregated selection of "user" */
export type User_Aggregate = {
  __typename?: 'user_aggregate';
  aggregate?: Maybe<User_Aggregate_Fields>;
  nodes: Array<User>;
};

/** aggregate fields of "user" */
export type User_Aggregate_Fields = {
  __typename?: 'user_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Max_Fields>;
  min?: Maybe<User_Min_Fields>;
};


/** aggregate fields of "user" */
export type User_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'. */
export type User_Bool_Exp = {
  _and?: InputMaybe<Array<User_Bool_Exp>>;
  _not?: InputMaybe<User_Bool_Exp>;
  _or?: InputMaybe<Array<User_Bool_Exp>>;
  messages?: InputMaybe<Message_Bool_Exp>;
  messages_aggregate?: InputMaybe<Message_Aggregate_Bool_Exp>;
  password?: InputMaybe<String_Comparison_Exp>;
  user_rooms?: InputMaybe<User_Room_Bool_Exp>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Bool_Exp>;
  username?: InputMaybe<String_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user" */
export enum User_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserPkey = 'user_pkey',
  /** unique or primary key constraint on columns "username" */
  UserUsernameKey = 'user_username_key'
}

/** input type for inserting data into table "user" */
export type User_Insert_Input = {
  messages?: InputMaybe<Message_Arr_Rel_Insert_Input>;
  password?: InputMaybe<Scalars['String']['input']>;
  user_rooms?: InputMaybe<User_Room_Arr_Rel_Insert_Input>;
  username?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Max_Fields = {
  __typename?: 'user_max_fields';
  password?: Maybe<Scalars['String']['output']>;
  username?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type User_Min_Fields = {
  __typename?: 'user_min_fields';
  password?: Maybe<Scalars['String']['output']>;
  username?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "user" */
export type User_Mutation_Response = {
  __typename?: 'user_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User>;
};

/** input type for inserting object relation for remote table "user" */
export type User_Obj_Rel_Insert_Input = {
  data: User_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<User_On_Conflict>;
};

/** on_conflict condition type for table "user" */
export type User_On_Conflict = {
  constraint: User_Constraint;
  update_columns?: Array<User_Update_Column>;
  where?: InputMaybe<User_Bool_Exp>;
};

/** Ordering options when selecting data from "user". */
export type User_Order_By = {
  messages_aggregate?: InputMaybe<Message_Aggregate_Order_By>;
  password?: InputMaybe<Order_By>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Order_By>;
  username?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user */
export type User_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "user_room" */
export type User_Room = {
  __typename?: 'user_room';
  /** An object relationship */
  room: Room;
  room_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_room" */
export type User_Room_Aggregate = {
  __typename?: 'user_room_aggregate';
  aggregate?: Maybe<User_Room_Aggregate_Fields>;
  nodes: Array<User_Room>;
};

export type User_Room_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Room_Aggregate_Bool_Exp_Count>;
};

export type User_Room_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Room_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Room_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_room" */
export type User_Room_Aggregate_Fields = {
  __typename?: 'user_room_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Room_Max_Fields>;
  min?: Maybe<User_Room_Min_Fields>;
};


/** aggregate fields of "user_room" */
export type User_Room_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Room_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_room" */
export type User_Room_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Room_Max_Order_By>;
  min?: InputMaybe<User_Room_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_room" */
export type User_Room_Arr_Rel_Insert_Input = {
  data: Array<User_Room_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Room_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_room". All fields are combined with a logical 'AND'. */
export type User_Room_Bool_Exp = {
  _and?: InputMaybe<Array<User_Room_Bool_Exp>>;
  _not?: InputMaybe<User_Room_Bool_Exp>;
  _or?: InputMaybe<Array<User_Room_Bool_Exp>>;
  room?: InputMaybe<Room_Bool_Exp>;
  room_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_room" */
export enum User_Room_Constraint {
  /** unique or primary key constraint on columns "room_uuid", "user_uuid" */
  UserRoomPkey = 'user_room_pkey'
}

/** input type for inserting data into table "user_room" */
export type User_Room_Insert_Input = {
  room?: InputMaybe<Room_Obj_Rel_Insert_Input>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Room_Max_Fields = {
  __typename?: 'user_room_max_fields';
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_room" */
export type User_Room_Max_Order_By = {
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Room_Min_Fields = {
  __typename?: 'user_room_min_fields';
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_room" */
export type User_Room_Min_Order_By = {
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_room" */
export type User_Room_Mutation_Response = {
  __typename?: 'user_room_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Room>;
};

/** on_conflict condition type for table "user_room" */
export type User_Room_On_Conflict = {
  constraint: User_Room_Constraint;
  update_columns?: Array<User_Room_Update_Column>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};

/** Ordering options when selecting data from "user_room". */
export type User_Room_Order_By = {
  room?: InputMaybe<Room_Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_room */
export type User_Room_Pk_Columns_Input = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_room" */
export enum User_Room_Select_Column {
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid'
}

/** input type for updating data in table "user_room" */
export type User_Room_Set_Input = {
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_room" */
export type User_Room_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Room_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Room_Stream_Cursor_Value_Input = {
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_room" */
export enum User_Room_Update_Column {
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid'
}

export type User_Room_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Room_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Room_Bool_Exp;
};

/** select columns of table "user" */
export enum User_Select_Column {
  /** column name */
  Password = 'password',
  /** column name */
  Username = 'username',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "user" */
export type User_Set_Input = {
  password?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user" */
export type User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Stream_Cursor_Value_Input = {
  password?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user" */
export enum User_Update_Column {
  /** column name */
  Password = 'password',
  /** column name */
  Username = 'username',
  /** column name */
  Uuid = 'uuid'
}

export type User_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Bool_Exp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

export type AddMessageMutationVariables = Exact<{
  user_uuid: Scalars['uuid']['input'];
  room_uuid: Scalars['uuid']['input'];
  content: Scalars['String']['input'];
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
}>;


export type AddMessageMutation = { __typename?: 'mutation_root', insert_message_one?: { __typename?: 'message', uuid: any } | null };

export type GetMessagesByRoomSubscriptionVariables = Exact<{
  room_uuid: Scalars['uuid']['input'];
}>;


export type GetMessagesByRoomSubscription = { __typename?: 'subscription_root', message: Array<{ __typename?: 'message', uuid: any, reply_to?: any | null, content: string, created_at: any, user: { __typename?: 'user', uuid: any, username: string } }> };

export type AddRoomMutationVariables = Exact<{
  name: Scalars['String']['input'];
  intro: Scalars['String']['input'];
  invite_code: Scalars['String']['input'];
}>;


export type AddRoomMutation = { __typename?: 'mutation_root', insert_room_one?: { __typename?: 'room', uuid: any } | null };

export type GetJoinedRoomsQueryVariables = Exact<{
  user_uuid: Scalars['uuid']['input'];
}>;


export type GetJoinedRoomsQuery = { __typename?: 'query_root', user_room: Array<{ __typename?: 'user_room', room: { __typename?: 'room', uuid: any, name: string, intro: string, invite_code: string, created_at: any } }> };

export type GetRoomByInviteCodeQueryVariables = Exact<{
  invite_code: Scalars['String']['input'];
}>;


export type GetRoomByInviteCodeQuery = { __typename?: 'query_root', room: Array<{ __typename?: 'room', uuid: any }> };

export type JoinRoomMutationVariables = Exact<{
  user_uuid: Scalars['uuid']['input'];
  room_uuid: Scalars['uuid']['input'];
}>;


export type JoinRoomMutation = { __typename?: 'mutation_root', insert_user_room_one?: { __typename?: 'user_room', user_uuid: any, room_uuid: any } | null };

export type AddUserMutationVariables = Exact<{
  username: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type AddUserMutation = { __typename?: 'mutation_root', insert_user_one?: { __typename?: 'user', uuid: any } | null };

export type GetUsersByUsernameQueryVariables = Exact<{
  username: Scalars['String']['input'];
}>;


export type GetUsersByUsernameQuery = { __typename?: 'query_root', user: Array<{ __typename?: 'user', uuid: any, password: string }> };

export type UpdateUserPasswordMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
  password: Scalars['String']['input'];
}>;


export type UpdateUserPasswordMutation = { __typename?: 'mutation_root', update_user_by_pk?: { __typename?: 'user', uuid: any, password: string } | null };

export type DeleteUserMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
}>;


export type DeleteUserMutation = { __typename?: 'mutation_root', delete_user_by_pk?: { __typename?: 'user', uuid: any, username: string } | null };

export type DeleteUserRoomMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
}>;


export type DeleteUserRoomMutation = { __typename?: 'mutation_root', delete_user_room?: { __typename?: 'user_room_mutation_response', affected_rows: number } | null };

export type DeleteUserMessageMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
}>;


export type DeleteUserMessageMutation = { __typename?: 'mutation_root', delete_message?: { __typename?: 'message_mutation_response', affected_rows: number } | null };


export const AddMessageDocument = gql`
    mutation addMessage($user_uuid: uuid!, $room_uuid: uuid!, $content: String!, $reply_to: uuid) {
  insert_message_one(
    object: {user_uuid: $user_uuid, room_uuid: $room_uuid, content: $content, reply_to: $reply_to}
  ) {
    uuid
  }
}
    `;
export const GetMessagesByRoomDocument = gql`
    subscription getMessagesByRoom($room_uuid: uuid!) {
  message(where: {room_uuid: {_eq: $room_uuid}}) {
    uuid
    user {
      uuid
      username
    }
    reply_to
    content
    created_at
  }
}
    `;
export const AddRoomDocument = gql`
    mutation addRoom($name: String!, $intro: String!, $invite_code: String!) {
  insert_room_one(object: {name: $name, intro: $intro, invite_code: $invite_code}) {
    uuid
  }
}
    `;
export const GetJoinedRoomsDocument = gql`
    query getJoinedRooms($user_uuid: uuid!) {
  user_room(where: {user_uuid: {_eq: $user_uuid}}) {
    room {
      uuid
      name
      intro
      invite_code
      created_at
    }
  }
}
    `;
export const GetRoomByInviteCodeDocument = gql`
    query getRoomByInviteCode($invite_code: String!) {
  room(where: {invite_code: {_eq: $invite_code}}) {
    uuid
  }
}
    `;
export const JoinRoomDocument = gql`
    mutation joinRoom($user_uuid: uuid!, $room_uuid: uuid!) {
  insert_user_room_one(object: {user_uuid: $user_uuid, room_uuid: $room_uuid}) {
    user_uuid
    room_uuid
  }
}
    `;
export const AddUserDocument = gql`
    mutation addUser($username: String!, $password: String!) {
  insert_user_one(object: {username: $username, password: $password}) {
    uuid
  }
}
    `;
export const GetUsersByUsernameDocument = gql`
    query getUsersByUsername($username: String!) {
  user(where: {username: {_eq: $username}}) {
    uuid
    password
  }
}
    `;
export const UpdateUserPasswordDocument = gql`
    mutation updateUserPassword($uuid: uuid!, $password: String!) {
  update_user_by_pk(pk_columns: {uuid: $uuid}, _set: {password: $password}) {
    uuid
    password
  }
}
    `;
export const DeleteUserDocument = gql`
    mutation deleteUser($uuid: uuid!) {
  delete_user_by_pk(uuid: $uuid) {
    uuid
    username
  }
}
    `;
export const DeleteUserRoomDocument = gql`
    mutation deleteUserRoom($uuid: uuid!) {
  delete_user_room(where: {user_uuid: {_eq: $uuid}}) {
    affected_rows
  }
}
    `;
export const DeleteUserMessageDocument = gql`
    mutation deleteUserMessage($uuid: uuid!) {
  delete_message(where: {user_uuid: {_eq: $uuid}}) {
    affected_rows
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string, operationType?: string, variables?: any) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName, _operationType, _variables) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    addMessage(variables: AddMessageMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AddMessageMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddMessageMutation>(AddMessageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'addMessage', 'mutation', variables);
    },
    getMessagesByRoom(variables: GetMessagesByRoomSubscriptionVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetMessagesByRoomSubscription> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetMessagesByRoomSubscription>(GetMessagesByRoomDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getMessagesByRoom', 'subscription', variables);
    },
    addRoom(variables: AddRoomMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AddRoomMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddRoomMutation>(AddRoomDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'addRoom', 'mutation', variables);
    },
    getJoinedRooms(variables: GetJoinedRoomsQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetJoinedRoomsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetJoinedRoomsQuery>(GetJoinedRoomsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getJoinedRooms', 'query', variables);
    },
    getRoomByInviteCode(variables: GetRoomByInviteCodeQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetRoomByInviteCodeQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetRoomByInviteCodeQuery>(GetRoomByInviteCodeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getRoomByInviteCode', 'query', variables);
    },
    joinRoom(variables: JoinRoomMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<JoinRoomMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<JoinRoomMutation>(JoinRoomDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'joinRoom', 'mutation', variables);
    },
    addUser(variables: AddUserMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<AddUserMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddUserMutation>(AddUserDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'addUser', 'mutation', variables);
    },
    getUsersByUsername(variables: GetUsersByUsernameQueryVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<GetUsersByUsernameQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GetUsersByUsernameQuery>(GetUsersByUsernameDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'getUsersByUsername', 'query', variables);
    },
    updateUserPassword(variables: UpdateUserPasswordMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<UpdateUserPasswordMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<UpdateUserPasswordMutation>(UpdateUserPasswordDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'updateUserPassword', 'mutation', variables);
    },
    deleteUser(variables: DeleteUserMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DeleteUserMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeleteUserMutation>(DeleteUserDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'deleteUser', 'mutation', variables);
    },
    deleteUserRoom(variables: DeleteUserRoomMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DeleteUserRoomMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeleteUserRoomMutation>(DeleteUserRoomDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'deleteUserRoom', 'mutation', variables);
    },
    deleteUserMessage(variables: DeleteUserMessageMutationVariables, requestHeaders?: GraphQLClientRequestHeaders): Promise<DeleteUserMessageMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeleteUserMessageMutation>(DeleteUserMessageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'deleteUserMessage', 'mutation', variables);
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;

import express from "express";
import morgan from "morgan";
import dotenv from "dotenv";
import path from "path";
import { GraphQLClient } from "graphql-request";
import { getSdk } from "./graphql";
import userRouter from "./user";
import fileRouter from "./file";
import emailRouter from "./email";


const app = express();
const address = "http://localhost";
const port = 8888;

dotenv.config({
  path: path.resolve(process.cwd(), ".local.env"),
});

const client = new GraphQLClient(
  process.env.HASURA_GRAPHQL_ENDPOINT!,
  {
    headers: {
      "Content-Type": "application/json",
      "x-hasura-admin-secret": process.env.HASURA_GRAPHQL_ADMIN_SECRET!,
    },
  }
);
export const sdk = getSdk(client);

// Log all requests to the console, optional.
app.use(morgan(process.env.NODE_ENV === "production" ? "combined" : "dev"));

app.all("*", (req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "*");
  next();
});

app.use(express.json());

app.get('/', (req, res) => {
  res.send('Hello, World!');
});

app.use("/user", userRouter);
app.use("/file", fileRouter);
app.use("/email", emailRouter);

app.listen(port, () => {
  console.log(`Server running at ${address}:${port}/`);
});


import express from "express";
import jwt from "jsonwebtoken";
import { sdk as graphql } from "./index";
import changePasswordRouter from "./changePassword";
import deleteUserRouter from "./deleteUser";

interface userJWTPayload {
  uuid: string;
  "https://hasura.io/jwt/claims": {
    "x-hasura-allowed-roles": string[];
    "x-hasura-default-role": string;
  };
}

const router = express.Router();

router.post("/login", async (req, res) => {
  const { username, password } = req.body;
  console.log(username, password);
  //console.log(req);
  if (!username || !password) {
    return res.status(422).send("422 Unprocessable Entity: Missing username or password");
  }
  try {
    const queryResult = await graphql.getUsersByUsername({ username: username });
    if (queryResult.user.length === 0) {
      return res.status(404).send("404 Not Found: User does not exist");
    }
    const user = queryResult.user[0];
    if (user.password !== password) {
      return res.status(401).send("401 Unauthorized: Password does not match");
    }
    const payload: userJWTPayload = {
      uuid: user.uuid,
      "https://hasura.io/jwt/claims": {
        "x-hasura-allowed-roles": ["admin", "user"],
        "x-hasura-default-role": "user",
      },
    };
    const token = jwt.sign(payload, process.env.JWT_SECRET!, {
      expiresIn: "24h",
    });
    return res.status(200).json({ token });
  } catch (err) {
    console.error(err);
    return res.sendStatus(500);
  }
});

router.post("/register", async (req, res) => {
  const { username, password } = req.body;
  if (!username || !password) {
    return res.status(422).send("422 Unprocessable Entity: Missing username or password");
  }
  try {
    const queryResult = await graphql.getUsersByUsername({ username: username });
    if (queryResult.user.length !== 0) {
      return res.status(409).send("409 Conflict: User already exists");
    }
    const mutationResult = await graphql.addUser({ username: username, password: password });
    const payload: userJWTPayload = {
      uuid: mutationResult.insert_user_one?.uuid,
      "https://hasura.io/jwt/claims": {
        "x-hasura-allowed-roles": ["admin", "user"],
        "x-hasura-default-role": "user",
      },
    };
    const token = jwt.sign(payload, process.env.JWT_SECRET!, {
      expiresIn: "24h",
    });
    return res.status(200).json({ token });
  } catch (err) {
    console.error(err);
    return res.sendStatus(500);
  }
});

router.post("/change-password/request", changePasswordRouter);
router.post("/change-password/action", changePasswordRouter);
router.get("/delete", deleteUserRouter);

export default router;


import { Request, Response, NextFunction } from "express";
import jwt from "jsonwebtoken";

const authenticate: (req: Request, res: Response, next: NextFunction) => Response | void =
  (req, res, next) => {
    const authHeader = req.get("Authorization");
    if (!authHeader) {
      return res.status(401).send("401 Unauthorized: Missing Token");
    }
    const token = authHeader.substring(7);
    return jwt.verify(token, process.env.JWT_SECRET!, async (err, decoded) => {
      if (err || !decoded) {
        return res.status(401).send("401 Unauthorized: Token expired or invalid");
      }
      return next();
    });
  };

export default authenticate;


import express from "express";
import jwt from "jsonwebtoken";
import {sdk as graphql} from "./index";
import nodemailer from "nodemailer";

const router = express.Router();

router.get("/delete", async(req,res) => {
    const authHeader = req.headers.authorization;
    if(!authHeader){
        return res.status(401).send("401 Unauthorized: Missing Authorization Header");
    }
    const token = authHeader.split(" ")[1];
    let userId;
    try{
        try{
            jwt.verify(token, process.env.JWT_SECRET!);
        }catch(err){
            return res.status(401).send("401 Unauthorized: Invalid Token");
        }
        const payload = jwt.decode(token) as {uuid:string};
        if(!payload.uuid){
            console.log(payload.uuid);
            return res.status(403).send("403 Forbidden: Invalid UUID");
        }
        const query = await graphql.deleteUser({uuid: payload.uuid});
        console.log(payload.uuid);
        return res.status(200).send("User Deleted");
    }catch(err){
        console.log(err);
        return res.status(500).send("500 Internal Server Error");
    }
});

export default router;

import express from "express";
import jwt from "jsonwebtoken";
import {sdk as graphql} from "./index";
import nodemailer from "nodemailer";
import { prototype } from "events";

const router = express.Router();

router.post("/change-password/request", async (req, res) => {
    const {username} = req.body;
    if(!username){
        return res.status(422).send("422 Unprocessable Entity: Missing username");
    }
    try{
        const queryResult = await graphql.getUsersByUsername({username: username});
        if(queryResult.user.length == 0){
            return res.status(404).send("404 Not Found: User does not exist");
        }
        const user = queryResult.user[0];
        const payload = {uuid:user.uuid, username:username };  
        const token = jwt.sign(payload, process.env.JWT_SECRET!, {expiresIn: "1h"});
        // 未检查username是不是合法的email地址
        // Check if the username is a valid email address
        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(username)) { // 这个写法值得学习
            return res.status(422).send("422 Unprocessable Entity: Invalid username(Not an email Address)");
        }
        const transporter = nodemailer.createTransport({
            host: process.env.EMAIL_HOST,
            port: parseInt(process.env.EMAIL_PORT!),
            auth:{
                user: process.env.EMAIL_ADDRESS,
                pass: process.env.EMAIL_PASSWORD
            },
            logger: true,
            debug: true
        });
        if(!process.env.EMAIL_ADDRESS || !process.env.EMAIL_PASSWORD){
            return res.status(500).send("500: Can't Send EMAIL");
        }
        const mailOptions = {
            from: process.env.EMAIL_ADDRESS,
            to: username,
            subject: "Password Reset Request",
            text: `Please use the following link to reset your password: localhost:3000/user/change-password/reset
            your token below : ${'\n'}${token}`
        };
        await transporter.sendMail(mailOptions);
        console.log(token);
        return res.status(200).send("Reset Email send");
    }catch (err){
        console.error(err);
        return res.sendStatus(500);
    }
});

router.post("/change-password/action", async (req,res) => { 
    const {token, newPassword} = req.body;
    if(!token || !newPassword){
        return res.status(422).send("422 Unprocessable Entity: Missing New Password/token");
    }
    try{ 
        try{
            console.log(jwt.decode(token));
            jwt.verify(token, process.env.JWT_SECRET!);
        }catch(err){
            return res.status(401).send("401 Unauthorized: Invalid token");
        }
        const decoded = jwt.decode(token) as {uuid: string, username: string};
        const query = await graphql.updateUserPassword({uuid: decoded.uuid, password: newPassword});
        if(query.update_user_by_pk){
            return res.status(200).send("Password Updated");
        }else{
            return res.status(500).send("500 Internal Server Error");
        }
    }catch(err){
        console.error(err);
        return res.status(500).send("500 Server Error");
    }
});

export default router;

import express from "express";
import nodemailer from "nodemailer";

const router = express.Router();

const sendEmail = async (to: string, subject: string, text: string) => {
  const transporter = nodemailer.createTransport({
    host: process.env.EMAIL_HOST!,
    port: Number(process.env.EMAIL_PORT!),
    secure: process.env.EMAIL_SECURE! === "true",
    auth: {
      user: process.env.EMAIL_ADDRESS!,
      pass: process.env.EMAIL_PASSWORD!,
    },
    tls: { rejectUnauthorized: false },
  });
  try {
    await transporter.verify();
    return await transporter.sendMail({ from: process.env.EMAIL_ADDRESS!, to, subject, text });
  } catch (err) {
    throw err;
  }
}

router.post("/contact-us", async (req, res) => {
  const { email, name, message } = req.body;
  if (!email || !name || !message) {
    return res.status(422).send("422 Unprocessable Entity: Missing email, name, or message");
  }
  try {
    const result = await sendEmail(
      process.env.EMAIL_ADDRESS!,
      "Web Workshop Contact Us Form",
      `Message from ${name} <${email}>:\n\n${message}`,
    );
    if (result.accepted.length > 0) {
      return res.send("Message sent successfully");
    } else {
      throw new Error("Failed to send message for unknown reason");
    }
  } catch (err) {
    console.error(err);
    return res.sendStatus(500);
  }
});

export default router;


import os

def batch_rename_extension(cur_directory,tar_directory, old_ext, new_ext):
    # 确保后缀以点号开头
    if not old_ext.startswith('.'):
        old_ext = '.' + old_ext
    if not new_ext.startswith('.'):
        new_ext = '.' + new_ext

    for filename in os.listdir(cur_directory):
        # 检查文件是否以目标后缀结尾
        if filename.endswith(old_ext):
            # 构建旧文件名和新文件名
            old_file = os.path.join(cur_directory, filename)
            new_file = os.path.join(tar_directory, filename[:-len(old_ext)] + new_ext)
            # 重命名文件
            os.rename(old_file, new_file)
            print(f'Renamed {old_file} -> {new_file}')

# 示例调用
cur_directory = './'  # 替换为目标目录路径
tar_directory = './new'
old_ext = '.tsx'  # 替换为当前后缀
new_ext = '.txt'  # 替换为新后缀

batch_rename_extension(cur_directory,tar_directory, old_ext, new_ext)

import { useEffect, useState } from "react";
import { Button, List, message, Spin, Upload } from "antd";
import {
  InboxOutlined,
  DownloadOutlined,
  ReloadOutlined,
} from "@ant-design/icons";
import axios from "axios";
import * as graphql from "./graphql";
import { Card, Container, Scroll, Text } from "./Components";

const { Dragger } = Upload;

interface FileShareProps {
  room: graphql.GetJoinedRoomsQuery["user_room"][0]["room"] | undefined;
  handleClose: () => void;
}

const fetchFileList = async (roomUUID: string) => {
  try {
    const response = await axios.get("/file/list?room=" + roomUUID);
    return response.data.fileList;
  } catch (error) {
    console.error(error);
    message.error("获取文件列表失败！");
    return [];
  }
};

const downloadFile = async (roomUUID: string, filename: string) => {
  try {
    message.info("正在请求下载...");
    const response = await axios.get(
      "/file/download?room=" + roomUUID + "&filename=" + filename
    );
    const url = window.URL.createObjectURL(new Blob([response.data]));
    const link = document.createElement("a");
    link.href = url;
    link.setAttribute("download", filename);
    document.body.appendChild(link);
    link.click();
    link.remove();
    message.success("开始下载文件！");
  } catch (error) {
    console.error(error);
    message.error("下载文件失败！");
  }
};

const FileShare: React.FC<FileShareProps> = ({ room, handleClose }) => {
  const [fileList, setFileList] = useState<string[]>([]);
  const [loading, setLoading] = useState(false);
  const [refreshing, setRefreshing] = useState(false);

  useEffect(() => {
    if (room) {
      fetchFileList(room.uuid).then(setFileList);
    }
  }, [room]);

  const uploadFile = async (file: File, onSuccess: any, onError: any) => {
    setLoading(true);
    const formData = new FormData();
    formData.append("file", file);
    try {
      await axios.post("/file/upload/" + room?.uuid, formData);
      await fetchFileList(room?.uuid).then(setFileList);
      message.success("上传文件成功！");
      onSuccess?.();
    } catch (error) {
      console.error(error);
      message.error("上传文件失败！");
      onError?.(error as Error);
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    if (room) {
      fetchFileList(room.uuid).then(setFileList);
    }
    setTimeout(() => setRefreshing(false), 1000);
  };

  const Refresh = () => (
    <Button
      type="link"
      style={{
        width: "40px",
        height: "40px",
        fontSize: "16px",
        position: "absolute",
        left: 0,
        top: 0,
      }}
      className="need-interaction"
      onClick={handleRefresh}
    >
      <ReloadOutlined spin={refreshing} />
    </Button>
  );

  const Close = () => (
    <Button
      type="link"
      style={{
        width: "40px",
        height: "40px",
        fontSize: "12px",
        position: "absolute",
        right: 0,
        top: 0,
      }}
      className="need-interaction"
      onClick={handleClose}
    >
      ❌
    </Button>
  );

  if (!room) {
    return null;
  }
  return (
    <Card style={{ width: "300px", height: "500px" }}>
      <Refresh />
      <Close />
      <Container style={{ margin: "6px" }}>
        <Text>
          <strong>{room.name}</strong>
        </Text>
        <Text size="small" style={{ marginTop: "6px", marginBottom: "6px" }}>
          文件共享空间
        </Text>
      </Container>
      <FileList roomUUID={room.uuid} filelist={fileList} />
      <div
        className="need-interaction"
        style={{ marginTop: "12px", width: "100%" }}
      >
        <Dragger
          customRequest={({ file, onSuccess, onError }) => {
            uploadFile(file as File, onSuccess, onError);
          }}
          showUploadList={false}
          disabled={loading}
        >
          <p className="ant-upload-drag-icon">
            {loading ? <Spin size="large" /> : <InboxOutlined />}
          </p>
          <p className="ant-upload-text">拖拽或点击上传文件</p>
        </Dragger>
      </div>
    </Card>
  );
};

interface FileListProps {
  roomUUID: string;
  filelist: string[];
}

const FileList: React.FC<FileListProps> = ({ roomUUID, filelist }) => {
  const Download = (filename: string) => (
    <Button
      type="link"
      style={{ fontSize: "18px", width: "18px", height: "18px", padding: 0 }}
      onClick={async () => await downloadFile(roomUUID, filename)}
    >
      <DownloadOutlined />
    </Button>
  );
  return (
    <Scroll>
      <List
        size="small"
        dataSource={filelist}
        renderItem={(filename) => (
          <List.Item style={{ padding: "8px" }} actions={[Download(filename)]}>
            <Text style={{ wordBreak: "break-all" }}>{filename}</Text>
          </List.Item>
        )}
      />
    </Scroll>
  );
};

export default FileShare;


import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  timestamp: { input: any; output: any; }
  uuid: { input: any; output: any; }
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** columns and relationships of "message" */
export type Message = {
  __typename?: 'message';
  content: Scalars['String']['output'];
  created_at: Scalars['timestamp']['output'];
  reply_to?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  room: Room;
  room_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
  uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "message" */
export type Message_Aggregate = {
  __typename?: 'message_aggregate';
  aggregate?: Maybe<Message_Aggregate_Fields>;
  nodes: Array<Message>;
};

export type Message_Aggregate_Bool_Exp = {
  count?: InputMaybe<Message_Aggregate_Bool_Exp_Count>;
};

export type Message_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<Message_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<Message_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "message" */
export type Message_Aggregate_Fields = {
  __typename?: 'message_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Message_Max_Fields>;
  min?: Maybe<Message_Min_Fields>;
};


/** aggregate fields of "message" */
export type Message_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Message_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "message" */
export type Message_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Message_Max_Order_By>;
  min?: InputMaybe<Message_Min_Order_By>;
};

/** input type for inserting array relation for remote table "message" */
export type Message_Arr_Rel_Insert_Input = {
  data: Array<Message_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Message_On_Conflict>;
};

/** Boolean expression to filter rows from the table "message". All fields are combined with a logical 'AND'. */
export type Message_Bool_Exp = {
  _and?: InputMaybe<Array<Message_Bool_Exp>>;
  _not?: InputMaybe<Message_Bool_Exp>;
  _or?: InputMaybe<Array<Message_Bool_Exp>>;
  content?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  reply_to?: InputMaybe<Uuid_Comparison_Exp>;
  room?: InputMaybe<Room_Bool_Exp>;
  room_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "message" */
export enum Message_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  MessagePkey = 'message_pkey'
}

/** input type for inserting data into table "message" */
export type Message_Insert_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
  room?: InputMaybe<Room_Obj_Rel_Insert_Input>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Message_Max_Fields = {
  __typename?: 'message_max_fields';
  content?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamp']['output']>;
  reply_to?: Maybe<Scalars['uuid']['output']>;
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "message" */
export type Message_Max_Order_By = {
  content?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  reply_to?: InputMaybe<Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Message_Min_Fields = {
  __typename?: 'message_min_fields';
  content?: Maybe<Scalars['String']['output']>;
  created_at?: Maybe<Scalars['timestamp']['output']>;
  reply_to?: Maybe<Scalars['uuid']['output']>;
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "message" */
export type Message_Min_Order_By = {
  content?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  reply_to?: InputMaybe<Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "message" */
export type Message_Mutation_Response = {
  __typename?: 'message_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Message>;
};

/** on_conflict condition type for table "message" */
export type Message_On_Conflict = {
  constraint: Message_Constraint;
  update_columns?: Array<Message_Update_Column>;
  where?: InputMaybe<Message_Bool_Exp>;
};

/** Ordering options when selecting data from "message". */
export type Message_Order_By = {
  content?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  reply_to?: InputMaybe<Order_By>;
  room?: InputMaybe<Room_Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: message */
export type Message_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "message" */
export enum Message_Select_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ReplyTo = 'reply_to',
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "message" */
export type Message_Set_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "message" */
export type Message_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Message_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Message_Stream_Cursor_Value_Input = {
  content?: InputMaybe<Scalars['String']['input']>;
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "message" */
export enum Message_Update_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ReplyTo = 'reply_to',
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid',
  /** column name */
  Uuid = 'uuid'
}

export type Message_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Message_Set_Input>;
  /** filter the rows which have to be updated */
  where: Message_Bool_Exp;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "message" */
  delete_message?: Maybe<Message_Mutation_Response>;
  /** delete single row from the table: "message" */
  delete_message_by_pk?: Maybe<Message>;
  /** delete data from the table: "room" */
  delete_room?: Maybe<Room_Mutation_Response>;
  /** delete single row from the table: "room" */
  delete_room_by_pk?: Maybe<Room>;
  /** delete data from the table: "user" */
  delete_user?: Maybe<User_Mutation_Response>;
  /** delete single row from the table: "user" */
  delete_user_by_pk?: Maybe<User>;
  /** delete data from the table: "user_room" */
  delete_user_room?: Maybe<User_Room_Mutation_Response>;
  /** delete single row from the table: "user_room" */
  delete_user_room_by_pk?: Maybe<User_Room>;
  /** insert data into the table: "message" */
  insert_message?: Maybe<Message_Mutation_Response>;
  /** insert a single row into the table: "message" */
  insert_message_one?: Maybe<Message>;
  /** insert data into the table: "room" */
  insert_room?: Maybe<Room_Mutation_Response>;
  /** insert a single row into the table: "room" */
  insert_room_one?: Maybe<Room>;
  /** insert data into the table: "user" */
  insert_user?: Maybe<User_Mutation_Response>;
  /** insert a single row into the table: "user" */
  insert_user_one?: Maybe<User>;
  /** insert data into the table: "user_room" */
  insert_user_room?: Maybe<User_Room_Mutation_Response>;
  /** insert a single row into the table: "user_room" */
  insert_user_room_one?: Maybe<User_Room>;
  /** update data of the table: "message" */
  update_message?: Maybe<Message_Mutation_Response>;
  /** update single row of the table: "message" */
  update_message_by_pk?: Maybe<Message>;
  /** update multiples rows of table: "message" */
  update_message_many?: Maybe<Array<Maybe<Message_Mutation_Response>>>;
  /** update data of the table: "room" */
  update_room?: Maybe<Room_Mutation_Response>;
  /** update single row of the table: "room" */
  update_room_by_pk?: Maybe<Room>;
  /** update multiples rows of table: "room" */
  update_room_many?: Maybe<Array<Maybe<Room_Mutation_Response>>>;
  /** update data of the table: "user" */
  update_user?: Maybe<User_Mutation_Response>;
  /** update single row of the table: "user" */
  update_user_by_pk?: Maybe<User>;
  /** update multiples rows of table: "user" */
  update_user_many?: Maybe<Array<Maybe<User_Mutation_Response>>>;
  /** update data of the table: "user_room" */
  update_user_room?: Maybe<User_Room_Mutation_Response>;
  /** update single row of the table: "user_room" */
  update_user_room_by_pk?: Maybe<User_Room>;
  /** update multiples rows of table: "user_room" */
  update_user_room_many?: Maybe<Array<Maybe<User_Room_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootDelete_MessageArgs = {
  where: Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Message_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_RoomArgs = {
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UserArgs = {
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_User_RoomArgs = {
  where: User_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_Room_By_PkArgs = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootInsert_MessageArgs = {
  objects: Array<Message_Insert_Input>;
  on_conflict?: InputMaybe<Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Message_OneArgs = {
  object: Message_Insert_Input;
  on_conflict?: InputMaybe<Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomArgs = {
  objects: Array<Room_Insert_Input>;
  on_conflict?: InputMaybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_OneArgs = {
  object: Room_Insert_Input;
  on_conflict?: InputMaybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserArgs = {
  objects: Array<User_Insert_Input>;
  on_conflict?: InputMaybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OneArgs = {
  object: User_Insert_Input;
  on_conflict?: InputMaybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_RoomArgs = {
  objects: Array<User_Room_Insert_Input>;
  on_conflict?: InputMaybe<User_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_Room_OneArgs = {
  object: User_Room_Insert_Input;
  on_conflict?: InputMaybe<User_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootUpdate_MessageArgs = {
  _set?: InputMaybe<Message_Set_Input>;
  where: Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Message_By_PkArgs = {
  _set?: InputMaybe<Message_Set_Input>;
  pk_columns: Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Message_ManyArgs = {
  updates: Array<Message_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_RoomArgs = {
  _set?: InputMaybe<Room_Set_Input>;
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_By_PkArgs = {
  _set?: InputMaybe<Room_Set_Input>;
  pk_columns: Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ManyArgs = {
  updates: Array<Room_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UserArgs = {
  _set?: InputMaybe<User_Set_Input>;
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_By_PkArgs = {
  _set?: InputMaybe<User_Set_Input>;
  pk_columns: User_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_ManyArgs = {
  updates: Array<User_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_User_RoomArgs = {
  _set?: InputMaybe<User_Room_Set_Input>;
  where: User_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_Room_By_PkArgs = {
  _set?: InputMaybe<User_Room_Set_Input>;
  pk_columns: User_Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_User_Room_ManyArgs = {
  updates: Array<User_Room_Updates>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "message" */
  message: Array<Message>;
  /** fetch aggregated fields from the table: "message" */
  message_aggregate: Message_Aggregate;
  /** fetch data from the table: "message" using primary key columns */
  message_by_pk?: Maybe<Message>;
  /** fetch data from the table: "room" */
  room: Array<Room>;
  /** fetch aggregated fields from the table: "room" */
  room_aggregate: Room_Aggregate;
  /** fetch data from the table: "room" using primary key columns */
  room_by_pk?: Maybe<Room>;
  /** fetch data from the table: "user" */
  user: Array<User>;
  /** fetch aggregated fields from the table: "user" */
  user_aggregate: User_Aggregate;
  /** fetch data from the table: "user" using primary key columns */
  user_by_pk?: Maybe<User>;
  /** fetch data from the table: "user_room" */
  user_room: Array<User_Room>;
  /** fetch aggregated fields from the table: "user_room" */
  user_room_aggregate: User_Room_Aggregate;
  /** fetch data from the table: "user_room" using primary key columns */
  user_room_by_pk?: Maybe<User_Room>;
};


export type Query_RootMessageArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Query_RootMessage_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Query_RootMessage_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootRoomArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Query_RootRoom_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Query_RootRoom_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUserArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Query_RootUser_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Query_RootUser_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Query_RootUser_RoomArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Query_RootUser_Room_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Query_RootUser_Room_By_PkArgs = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "room" */
export type Room = {
  __typename?: 'room';
  created_at: Scalars['timestamp']['output'];
  intro: Scalars['String']['output'];
  invite_code: Scalars['String']['output'];
  /** An array relationship */
  messages: Array<Message>;
  /** An aggregate relationship */
  messages_aggregate: Message_Aggregate;
  name: Scalars['String']['output'];
  /** An array relationship */
  user_rooms: Array<User_Room>;
  /** An aggregate relationship */
  user_rooms_aggregate: User_Room_Aggregate;
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "room" */
export type RoomMessagesArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "room" */
export type RoomMessages_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "room" */
export type RoomUser_RoomsArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


/** columns and relationships of "room" */
export type RoomUser_Rooms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};

/** aggregated selection of "room" */
export type Room_Aggregate = {
  __typename?: 'room_aggregate';
  aggregate?: Maybe<Room_Aggregate_Fields>;
  nodes: Array<Room>;
};

/** aggregate fields of "room" */
export type Room_Aggregate_Fields = {
  __typename?: 'room_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Room_Max_Fields>;
  min?: Maybe<Room_Min_Fields>;
};


/** aggregate fields of "room" */
export type Room_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Room_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "room". All fields are combined with a logical 'AND'. */
export type Room_Bool_Exp = {
  _and?: InputMaybe<Array<Room_Bool_Exp>>;
  _not?: InputMaybe<Room_Bool_Exp>;
  _or?: InputMaybe<Array<Room_Bool_Exp>>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  intro?: InputMaybe<String_Comparison_Exp>;
  invite_code?: InputMaybe<String_Comparison_Exp>;
  messages?: InputMaybe<Message_Bool_Exp>;
  messages_aggregate?: InputMaybe<Message_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  user_rooms?: InputMaybe<User_Room_Bool_Exp>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Bool_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "room" */
export enum Room_Constraint {
  /** unique or primary key constraint on columns "invite_code" */
  RoomInviteCodeKey = 'room_invite_code_key',
  /** unique or primary key constraint on columns "name" */
  RoomNameKey = 'room_name_key',
  /** unique or primary key constraint on columns "uuid" */
  RoomPkey = 'room_pkey'
}

/** input type for inserting data into table "room" */
export type Room_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  intro?: InputMaybe<Scalars['String']['input']>;
  invite_code?: InputMaybe<Scalars['String']['input']>;
  messages?: InputMaybe<Message_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  user_rooms?: InputMaybe<User_Room_Arr_Rel_Insert_Input>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Room_Max_Fields = {
  __typename?: 'room_max_fields';
  created_at?: Maybe<Scalars['timestamp']['output']>;
  intro?: Maybe<Scalars['String']['output']>;
  invite_code?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Room_Min_Fields = {
  __typename?: 'room_min_fields';
  created_at?: Maybe<Scalars['timestamp']['output']>;
  intro?: Maybe<Scalars['String']['output']>;
  invite_code?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "room" */
export type Room_Mutation_Response = {
  __typename?: 'room_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Room>;
};

/** input type for inserting object relation for remote table "room" */
export type Room_Obj_Rel_Insert_Input = {
  data: Room_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Room_On_Conflict>;
};

/** on_conflict condition type for table "room" */
export type Room_On_Conflict = {
  constraint: Room_Constraint;
  update_columns?: Array<Room_Update_Column>;
  where?: InputMaybe<Room_Bool_Exp>;
};

/** Ordering options when selecting data from "room". */
export type Room_Order_By = {
  created_at?: InputMaybe<Order_By>;
  intro?: InputMaybe<Order_By>;
  invite_code?: InputMaybe<Order_By>;
  messages_aggregate?: InputMaybe<Message_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: room */
export type Room_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** select columns of table "room" */
export enum Room_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Intro = 'intro',
  /** column name */
  InviteCode = 'invite_code',
  /** column name */
  Name = 'name',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "room" */
export type Room_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  intro?: InputMaybe<Scalars['String']['input']>;
  invite_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "room" */
export type Room_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Room_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Room_Stream_Cursor_Value_Input = {
  created_at?: InputMaybe<Scalars['timestamp']['input']>;
  intro?: InputMaybe<Scalars['String']['input']>;
  invite_code?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "room" */
export enum Room_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Intro = 'intro',
  /** column name */
  InviteCode = 'invite_code',
  /** column name */
  Name = 'name',
  /** column name */
  Uuid = 'uuid'
}

export type Room_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Room_Set_Input>;
  /** filter the rows which have to be updated */
  where: Room_Bool_Exp;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "message" */
  message: Array<Message>;
  /** fetch aggregated fields from the table: "message" */
  message_aggregate: Message_Aggregate;
  /** fetch data from the table: "message" using primary key columns */
  message_by_pk?: Maybe<Message>;
  /** fetch data from the table in a streaming manner: "message" */
  message_stream: Array<Message>;
  /** fetch data from the table: "room" */
  room: Array<Room>;
  /** fetch aggregated fields from the table: "room" */
  room_aggregate: Room_Aggregate;
  /** fetch data from the table: "room" using primary key columns */
  room_by_pk?: Maybe<Room>;
  /** fetch data from the table in a streaming manner: "room" */
  room_stream: Array<Room>;
  /** fetch data from the table: "user" */
  user: Array<User>;
  /** fetch aggregated fields from the table: "user" */
  user_aggregate: User_Aggregate;
  /** fetch data from the table: "user" using primary key columns */
  user_by_pk?: Maybe<User>;
  /** fetch data from the table: "user_room" */
  user_room: Array<User_Room>;
  /** fetch aggregated fields from the table: "user_room" */
  user_room_aggregate: User_Room_Aggregate;
  /** fetch data from the table: "user_room" using primary key columns */
  user_room_by_pk?: Maybe<User_Room>;
  /** fetch data from the table in a streaming manner: "user_room" */
  user_room_stream: Array<User_Room>;
  /** fetch data from the table in a streaming manner: "user" */
  user_stream: Array<User>;
};


export type Subscription_RootMessageArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Subscription_RootMessage_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Subscription_RootMessage_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootMessage_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Message_Stream_Cursor_Input>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


export type Subscription_RootRoomArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Subscription_RootRoom_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Room_Order_By>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Subscription_RootRoom_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootRoom_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Room_Stream_Cursor_Input>>;
  where?: InputMaybe<Room_Bool_Exp>;
};


export type Subscription_RootUserArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Subscription_RootUser_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Order_By>>;
  where?: InputMaybe<User_Bool_Exp>;
};


export type Subscription_RootUser_By_PkArgs = {
  uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_RoomArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Subscription_RootUser_Room_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Subscription_RootUser_Room_By_PkArgs = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};


export type Subscription_RootUser_Room_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Room_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


export type Subscription_RootUser_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<User_Stream_Cursor_Input>>;
  where?: InputMaybe<User_Bool_Exp>;
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']['input']>;
  _gt?: InputMaybe<Scalars['timestamp']['input']>;
  _gte?: InputMaybe<Scalars['timestamp']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamp']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamp']['input']>;
  _lte?: InputMaybe<Scalars['timestamp']['input']>;
  _neq?: InputMaybe<Scalars['timestamp']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']['input']>>;
};

/** columns and relationships of "user" */
export type User = {
  __typename?: 'user';
  /** An array relationship */
  messages: Array<Message>;
  /** An aggregate relationship */
  messages_aggregate: Message_Aggregate;
  password: Scalars['String']['output'];
  /** An array relationship */
  user_rooms: Array<User_Room>;
  /** An aggregate relationship */
  user_rooms_aggregate: User_Room_Aggregate;
  username: Scalars['String']['output'];
  uuid: Scalars['uuid']['output'];
};


/** columns and relationships of "user" */
export type UserMessagesArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserMessages_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Message_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Message_Order_By>>;
  where?: InputMaybe<Message_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_RoomsArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};


/** columns and relationships of "user" */
export type UserUser_Rooms_AggregateArgs = {
  distinct_on?: InputMaybe<Array<User_Room_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<User_Room_Order_By>>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};

/** aggregated selection of "user" */
export type User_Aggregate = {
  __typename?: 'user_aggregate';
  aggregate?: Maybe<User_Aggregate_Fields>;
  nodes: Array<User>;
};

/** aggregate fields of "user" */
export type User_Aggregate_Fields = {
  __typename?: 'user_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Max_Fields>;
  min?: Maybe<User_Min_Fields>;
};


/** aggregate fields of "user" */
export type User_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'. */
export type User_Bool_Exp = {
  _and?: InputMaybe<Array<User_Bool_Exp>>;
  _not?: InputMaybe<User_Bool_Exp>;
  _or?: InputMaybe<Array<User_Bool_Exp>>;
  messages?: InputMaybe<Message_Bool_Exp>;
  messages_aggregate?: InputMaybe<Message_Aggregate_Bool_Exp>;
  password?: InputMaybe<String_Comparison_Exp>;
  user_rooms?: InputMaybe<User_Room_Bool_Exp>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Bool_Exp>;
  username?: InputMaybe<String_Comparison_Exp>;
  uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user" */
export enum User_Constraint {
  /** unique or primary key constraint on columns "uuid" */
  UserPkey = 'user_pkey',
  /** unique or primary key constraint on columns "username" */
  UserUsernameKey = 'user_username_key'
}

/** input type for inserting data into table "user" */
export type User_Insert_Input = {
  messages?: InputMaybe<Message_Arr_Rel_Insert_Input>;
  password?: InputMaybe<Scalars['String']['input']>;
  user_rooms?: InputMaybe<User_Room_Arr_Rel_Insert_Input>;
  username?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Max_Fields = {
  __typename?: 'user_max_fields';
  password?: Maybe<Scalars['String']['output']>;
  username?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type User_Min_Fields = {
  __typename?: 'user_min_fields';
  password?: Maybe<Scalars['String']['output']>;
  username?: Maybe<Scalars['String']['output']>;
  uuid?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "user" */
export type User_Mutation_Response = {
  __typename?: 'user_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User>;
};

/** input type for inserting object relation for remote table "user" */
export type User_Obj_Rel_Insert_Input = {
  data: User_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<User_On_Conflict>;
};

/** on_conflict condition type for table "user" */
export type User_On_Conflict = {
  constraint: User_Constraint;
  update_columns?: Array<User_Update_Column>;
  where?: InputMaybe<User_Bool_Exp>;
};

/** Ordering options when selecting data from "user". */
export type User_Order_By = {
  messages_aggregate?: InputMaybe<Message_Aggregate_Order_By>;
  password?: InputMaybe<Order_By>;
  user_rooms_aggregate?: InputMaybe<User_Room_Aggregate_Order_By>;
  username?: InputMaybe<Order_By>;
  uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user */
export type User_Pk_Columns_Input = {
  uuid: Scalars['uuid']['input'];
};

/** columns and relationships of "user_room" */
export type User_Room = {
  __typename?: 'user_room';
  /** An object relationship */
  room: Room;
  room_uuid: Scalars['uuid']['output'];
  /** An object relationship */
  user: User;
  user_uuid: Scalars['uuid']['output'];
};

/** aggregated selection of "user_room" */
export type User_Room_Aggregate = {
  __typename?: 'user_room_aggregate';
  aggregate?: Maybe<User_Room_Aggregate_Fields>;
  nodes: Array<User_Room>;
};

export type User_Room_Aggregate_Bool_Exp = {
  count?: InputMaybe<User_Room_Aggregate_Bool_Exp_Count>;
};

export type User_Room_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<User_Room_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<User_Room_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_room" */
export type User_Room_Aggregate_Fields = {
  __typename?: 'user_room_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<User_Room_Max_Fields>;
  min?: Maybe<User_Room_Min_Fields>;
};


/** aggregate fields of "user_room" */
export type User_Room_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<User_Room_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "user_room" */
export type User_Room_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<User_Room_Max_Order_By>;
  min?: InputMaybe<User_Room_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_room" */
export type User_Room_Arr_Rel_Insert_Input = {
  data: Array<User_Room_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<User_Room_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_room". All fields are combined with a logical 'AND'. */
export type User_Room_Bool_Exp = {
  _and?: InputMaybe<Array<User_Room_Bool_Exp>>;
  _not?: InputMaybe<User_Room_Bool_Exp>;
  _or?: InputMaybe<Array<User_Room_Bool_Exp>>;
  room?: InputMaybe<Room_Bool_Exp>;
  room_uuid?: InputMaybe<Uuid_Comparison_Exp>;
  user?: InputMaybe<User_Bool_Exp>;
  user_uuid?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_room" */
export enum User_Room_Constraint {
  /** unique or primary key constraint on columns "room_uuid", "user_uuid" */
  UserRoomPkey = 'user_room_pkey'
}

/** input type for inserting data into table "user_room" */
export type User_Room_Insert_Input = {
  room?: InputMaybe<Room_Obj_Rel_Insert_Input>;
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user?: InputMaybe<User_Obj_Rel_Insert_Input>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type User_Room_Max_Fields = {
  __typename?: 'user_room_max_fields';
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "user_room" */
export type User_Room_Max_Order_By = {
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type User_Room_Min_Fields = {
  __typename?: 'user_room_min_fields';
  room_uuid?: Maybe<Scalars['uuid']['output']>;
  user_uuid?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "user_room" */
export type User_Room_Min_Order_By = {
  room_uuid?: InputMaybe<Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "user_room" */
export type User_Room_Mutation_Response = {
  __typename?: 'user_room_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Room>;
};

/** on_conflict condition type for table "user_room" */
export type User_Room_On_Conflict = {
  constraint: User_Room_Constraint;
  update_columns?: Array<User_Room_Update_Column>;
  where?: InputMaybe<User_Room_Bool_Exp>;
};

/** Ordering options when selecting data from "user_room". */
export type User_Room_Order_By = {
  room?: InputMaybe<Room_Order_By>;
  room_uuid?: InputMaybe<Order_By>;
  user?: InputMaybe<User_Order_By>;
  user_uuid?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_room */
export type User_Room_Pk_Columns_Input = {
  room_uuid: Scalars['uuid']['input'];
  user_uuid: Scalars['uuid']['input'];
};

/** select columns of table "user_room" */
export enum User_Room_Select_Column {
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid'
}

/** input type for updating data in table "user_room" */
export type User_Room_Set_Input = {
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user_room" */
export type User_Room_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Room_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Room_Stream_Cursor_Value_Input = {
  room_uuid?: InputMaybe<Scalars['uuid']['input']>;
  user_uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_room" */
export enum User_Room_Update_Column {
  /** column name */
  RoomUuid = 'room_uuid',
  /** column name */
  UserUuid = 'user_uuid'
}

export type User_Room_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Room_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Room_Bool_Exp;
};

/** select columns of table "user" */
export enum User_Select_Column {
  /** column name */
  Password = 'password',
  /** column name */
  Username = 'username',
  /** column name */
  Uuid = 'uuid'
}

/** input type for updating data in table "user" */
export type User_Set_Input = {
  password?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "user" */
export type User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Stream_Cursor_Value_Input = {
  password?: InputMaybe<Scalars['String']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
  uuid?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user" */
export enum User_Update_Column {
  /** column name */
  Password = 'password',
  /** column name */
  Username = 'username',
  /** column name */
  Uuid = 'uuid'
}

export type User_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<User_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Bool_Exp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

export type AddMessageMutationVariables = Exact<{
  user_uuid: Scalars['uuid']['input'];
  room_uuid: Scalars['uuid']['input'];
  content: Scalars['String']['input'];
  reply_to?: InputMaybe<Scalars['uuid']['input']>;
}>;


export type AddMessageMutation = { __typename?: 'mutation_root', insert_message_one?: { __typename?: 'message', uuid: any } | null };

export type GetMessagesByRoomSubscriptionVariables = Exact<{
  room_uuid: Scalars['uuid']['input'];
}>;


export type GetMessagesByRoomSubscription = { __typename?: 'subscription_root', message: Array<{ __typename?: 'message', uuid: any, reply_to?: any | null, content: string, created_at: any, user: { __typename?: 'user', uuid: any, username: string } }> };

export type AddRoomMutationVariables = Exact<{
  name: Scalars['String']['input'];
  intro: Scalars['String']['input'];
  invite_code: Scalars['String']['input'];
}>;


export type AddRoomMutation = { __typename?: 'mutation_root', insert_room_one?: { __typename?: 'room', uuid: any } | null };

export type GetJoinedRoomsQueryVariables = Exact<{
  user_uuid: Scalars['uuid']['input'];
}>;


export type GetJoinedRoomsQuery = { __typename?: 'query_root', user_room: Array<{ __typename?: 'user_room', room: { __typename?: 'room', uuid: any, name: string, intro: string, invite_code: string, created_at: any } }> };

export type GetRoomByInviteCodeQueryVariables = Exact<{
  invite_code: Scalars['String']['input'];
}>;


export type GetRoomByInviteCodeQuery = { __typename?: 'query_root', room: Array<{ __typename?: 'room', uuid: any }> };

export type JoinRoomMutationVariables = Exact<{
  user_uuid: Scalars['uuid']['input'];
  room_uuid: Scalars['uuid']['input'];
}>;


export type JoinRoomMutation = { __typename?: 'mutation_root', insert_user_room_one?: { __typename?: 'user_room', user_uuid: any, room_uuid: any } | null };

export type AddUserMutationVariables = Exact<{
  username: Scalars['String']['input'];
  password: Scalars['String']['input'];
}>;


export type AddUserMutation = { __typename?: 'mutation_root', insert_user_one?: { __typename?: 'user', uuid: any } | null };

export type GetUsersByUsernameQueryVariables = Exact<{
  username: Scalars['String']['input'];
}>;


export type GetUsersByUsernameQuery = { __typename?: 'query_root', user: Array<{ __typename?: 'user', uuid: any, password: string }> };

export type UpdateUserPasswordMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
  password: Scalars['String']['input'];
}>;


export type UpdateUserPasswordMutation = { __typename?: 'mutation_root', update_user_by_pk?: { __typename?: 'user', uuid: any, password: string } | null };

export type DeleteUserMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
}>;


export type DeleteUserMutation = { __typename?: 'mutation_root', delete_user_by_pk?: { __typename?: 'user', uuid: any, username: string } | null };

export type DeleteUserRoomMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
}>;


export type DeleteUserRoomMutation = { __typename?: 'mutation_root', delete_user_room?: { __typename?: 'user_room_mutation_response', affected_rows: number } | null };

export type DeleteUserMessageMutationVariables = Exact<{
  uuid: Scalars['uuid']['input'];
}>;


export type DeleteUserMessageMutation = { __typename?: 'mutation_root', delete_message?: { __typename?: 'message_mutation_response', affected_rows: number } | null };


export const AddMessageDocument = gql`
    mutation addMessage($user_uuid: uuid!, $room_uuid: uuid!, $content: String!, $reply_to: uuid) {
  insert_message_one(
    object: {user_uuid: $user_uuid, room_uuid: $room_uuid, content: $content, reply_to: $reply_to}
  ) {
    uuid
  }
}
    `;
export type AddMessageMutationFn = Apollo.MutationFunction<AddMessageMutation, AddMessageMutationVariables>;

/**
 * __useAddMessageMutation__
 *
 * To run a mutation, you first call `useAddMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addMessageMutation, { data, loading, error }] = useAddMessageMutation({
 *   variables: {
 *      user_uuid: // value for 'user_uuid'
 *      room_uuid: // value for 'room_uuid'
 *      content: // value for 'content'
 *      reply_to: // value for 'reply_to'
 *   },
 * });
 */
export function useAddMessageMutation(baseOptions?: Apollo.MutationHookOptions<AddMessageMutation, AddMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddMessageMutation, AddMessageMutationVariables>(AddMessageDocument, options);
      }
export type AddMessageMutationHookResult = ReturnType<typeof useAddMessageMutation>;
export type AddMessageMutationResult = Apollo.MutationResult<AddMessageMutation>;
export type AddMessageMutationOptions = Apollo.BaseMutationOptions<AddMessageMutation, AddMessageMutationVariables>;
export const GetMessagesByRoomDocument = gql`
    subscription getMessagesByRoom($room_uuid: uuid!) {
  message(where: {room_uuid: {_eq: $room_uuid}}) {
    uuid
    user {
      uuid
      username
    }
    reply_to
    content
    created_at
  }
}
    `;

/**
 * __useGetMessagesByRoomSubscription__
 *
 * To run a query within a React component, call `useGetMessagesByRoomSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetMessagesByRoomSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMessagesByRoomSubscription({
 *   variables: {
 *      room_uuid: // value for 'room_uuid'
 *   },
 * });
 */
export function useGetMessagesByRoomSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetMessagesByRoomSubscription, GetMessagesByRoomSubscriptionVariables> & ({ variables: GetMessagesByRoomSubscriptionVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetMessagesByRoomSubscription, GetMessagesByRoomSubscriptionVariables>(GetMessagesByRoomDocument, options);
      }
export type GetMessagesByRoomSubscriptionHookResult = ReturnType<typeof useGetMessagesByRoomSubscription>;
export type GetMessagesByRoomSubscriptionResult = Apollo.SubscriptionResult<GetMessagesByRoomSubscription>;
export const AddRoomDocument = gql`
    mutation addRoom($name: String!, $intro: String!, $invite_code: String!) {
  insert_room_one(object: {name: $name, intro: $intro, invite_code: $invite_code}) {
    uuid
  }
}
    `;
export type AddRoomMutationFn = Apollo.MutationFunction<AddRoomMutation, AddRoomMutationVariables>;

/**
 * __useAddRoomMutation__
 *
 * To run a mutation, you first call `useAddRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addRoomMutation, { data, loading, error }] = useAddRoomMutation({
 *   variables: {
 *      name: // value for 'name'
 *      intro: // value for 'intro'
 *      invite_code: // value for 'invite_code'
 *   },
 * });
 */
export function useAddRoomMutation(baseOptions?: Apollo.MutationHookOptions<AddRoomMutation, AddRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddRoomMutation, AddRoomMutationVariables>(AddRoomDocument, options);
      }
export type AddRoomMutationHookResult = ReturnType<typeof useAddRoomMutation>;
export type AddRoomMutationResult = Apollo.MutationResult<AddRoomMutation>;
export type AddRoomMutationOptions = Apollo.BaseMutationOptions<AddRoomMutation, AddRoomMutationVariables>;
export const GetJoinedRoomsDocument = gql`
    query getJoinedRooms($user_uuid: uuid!) {
  user_room(where: {user_uuid: {_eq: $user_uuid}}) {
    room {
      uuid
      name
      intro
      invite_code
      created_at
    }
  }
}
    `;

/**
 * __useGetJoinedRoomsQuery__
 *
 * To run a query within a React component, call `useGetJoinedRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetJoinedRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetJoinedRoomsQuery({
 *   variables: {
 *      user_uuid: // value for 'user_uuid'
 *   },
 * });
 */
export function useGetJoinedRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetJoinedRoomsQuery, GetJoinedRoomsQueryVariables> & ({ variables: GetJoinedRoomsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetJoinedRoomsQuery, GetJoinedRoomsQueryVariables>(GetJoinedRoomsDocument, options);
      }
export function useGetJoinedRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetJoinedRoomsQuery, GetJoinedRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetJoinedRoomsQuery, GetJoinedRoomsQueryVariables>(GetJoinedRoomsDocument, options);
        }
export function useGetJoinedRoomsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetJoinedRoomsQuery, GetJoinedRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetJoinedRoomsQuery, GetJoinedRoomsQueryVariables>(GetJoinedRoomsDocument, options);
        }
export type GetJoinedRoomsQueryHookResult = ReturnType<typeof useGetJoinedRoomsQuery>;
export type GetJoinedRoomsLazyQueryHookResult = ReturnType<typeof useGetJoinedRoomsLazyQuery>;
export type GetJoinedRoomsSuspenseQueryHookResult = ReturnType<typeof useGetJoinedRoomsSuspenseQuery>;
export type GetJoinedRoomsQueryResult = Apollo.QueryResult<GetJoinedRoomsQuery, GetJoinedRoomsQueryVariables>;
export const GetRoomByInviteCodeDocument = gql`
    query getRoomByInviteCode($invite_code: String!) {
  room(where: {invite_code: {_eq: $invite_code}}) {
    uuid
  }
}
    `;

/**
 * __useGetRoomByInviteCodeQuery__
 *
 * To run a query within a React component, call `useGetRoomByInviteCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomByInviteCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomByInviteCodeQuery({
 *   variables: {
 *      invite_code: // value for 'invite_code'
 *   },
 * });
 */
export function useGetRoomByInviteCodeQuery(baseOptions: Apollo.QueryHookOptions<GetRoomByInviteCodeQuery, GetRoomByInviteCodeQueryVariables> & ({ variables: GetRoomByInviteCodeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomByInviteCodeQuery, GetRoomByInviteCodeQueryVariables>(GetRoomByInviteCodeDocument, options);
      }
export function useGetRoomByInviteCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomByInviteCodeQuery, GetRoomByInviteCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomByInviteCodeQuery, GetRoomByInviteCodeQueryVariables>(GetRoomByInviteCodeDocument, options);
        }
export function useGetRoomByInviteCodeSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetRoomByInviteCodeQuery, GetRoomByInviteCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetRoomByInviteCodeQuery, GetRoomByInviteCodeQueryVariables>(GetRoomByInviteCodeDocument, options);
        }
export type GetRoomByInviteCodeQueryHookResult = ReturnType<typeof useGetRoomByInviteCodeQuery>;
export type GetRoomByInviteCodeLazyQueryHookResult = ReturnType<typeof useGetRoomByInviteCodeLazyQuery>;
export type GetRoomByInviteCodeSuspenseQueryHookResult = ReturnType<typeof useGetRoomByInviteCodeSuspenseQuery>;
export type GetRoomByInviteCodeQueryResult = Apollo.QueryResult<GetRoomByInviteCodeQuery, GetRoomByInviteCodeQueryVariables>;
export const JoinRoomDocument = gql`
    mutation joinRoom($user_uuid: uuid!, $room_uuid: uuid!) {
  insert_user_room_one(object: {user_uuid: $user_uuid, room_uuid: $room_uuid}) {
    user_uuid
    room_uuid
  }
}
    `;
export type JoinRoomMutationFn = Apollo.MutationFunction<JoinRoomMutation, JoinRoomMutationVariables>;

/**
 * __useJoinRoomMutation__
 *
 * To run a mutation, you first call `useJoinRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinRoomMutation, { data, loading, error }] = useJoinRoomMutation({
 *   variables: {
 *      user_uuid: // value for 'user_uuid'
 *      room_uuid: // value for 'room_uuid'
 *   },
 * });
 */
export function useJoinRoomMutation(baseOptions?: Apollo.MutationHookOptions<JoinRoomMutation, JoinRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<JoinRoomMutation, JoinRoomMutationVariables>(JoinRoomDocument, options);
      }
export type JoinRoomMutationHookResult = ReturnType<typeof useJoinRoomMutation>;
export type JoinRoomMutationResult = Apollo.MutationResult<JoinRoomMutation>;
export type JoinRoomMutationOptions = Apollo.BaseMutationOptions<JoinRoomMutation, JoinRoomMutationVariables>;
export const AddUserDocument = gql`
    mutation addUser($username: String!, $password: String!) {
  insert_user_one(object: {username: $username, password: $password}) {
    uuid
  }
}
    `;
export type AddUserMutationFn = Apollo.MutationFunction<AddUserMutation, AddUserMutationVariables>;

/**
 * __useAddUserMutation__
 *
 * To run a mutation, you first call `useAddUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addUserMutation, { data, loading, error }] = useAddUserMutation({
 *   variables: {
 *      username: // value for 'username'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useAddUserMutation(baseOptions?: Apollo.MutationHookOptions<AddUserMutation, AddUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddUserMutation, AddUserMutationVariables>(AddUserDocument, options);
      }
export type AddUserMutationHookResult = ReturnType<typeof useAddUserMutation>;
export type AddUserMutationResult = Apollo.MutationResult<AddUserMutation>;
export type AddUserMutationOptions = Apollo.BaseMutationOptions<AddUserMutation, AddUserMutationVariables>;
export const GetUsersByUsernameDocument = gql`
    query getUsersByUsername($username: String!) {
  user(where: {username: {_eq: $username}}) {
    uuid
    password
  }
}
    `;

/**
 * __useGetUsersByUsernameQuery__
 *
 * To run a query within a React component, call `useGetUsersByUsernameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUsersByUsernameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUsersByUsernameQuery({
 *   variables: {
 *      username: // value for 'username'
 *   },
 * });
 */
export function useGetUsersByUsernameQuery(baseOptions: Apollo.QueryHookOptions<GetUsersByUsernameQuery, GetUsersByUsernameQueryVariables> & ({ variables: GetUsersByUsernameQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUsersByUsernameQuery, GetUsersByUsernameQueryVariables>(GetUsersByUsernameDocument, options);
      }
export function useGetUsersByUsernameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUsersByUsernameQuery, GetUsersByUsernameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUsersByUsernameQuery, GetUsersByUsernameQueryVariables>(GetUsersByUsernameDocument, options);
        }
export function useGetUsersByUsernameSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<GetUsersByUsernameQuery, GetUsersByUsernameQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetUsersByUsernameQuery, GetUsersByUsernameQueryVariables>(GetUsersByUsernameDocument, options);
        }
export type GetUsersByUsernameQueryHookResult = ReturnType<typeof useGetUsersByUsernameQuery>;
export type GetUsersByUsernameLazyQueryHookResult = ReturnType<typeof useGetUsersByUsernameLazyQuery>;
export type GetUsersByUsernameSuspenseQueryHookResult = ReturnType<typeof useGetUsersByUsernameSuspenseQuery>;
export type GetUsersByUsernameQueryResult = Apollo.QueryResult<GetUsersByUsernameQuery, GetUsersByUsernameQueryVariables>;
export const UpdateUserPasswordDocument = gql`
    mutation updateUserPassword($uuid: uuid!, $password: String!) {
  update_user_by_pk(pk_columns: {uuid: $uuid}, _set: {password: $password}) {
    uuid
    password
  }
}
    `;
export type UpdateUserPasswordMutationFn = Apollo.MutationFunction<UpdateUserPasswordMutation, UpdateUserPasswordMutationVariables>;

/**
 * __useUpdateUserPasswordMutation__
 *
 * To run a mutation, you first call `useUpdateUserPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUserPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUserPasswordMutation, { data, loading, error }] = useUpdateUserPasswordMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useUpdateUserPasswordMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUserPasswordMutation, UpdateUserPasswordMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUserPasswordMutation, UpdateUserPasswordMutationVariables>(UpdateUserPasswordDocument, options);
      }
export type UpdateUserPasswordMutationHookResult = ReturnType<typeof useUpdateUserPasswordMutation>;
export type UpdateUserPasswordMutationResult = Apollo.MutationResult<UpdateUserPasswordMutation>;
export type UpdateUserPasswordMutationOptions = Apollo.BaseMutationOptions<UpdateUserPasswordMutation, UpdateUserPasswordMutationVariables>;
export const DeleteUserDocument = gql`
    mutation deleteUser($uuid: uuid!) {
  delete_user_by_pk(uuid: $uuid) {
    uuid
    username
  }
}
    `;
export type DeleteUserMutationFn = Apollo.MutationFunction<DeleteUserMutation, DeleteUserMutationVariables>;

/**
 * __useDeleteUserMutation__
 *
 * To run a mutation, you first call `useDeleteUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMutation, { data, loading, error }] = useDeleteUserMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useDeleteUserMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMutation, DeleteUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserMutation, DeleteUserMutationVariables>(DeleteUserDocument, options);
      }
export type DeleteUserMutationHookResult = ReturnType<typeof useDeleteUserMutation>;
export type DeleteUserMutationResult = Apollo.MutationResult<DeleteUserMutation>;
export type DeleteUserMutationOptions = Apollo.BaseMutationOptions<DeleteUserMutation, DeleteUserMutationVariables>;
export const DeleteUserRoomDocument = gql`
    mutation deleteUserRoom($uuid: uuid!) {
  delete_user_room(where: {user_uuid: {_eq: $uuid}}) {
    affected_rows
  }
}
    `;
export type DeleteUserRoomMutationFn = Apollo.MutationFunction<DeleteUserRoomMutation, DeleteUserRoomMutationVariables>;

/**
 * __useDeleteUserRoomMutation__
 *
 * To run a mutation, you first call `useDeleteUserRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserRoomMutation, { data, loading, error }] = useDeleteUserRoomMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useDeleteUserRoomMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserRoomMutation, DeleteUserRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserRoomMutation, DeleteUserRoomMutationVariables>(DeleteUserRoomDocument, options);
      }
export type DeleteUserRoomMutationHookResult = ReturnType<typeof useDeleteUserRoomMutation>;
export type DeleteUserRoomMutationResult = Apollo.MutationResult<DeleteUserRoomMutation>;
export type DeleteUserRoomMutationOptions = Apollo.BaseMutationOptions<DeleteUserRoomMutation, DeleteUserRoomMutationVariables>;
export const DeleteUserMessageDocument = gql`
    mutation deleteUserMessage($uuid: uuid!) {
  delete_message(where: {user_uuid: {_eq: $uuid}}) {
    affected_rows
  }
}
    `;
export type DeleteUserMessageMutationFn = Apollo.MutationFunction<DeleteUserMessageMutation, DeleteUserMessageMutationVariables>;

/**
 * __useDeleteUserMessageMutation__
 *
 * To run a mutation, you first call `useDeleteUserMessageMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteUserMessageMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteUserMessageMutation, { data, loading, error }] = useDeleteUserMessageMutation({
 *   variables: {
 *      uuid: // value for 'uuid'
 *   },
 * });
 */
export function useDeleteUserMessageMutation(baseOptions?: Apollo.MutationHookOptions<DeleteUserMessageMutation, DeleteUserMessageMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteUserMessageMutation, DeleteUserMessageMutationVariables>(DeleteUserMessageDocument, options);
      }
export type DeleteUserMessageMutationHookResult = ReturnType<typeof useDeleteUserMessageMutation>;
export type DeleteUserMessageMutationResult = Apollo.MutationResult<DeleteUserMessageMutation>;
export type DeleteUserMessageMutationOptions = Apollo.BaseMutationOptions<DeleteUserMessageMutation, DeleteUserMessageMutationVariables>;


import { useEffect, useRef, useState } from "react";
import { Button, Input, message, Spin } from "antd";
import { user } from "./getUser";
import * as graphql from "./graphql";
import { Bubble, Card, Container, Scroll, Text } from "./Components";

interface ChatBoxProps {
  user: user | null;
  room: graphql.GetJoinedRoomsQuery["user_room"][0]["room"] | undefined;
  handleClose: () => void;
}

const ChatBox: React.FC<ChatBoxProps> = ({ user, room, handleClose }) => {
  const [text, setText] = useState<string>("");
  const [loading, setLoading] = useState<boolean>(false);

  const { data, error } = graphql.useGetMessagesByRoomSubscription({
    skip: !room,
    variables: {
      room_uuid: room?.uuid,
    },
  });
  useEffect(() => {
    if (error) {
      console.error(error);
      message.error("获取消息失败！");
    }
  }, [error]);

  const [addMessageMutation] = graphql.useAddMessageMutation();

  const handleSend = async () => {
    setLoading(true);
    if (!text) {
      message.error("消息不能为空！");
      return setLoading(false);
    }
    const result = await addMessageMutation({
      variables: {
        user_uuid: user?.uuid,
        room_uuid: room?.uuid,
        content: text,
      },
    });
    if (result.errors) {
      console.error(result.errors);
      message.error("发送消息失败！");
    }
    setText("");
    setLoading(false);
  };

  const Close = () => (
    <Button
      type="link"
      style={{
        width: "40px",
        height: "40px",
        fontSize: "12px",
        position: "absolute",
        right: 0,
        top: 0,
      }}
      className="need-interaction"
      onClick={handleClose}
    >
      ❌
    </Button>
  );

  if (!user || !room) {
    return null;
  }
  return (
    <Card style={{ width: "300px", height: "500px" }}>
      <Close />
      <Container style={{ margin: "6px" }}>
        <Text>
          <strong>{room.name}</strong>
        </Text>
        <Text size="small" style={{ marginTop: "6px", marginBottom: "6px" }}>
          {room.intro}
        </Text>
      </Container>
      <MessageFeed user={user} messages={data?.message} />
      <div
        className="need-interaction"
        style={{
          marginTop: "12px",
          display: "flex",
          width: "100%",
        }}
      >
        <Input
          placeholder="输入消息"
          value={text}
          onChange={(e) => setText(e.target.value)}
          style={{ fontSize: "18px", height: "40px" }}
        />
        <Button
          style={{ height: "40px", fontSize: "18px", marginLeft: "12px" }}
          onClick={handleSend}
          type="primary"
          loading={loading}
        >
          <strong>发送</strong>
        </Button>
      </div>
    </Card>
  );
};

interface MessageFeedProps {
  user: user;
  messages: graphql.GetMessagesByRoomSubscription["message"] | undefined;
}

const MessageFeed: React.FC<MessageFeedProps> = ({ user, messages }) => {
  const bottomRef = useRef<HTMLDivElement | null>(null);
  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  return (
    <Scroll>
      {messages ? (
        messages.map((message, index) => (
          <div
            ref={index === messages.length - 1 ? bottomRef : null}
            key={index}
          >
            <MessageBubble user={user} message={message} />
          </div>
        ))
      ) : (
        <Container style={{ height: "100%" }}>
          <Spin size="large" />
        </Container>
      )}
    </Scroll>
  );
};

interface MessageBubbleProps {
  user: user;
  message: graphql.GetMessagesByRoomSubscription["message"][0];
}

const MessageBubble: React.FC<MessageBubbleProps> = ({ user, message }) => {
  const isSelf = user.uuid === message.user.uuid;
  const dateUTC = new Date(message.created_at);
  const date = new Date(
    dateUTC.getTime() - dateUTC.getTimezoneOffset() * 60000
  );
  return (
    <div
      style={{
        margin: "6px 0",
        display: "flex",
        flexDirection: "column",
        flexWrap: "nowrap",
        alignItems: isSelf ? "flex-end" : "flex-start",
      }}
    >
      <div style={{ marginLeft: "12px", marginRight: "12px" }}>
        <Text size="small">{message.user.username}</Text>
        <Text size="small" style={{ marginLeft: "6px" }}>
          {date.toLocaleString("zh-CN")}
        </Text>
      </div>
      <Bubble
        style={{
          minHeight: "24px",
          width: "fit-content",
          maxWidth: "80%",
          backgroundColor: isSelf
            ? "rgba(4, 190, 2, 0.25)"
            : "rgba(255, 255, 255, 0.25)",
        }}
      >
        <Text style={{ wordBreak: "break-all" }}>{message.content}</Text>
      </Bubble>
    </div>
  );
};

export default ChatBox;


import React, { Suspense, useEffect, useState } from "react";
import { createRoot } from "react-dom/client";
import { createHashRouter, RouterProvider } from "react-router-dom";
import axios from "axios";
import { ApolloProvider } from "@apollo/client";
import { message } from "antd";
import Draggable from "react-draggable";
import "./index.css";
import { client } from "./apollo";
import * as graphql from "./graphql";
import Dice from "./Dice";
import Timer from "./Timer";
import getUser from "./getUser";

const MainPanel = React.lazy(() => import("./MainPanel"));
const LoginPage = React.lazy(() => import("./LoginPage"));
const ChatBox = React.lazy(() => import("./ChatBox"));
const FileShare = React.lazy(() => import("./FileShare"));
const RequestPasswordResetPage = React.lazy(() => import("./RequestPasswordResetPage"));
const ResetPasswordPage = React.lazy( () => import("./ResetPasswordPage"));

axios.defaults.baseURL = process.env.REACT_APP_BACKEND_URL!;
axios.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers.Authorization = "Bearer " + token;
  }
  return config;
});

interface MyDraggableProps {
  oid: string;
  currentDrag: string;
  setCurrentDrag: (oid: string) => void;
  style?: React.CSSProperties;
}

const MyDraggable: React.FC<React.PropsWithChildren<MyDraggableProps>> = ({
  oid,
  currentDrag,
  setCurrentDrag,
  children,
  style,
}) => {
  return (
    <Draggable
      bounds="body"
      grid={[4, 4]}
      onStart={() => setCurrentDrag(oid)}
      cancel=".need-interaction"
    >
      <div
        style={{
          ...style,
          height: "fit-content",
          width: "fit-content",
          zIndex: currentDrag === oid ? 99 : 0,
        }}
      >
        {children}
      </div>
    </Draggable>
  );
};

const App = () => {
  const user = getUser();
  const [chatBoxList, setChatBoxList] = useState<number[]>([]);
  const [fileShareList, setFileShareList] = useState<number[]>([]);
  const [currentDrag, setCurrentDrag] = useState<string>("");

  const draggableProps = {
    currentDrag,
    setCurrentDrag,
  };

  const addChatBox = (idx: number) => {
    if (!chatBoxList.includes(idx)) {
      setChatBoxList([...chatBoxList, idx]);
    }
  };
  const addFileShare = (idx: number) => {
    if (!fileShareList.includes(idx)) {
      setFileShareList([...fileShareList, idx]);
    }
  };
  const removeChatBox = (idx: number) => {
    setChatBoxList(chatBoxList.filter((id) => id !== idx));
  };
  const removeFileShare = (idx: number) => {
    setFileShareList(fileShareList.filter((id) => id !== idx));
  };

  const { data, error, refetch } = graphql.useGetJoinedRoomsQuery({
    skip: !user,
    variables: {
      user_uuid: user?.uuid,
    },
  });
  useEffect(() => {
    if (error) {
      console.error(error);
      message.error("获取房间列表失败！");
    }
  }, [error]);

  return (
    <div style={{ display: "inline-flex", flexWrap: "wrap" }}>
      <Suspense fallback={null}>
        <MainPanel
          user={user}
          rooms={data?.user_room}
          refetchRooms={refetch}
          addChatBox={addChatBox}
          addFileShare={addFileShare}
        />
      </Suspense>
      <MyDraggable key="dice" oid="dice" {...draggableProps}>
        <Dice />
      </MyDraggable>
      <MyDraggable key="timer" oid="timer" {...draggableProps}>
        <Timer />
      </MyDraggable>
      {chatBoxList.map((idx) => (
        <MyDraggable
          key={`chat-${idx}`}
          oid={`chat-${idx}`}
          style={{ position: "absolute", right: 0 }}
          {...draggableProps}
        >
          <Suspense fallback={null}>
            <ChatBox
              user={user}
              room={data?.user_room[idx].room}
              handleClose={() => removeChatBox(idx)}
            />
          </Suspense>
        </MyDraggable>
      ))}
      {fileShareList.map((idx) => (
        <MyDraggable
          key={`file-${idx}`}
          oid={`file-${idx}`}
          style={{ position: "absolute", right: 0 }}
          {...draggableProps}
        >
          <Suspense fallback={null}>
            <FileShare
              room={data?.user_room[idx].room}
              handleClose={() => removeFileShare(idx)}
            />
          </Suspense>
        </MyDraggable>
      ))}
    </div>
  );
};

const domNode = document.getElementById("root");
const root = createRoot(domNode!);
const router = createHashRouter([
  { path: "/login", element: <LoginPage /> },
  { path: "*", element: <App /> },
  { path: "/user/change-password/request", element: <RequestPasswordResetPage /> },
  { path: "/user/change-password/reset", element: <ResetPasswordPage /> },
]);
root.render(
  <React.StrictMode>
    <Suspense fallback={null}>
      <ApolloProvider client={client}>
        <RouterProvider router={router} />
      </ApolloProvider>
    </Suspense>
  </React.StrictMode>
);


//import md5 from "md5";
import axios, { AxiosError } from "axios";
import { useNavigate } from "react-router-dom";
import { message, Typography } from "antd";
import {
  LoginFormPage,
  ProFormCheckbox,
  ProFormText,
} from "@ant-design/pro-components";
import { UserOutlined, LockOutlined } from "@ant-design/icons";


const { Link } = Typography;

const LoginPage: React.FC = () => {
  const navigate = useNavigate();

  const handleSubmit = async (values: any) => {
    try {
      const response = await axios.post(`${process.env.REACT_APP_BACKEND_URL}/user/login`, values, {
        headers: { 
          "Content-Type": "application/json", 
        },
      });
      const { token } = response.data;
      localStorage.setItem("token", token);
      localStorage.setItem("username", values.username);
      message.success("登录成功！");
      return navigate(-1);
    } catch (error) {
      const err = error as AxiosError;
      if (
        values.autoRegister &&
        (err.response?.data as string).includes("User does not exist")
      ) {
        message.info("未找到用户，正在创建新用户");
        try {
          const response = await axios.post(`${process.env.REACT_APP_BACKEND_URL}/user/register`, values,{
            headers:{"Content-Type": "application/json",}
          });
          const { token } = response.data;
          localStorage.setItem("token", token);
          localStorage.setItem("username", values.username);
          message.success("注册成功！");
          return navigate(-1);
        } catch (error) {
          console.error(error);
          message.error("注册失败！");
        }
      }
      console.error(error);
      message.error("登录失败！");
    }
  };

  const handleForgetPassword = () => {
    navigate("/user/change-password/request");
  };

  return (
    <LoginFormPage
      style={{ height: "100vh" }}
      backgroundVideoUrl="https://gw.alipayobjects.com/v/huamei_gcee1x/afts/video/jXRBRK_VAwoAAAAAAAAAAAAAK4eUAQBr"
      logo="https://eesast.com/android-chrome-192x192.png"
      title="登录账户"
      subTitle="科协暑培(网站部分)学习型工程"
      submitter={{ searchConfig: { submitText: "登录 / 注册" } }}
      onFinish={handleSubmit}
    >
      <ProFormText
        name="username"
        fieldProps={{
          size: "large",
          prefix: <UserOutlined />,
        }}
        placeholder="用户名"
        rules={[{ required: true, message: "请输入用户名！" }]}
        allowClear
      />
      <ProFormText.Password
        name="password"
        fieldProps={{
          size: "large",
          prefix: <LockOutlined />,
        }}
        placeholder="密码"
        rules={[{ required: true, message: "请输入密码！" }]}
        allowClear
      />
      <div style={{ marginBlockEnd: 24 }}>
        <ProFormCheckbox noStyle name="autoRegister" initialValue={true}>
          自动创建新用户
        </ProFormCheckbox>
        <Link style={{ float: "right" }} onClick={handleForgetPassword}>
          忘记密码
        </Link>
      </div>
    </LoginFormPage>
  );
};

export default LoginPage;


import { useEffect, useRef, useState } from "react";
import { Button, Card, Container, fontFamilies, Text } from "./Components";
import { Input } from "antd";

interface TimerProps {
  setTime: (time: number) => void;
  setStart: (start: boolean) => void;
}

const Countdown: React.FC<TimerProps> = ({
  setTime,
  setStart: setCountdownStart,
}) => {
  const [countdownTime, setCountdownTime] = useState(0);

  const handleReset = () => {
    setCountdownStart(false);
    setTime(countdownTime);
  };

  const handleClear = () => {
    setCountdownStart(false);
    setTime(0);
  };

  return (
    <Container style={{ marginTop: "24px" }}>
      <div>
        <Text>倒计时</Text>
        <Input
          type="number"
          value={countdownTime}
          onChange={(e) => setCountdownTime(parseInt(e.target.value))}
          style={{
            marginLeft: "12px",
            marginRight: "12px",
            height: "28px",
            width: "80px",
            fontSize: "18px",
          }}
          className="need-interaction"
        />
        <Text>秒</Text>
      </div>
      <div style={{ marginTop: "24px" }}>
        <Button style={{ width: "100px" }} onClick={handleReset}>
          预备
        </Button>
        <Button
          style={{ width: "100px", marginLeft: "12px" }}
          onClick={() => setCountdownStart(true)}
        >
          开始
        </Button>
      </div>
      <div style={{ marginTop: "12px" }}>
        <Button
          style={{ width: "100px" }}
          onClick={() => setCountdownStart(false)}
        >
          暂停
        </Button>
        <Button
          style={{ width: "100px", marginLeft: "12px" }}
          onClick={handleClear}
        >
          清零
        </Button>
      </div>
    </Container>
  );
};

const Stopwatch: React.FC<TimerProps> = ({
  setTime,
  setStart: setStopwatchStart,
}) => {
  const handleReset = () => {
    setStopwatchStart(false);
    setTime(0);
  };

  return (
    <div style={{ marginTop: "24px" }}>
      <Button style={{ width: "72px" }} onClick={() => setStopwatchStart(true)}>
        开始
      </Button>
      <Button
        style={{ width: "72px", marginLeft: "12px" }}
        onClick={() => setStopwatchStart(false)}
      >
        暂停
      </Button>
      <Button
        style={{ width: "72px", marginLeft: "12px" }}
        onClick={handleReset}
      >
        清零
      </Button>
    </div>
  );
};

const Timer: React.FC = () => {
  const [time, setTime] = useState(0);
  const timer = useRef<null | NodeJS.Timeout>(null);
  const [mode, setMode] = useState<"countdown" | "stopwatch">("countdown");
  const [countdownStart, setCountdownStart] = useState(false);
  const [stopwatchStart, setStopwatchStart] = useState(false);

  useEffect(() => {
    if (timer.current) {
      clearInterval(timer.current);
    }
  }, []);

  useEffect(() => {
    if (countdownStart) {
      timer.current = setInterval(() => setTime((time) => time - 1), 1000);
    } else {
      timer.current && clearInterval(timer.current);
    }
  }, [countdownStart]);

  useEffect(() => {
    if (time <= 0) {
      setCountdownStart(false);
      setTime(0);
    }
  }, [time]);

  useEffect(() => {
    if (stopwatchStart) {
      timer.current = setInterval(() => setTime((time) => time + 1), 1000);
    } else {
      timer.current && clearInterval(timer.current);
    }
  }, [stopwatchStart]);

  return (
    <Card
      style={{
        width: "250px",
        height: mode === "countdown" ? "320px" : "215px",
      }}
    >
      <Text
        size="extra"
        style={{ fontFamily: fontFamilies.join(","), lineHeight: 1 }}
      >
        <strong>
          {Math.floor(time / 60)}:{time % 60 < 10 ? "0" : ""}{time % 60}
        </strong>
      </Text>
      <div style={{ marginTop: "12px" }}>
        <Button style={{ width: "100px" }} onClick={() => setMode("countdown")}>
          <strong>倒计时</strong>
        </Button>
        <Button
          style={{ width: "100px", marginLeft: "12px" }}
          onClick={() => setMode("stopwatch")}
        >
          <strong>计时器</strong>
        </Button>
      </div>
      {mode === "countdown" ? (
        <Countdown setTime={setTime} setStart={setCountdownStart} />
      ) : (
        <Stopwatch setTime={setTime} setStart={setStopwatchStart} />
      )}
    </Card>
  );
};

export default Timer;


import { useState } from "react";
import { Button, Card, fontFamilies, Text } from "./Components";

const Dice: React.FC = () => {
  const [value, setValue] = useState<number>(0);

  const handleRoll = () => {
    setValue(Math.floor(Math.random() * 6) + 1);
  };

  return (
    <Card style={{ width: "150px", height: "150px" }}>
      <Text
        size="extra"
        style={{ fontFamily: fontFamilies.join(","), lineHeight: 1 }}
      >
        <strong>{value}</strong>
      </Text>
      <Button
        style={{ marginTop: "12px", width: "120px" }}
        onClick={handleRoll}
      >
        <strong>摇骰子🎲</strong>
      </Button>
    </Card>
  );
};

export default Dice;


import React from 'react';
import { Form, Input, Button, message } from 'antd';
import axios from 'axios';

const ResetPasswordPage: React.FC = () => {
  const onFinish = async (values: { token: any; password: any; }) => {
    try {
      await axios.post(`${process.env.REACT_APP_BACKEND_URL}/user/change-password/action`, 
        {
            token: values.token,
            newPassword: values.password
        },
        {headers: { "Content-Type": "application/json" },}
    );
      message.success("密码重置成功！");
    } catch (error) {
        console.log(values.token);
        console.log(values.password);
      console.error(error);
      message.error("重置密码失败，请重试！");
    }
  };

  return (
    <Form onFinish={onFinish}>
      <Form.Item
        name="password"
        rules={[{ required: true, message: '请输入新密码！' }]}
      >
        <Input.Password placeholder="新密码" />
        </Form.Item>

    <Form.Item
      name="token"
      rules={[{ required: true, message: '请输入token!' }]}
    >
      <Input placeholder="token" />
    </Form.Item>
      
      <Form.Item>
        <Button type="primary" htmlType="submit">
          重置密码
        </Button>
      </Form.Item>
    </Form>
  );
};

export default ResetPasswordPage;


import { Button as AntdButton, Typography } from "antd";

const { Text: AntdText, Link: AntdLink } = Typography;

export const Container: React.FC<
  React.PropsWithChildren<{ style?: React.CSSProperties }>
> = ({ children, style }) => {
  return (
    <div
      style={{
        ...style,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
      }}
    >
      {children}
    </div>
  );
};

export const Card: React.FC<
  React.PropsWithChildren<{ style?: React.CSSProperties }>
> = ({ children, style }) => {
  return (
    <Container
      style={{
        ...style,
        padding: "12px",
        margin: "12px",
        borderRadius: "8px",
        backgroundColor: "rgba(255, 255, 255, 0.25)",
        boxShadow: "0 0 18px rgba(0, 0, 0, 0.25)",
        backdropFilter: "blur(12px)",
        WebkitBackdropFilter: "blur(12px)",
      }}
    >
      {children}
    </Container>
  );
};

export const Bubble: React.FC<
  React.PropsWithChildren<{ style?: React.CSSProperties }>
> = ({ children, style }) => {
  return (
    <div
      style={{
        ...style,
        padding: "6px",
        margin: "6px",
        borderRadius: "8px",
        boxShadow: "0 0 6px rgba(0, 0, 0, 0.25)",
        backdropFilter: "blur(6px)",
        WebkitBackdropFilter: "blur(6px)",
      }}
    >
      {children}
    </div>
  );
};

export const fontFamilies = [
  "Times New Roman",
  "Times",
  "Nimbus Roman No9 L",
  "Liberation Serif",
  "FreeSerif",
  "Hoefler Text",
  "Microsoft YaHei", // 微软雅黑
  "Hiragino Sans GB", // 冬青黑体
  "WenQuanYi Micro Hei", // 文泉驿微米黑
  "STHeiti", // 华文黑体
  "sans-serif", // 无衬线
];

export const Text: React.FC<
  React.PropsWithChildren<{
    style?: React.CSSProperties;
    size?: string;
    editable?: any;
    copyable?: any;
  }>
> = ({ children, style, size, editable, copyable }) => {
  switch (size) {
    case "small":
      size = "12px";
      break;
    case "medium":
      size = "18px";
      break;
    case "large":
      size = "24px";
      break;
    case "title":
      size = "36px";
      break;
    case "extra":
      size = "80px";
      break;
    default:
      size = "18px";
  }
  return (
    <AntdText
      style={{
        ...style,
        fontSize: size,
      }}
      editable={editable}
      copyable={copyable}
    >
      {children}
    </AntdText>
  );
};

export const Link: React.FC<
  React.PropsWithChildren<{
    style?: React.CSSProperties;
    onClick?: () => void;
    danger?: boolean;
  }>
> = ({ children, style, onClick, danger }) => {
  return (
    <AntdLink
      type={danger ? "danger" : undefined}
      style={{
        ...style,
        fontSize: "12px",
      }}
      onClick={onClick}
    >
      {children}
    </AntdLink>
  );
};

export const Button: React.FC<
  React.PropsWithChildren<{ style?: React.CSSProperties; onClick?: () => void }>
> = ({ children, style, onClick }) => {
  return (
    <AntdButton
      className="need-interaction"
      style={{
        ...style,
        fontSize: "18px",
        height: "40px",
        cursor: "pointer",
      }}
      onClick={onClick}
    >
      {children}
    </AntdButton>
  );
};

export const Scroll: React.FC<
  React.PropsWithChildren<{ style?: React.CSSProperties }>
> = ({ children, style }) => {
  return (
    <div
      className="need-interaction"
      style={{
        ...style,
        height: "100%",
        width: "100%",
        overflowY: "scroll",
        scrollbarWidth: "thin",
        scrollbarColor: "rgba(0, 0, 0, 0.25) rgba(255, 255, 255, 0)",
      }}
    >
      {children}
    </div>
  );
};


import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { Button, Form, Input, List, message, Modal } from "antd";
import {
  UserOutlined,
  LoginOutlined,
  LogoutOutlined,
  PlusOutlined,
} from "@ant-design/icons";
import * as graphql from "./graphql";
import { Bubble, Card, Link, Scroll, Text } from "./Components";
import { user } from "./getUser";

interface MainPanelProps {
  user: user | null;
  rooms: graphql.GetJoinedRoomsQuery["user_room"] | undefined;
  refetchRooms: () => void;
  addChatBox: (id: number) => void;
  addFileShare: (id: number) => void;
}

const MainPanel: React.FC<MainPanelProps> = (props) => {
  return (
    <Card style={{ width: "300px", height: "fit-content", zIndex: 100 }}>
      <User {...props} />
      {props.rooms && <JoinRoom {...props} />}
      {props.rooms && <RoomList {...props} />}
    </Card>
  );
};

const User: React.FC<MainPanelProps> = ({ user }) => {
  const navigate = useNavigate();

  const handleClick = () => {
    if (user) {
      localStorage.removeItem("token");
      navigate(0);
    } else {
      navigate("/login");
    }
  };

  return (
    <Bubble
      style={{
        width: "276px",
        height: "48px",
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
      }}
    >
      <Text size="title">
        <UserOutlined />
      </Text>
      <Text
        size="title"
        style={{
          height: "42px",
          lineHeight: 1,
          marginLeft: "12px",
          overflow: "hidden",
        }}
      >
        {user ? user.username : "未登录"}
      </Text>
      <Button
        style={{
          width: "36px",
          height: "36px",
          fontSize: "36px",
          marginLeft: "12px",
        }}
        onClick={handleClick}
        type="link"
        danger={user ? true : false}
      >
        {user ? <LogoutOutlined /> : <LoginOutlined />}
      </Button>
    </Bubble>
  );
};

const JoinRoom: React.FC<MainPanelProps> = ({ user, rooms, refetchRooms }) => {
  const [inviteCode, setInviteCode] = useState<string>("");
  const [loading, setLoading] = useState<boolean>(false);

  const { refetch } = graphql.useGetRoomByInviteCodeQuery({
    skip: inviteCode.length !== 6,
  });
  const [joinRoomMutation] = graphql.useJoinRoomMutation();

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const value = e.target.value;
    // Remove all non-digit and non-letter characters
    setInviteCode(value.replace(/[^a-zA-Z0-9]/g, ""));
  };

  const handleJoin = async () => {
    setLoading(true);
    if (inviteCode.length !== 6) {
      message.error("邀请码长度错误！");
      return setLoading(false);
    }
    if (rooms?.find((r) => r.room.invite_code === inviteCode)) {
      message.error("已加入该房间！");
      return setLoading(false);
    }
    const queryResult = await refetch({
      invite_code: inviteCode,
    });
    if (queryResult.errors) {
      console.error(queryResult.errors);
      message.error("获取房间失败！");
      return setLoading(false);
    }
    if (queryResult.data?.room.length === 0) {
      message.error("房间不存在！");
      return setLoading(false);
    }
    const room = queryResult.data?.room[0];
    const result = await joinRoomMutation({
      variables: {
        room_uuid: room?.uuid,
        user_uuid: user!.uuid,
      },
    });
    if (result.errors) {
      console.error(result.errors);
      message.error("加入房间失败！");
    } else {
      message.success("加入房间成功！");
      refetchRooms();
    }
    setInviteCode("");
    setLoading(false);
  };

  return (
    <Bubble
      style={{
        width: "276px",
        height: "48px",
        display: "flex",
        alignItems: "center",
      }}
    >
      <Input
        variant="filled"
        style={{
          width: "150px",
          height: "40px",
          fontSize: "24px",
          fontFamily: "monospace",
          marginLeft: "6px",
        }}
        placeholder="输入邀请码"
        maxLength={6}
        value={inviteCode}
        onChange={handleChange}
      />
      <Button
        type="primary"
        style={{
          height: "40px",
          fontSize: "18px",
          marginLeft: "12px",
          marginRight: "4px",
        }}
        onClick={handleJoin}
        loading={loading}
      >
        <strong>加入会议</strong>
      </Button>
    </Bubble>
  );
};

const RoomList: React.FC<MainPanelProps> = ({
  user,
  rooms,
  refetchRooms,
  addChatBox,
  addFileShare,
}) => {
  const [open, setOpen] = useState<boolean>(false);
  const [loading, setLoading] = useState<boolean>(false);

  const [addRoomMutation] = graphql.useAddRoomMutation();
  const [joinRoomMutation] = graphql.useJoinRoomMutation();

  const handleCreateRoom = async (values: any) => {
    setLoading(true);
    const result1 = await addRoomMutation({
      variables: {
        name: values.name,
        intro: values.intro,
        invite_code: Math.random().toString(36).slice(2, 8).toUpperCase(),
      },
    });
    if (result1.errors) {
      console.error(result1.errors);
      message.error("创建房间失败！");
    } else {
      const result2 = await joinRoomMutation({
        variables: {
          room_uuid: result1.data?.insert_room_one?.uuid,
          user_uuid: user!.uuid,
        },
      });
      if (result2.errors) {
        console.error(result2.errors);
        message.error("加入房间失败！");
      } else {
        message.success("创建并加入房间成功！");
      }
    }
    setLoading(false);
    setOpen(false);
    refetchRooms();
  };

  return (
    <Bubble
      style={{
        width: "276px",
        height: "300px",
        display: "flex",
        flexDirection: "column",
      }}
    >
      <Button
        type="primary"
        style={{ height: "40px", fontSize: "18px", margin: "4px 4px 12px 6px" }}
        icon={<PlusOutlined />}
        onClick={() => setOpen(true)}
      >
        <strong>创建新的会议</strong>
      </Button>
      <Scroll>
        <List
          size="small"
          itemLayout="vertical"
          dataSource={rooms}
          renderItem={(item, index) => (
            <RoomListItem
              room={item.room}
              handleOpenChat={() => addChatBox(index)}
              handleOpenFileShare={() => addFileShare(index)}
            />
          )}
        />
      </Scroll>
      <Modal
        title="创建新的会议"
        open={open}
        okText="创建"
        okButtonProps={{ autoFocus: true, htmlType: "submit" }}
        confirmLoading={loading}
        onCancel={() => setOpen(false)}
        cancelText="取消"
        destroyOnClose
        modalRender={(children) => (
          <Form onFinish={handleCreateRoom} clearOnDestroy>
            {children}
          </Form>
        )}
      >
        <Form.Item
          style={{ marginTop: "24px" }}
          label="会议名称"
          name="name"
          rules={[{ required: true, message: "请输入会议名称！" }]}
        >
          <Input placeholder="输入会议名称" />
        </Form.Item>
        <Form.Item label="会议简介" name="intro">
          <Input placeholder="输入会议简介" />
        </Form.Item>
      </Modal>
    </Bubble>
  );
};

interface RoomListItemProps {
  room: graphql.GetJoinedRoomsQuery["user_room"][0]["room"];
  handleOpenChat: () => void;
  handleOpenFileShare: () => void;
}

const RoomListItem: React.FC<RoomListItemProps> = ({
  room,
  handleOpenChat,
  handleOpenFileShare,
}) => {
  const dateUTC = new Date(room.created_at);
  const date = new Date(
    dateUTC.getTime() - dateUTC.getTimezoneOffset() * 60000
  );

  const handleQuit = () => {
    message.info("暂未实现");
  };

  return (
    <List.Item style={{ padding: "8px" }}>
      <div>
        <Text>
          <strong>{room.name}</strong>
        </Text>
        <br />
        <Text size="small" editable>
          {room.intro}
        </Text>
        <br />
        <Text size="small">
          创建于{" "}
          {date.toLocaleString("zh-CN", {
            dateStyle: "short",
            timeStyle: "short",
          })}
        </Text>
        <Text
          size="small"
          style={{ marginLeft: "12px" }}
          copyable={{ text: room.invite_code }}
        >
          邀请码 {room.invite_code}
        </Text>
        <br />
        <Link style={{ marginTop: "6px" }} onClick={handleOpenChat}>
          打开聊天室
        </Link>
        <Link style={{ marginLeft: "12px" }} onClick={handleOpenFileShare}>
          打开文件共享空间
        </Link>
        <Link danger style={{ marginLeft: "12px" }} onClick={handleQuit}>
          退出会议
        </Link>
      </div>
    </List.Item>
  );
};

export default MainPanel;


import { jwtDecode } from "jwt-decode";

interface userJWTPayload {
  uuid: string;
  "https://hasura.io/jwt/claims": {
    "x-hasura-allowed-roles": string[];
    "x-hasura-default-role": string;
  };
}

export interface user {
  username: string;
  uuid: string;
}

const getUser = () => {
  const token = localStorage.getItem("token");
  if (!token) return null;
  const payload: userJWTPayload = jwtDecode(token);
  const username = localStorage.getItem("username");
  if (!username) return null;
  const user: user = {
    username: username,
    uuid: payload.uuid,
  };
  return user;
};

export default getUser;


import React from 'react';
import { Form, Input, Button, message } from 'antd';
import axios, {AxiosError} from 'axios';

const RequestPasswordResetPage: React.FC = () => {
  const onFinish = async (values: { email: string }) => {
    try {
      await axios.post(`${process.env.REACT_APP_BACKEND_URL}/user/change-password/request`, 
        {username: values.email}, 
        {headers: { "Content-Type": "application/json" },}
    );
    message.success("重置密码邮件已发送！");
    } catch (error) {
        const err = error as AxiosError;
      if(err.response?.status === 422){
        message.error("用户名不为邮箱！");
      }
      else if((err.response?.data as string) === "User does not exist"){
        message.error("用户不存在");  
      }
      message.error("请求失败，请重试！");
    }
  };

  return (
    <Form onFinish={onFinish}>
      <Form.Item
        name="email"
        rules={[{ required: true, message: '请输入您的邮箱！' }]}
      >
        <Input placeholder="邮箱" />
      </Form.Item>
      <Form.Item>
        <Button type="primary" htmlType="submit">
          请求重置密码
        </Button>
      </Form.Item>
    </Form>
  );
};

export default RequestPasswordResetPage;