Succinct arguments for QMA from standard assumptions
via compiled nonlocal games
Tony Metger*1, Anand Natarajan‚Ä†2, and Tina Zhang‚Ä°2
1ETH Zurich
2MIT
Abstract
We construct a succinct classical argument system for QMA, the quantum analogue of NP, from generic and
standard cryptographic assumptions. Previously, building on the prior work of Mahadev (FOCS ‚Äô18), Bartusek et
al. (CRYPTO ‚Äô22) also constructed a succinct classical argument system for QMA. However, their construction
relied on post-quantumly secure indistinguishability obfuscation, a very strong primitive which is not known from
standard cryptographic assumptions. In contrast, the primitives we use (namely, collapsing hash functions and a mild
version of quantum homomorphic encryption) are much weaker and are implied by standard assumptions such as
LWE. Our protocol is constructed using a general transformation which was designed by Kalai et al. (STOC ‚Äô23) as a
candidate method to compile any quantum nonlocal game into an argument system. Our main technical contribution
is to analyze the soundness of this transformation when it is applied to a succinct self-test for Pauli measurements on
maximally entangled states, the latter of which is a key component in the proof of MIP‚àó= RE in quantum complexity.
*Email: tmetger@ethz.ch
‚Ä†Email: anandn@mit.edu
‚Ä°Email: tinaz@mit.edu
1
arXiv:2404.19754v1  [quant-ph]  30 Apr 2024


Contents
1
Introduction
3
1.1
Technical overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
2
Preliminaries
12
2.1
Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
2.2
Nonlocal games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
2.3
Pauli matrices and Heisenberg-Weyl group . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
2.4
Reduced measurements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
2.5
State dependent norm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
2.6
Efficient observables and computational indistinguishability
. . . . . . . . . . . . . . . . . . . . . .
15
2.7
Quantum homomorphic encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
3
Approximate representation theory
16
3.1
Gowers-Hatami theorem with non-uniform measures . . . . . . . . . . . . . . . . . . . . . . . . . .
16
3.2
Switching distributions for approximate Heisenberg-Weyl group representations . . . . . . . . . . . .
18
3.3
Lifting (anti-)commutation from small-bias sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
4
Description of the question-succinct protocol
23
4.1
Compiling nonlocal games using cryptography: the KLVY transformation . . . . . . . . . . . . . . .
23
4.2
Description of question-succinct protocol for QMA . . . . . . . . . . . . . . . . . . . . . . . . . . .
23
4.3
Question types
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
5
Modeling and state-dependent norms for the compiled game
28
5.1
Modelling the prover in any compiled game . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
5.2
Modelling the prover in Protocol 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
6
Analysis of the question-succinct protocol
32
6.1
Consistency test and ‚Äúprover switching‚Äù . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
6.2
Analysis of compiled Pauli braiding test: obtaining the group relations . . . . . . . . . . . . . . . . .
34
6.3
Analysis of compiled mixed-vs-pure basis test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
6.4
Subsampled Hamiltonian . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
6.5
Analysis of the compiled Hamiltonian test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
6.6
Analysis of full compiled protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
44
7
Compiling from a question-succinct protocol into a fully succinct protocol using succinct arguments of
knowledge
45
7.1
Post-quantum succinct arguments of knowledge . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
46
7.2
[LMS22] extraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
7.3
A fully succinct version of Protocol 2
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
2


1
Introduction
Succinct verification of computation is a notion that has been extensively studied in the classical setting. A weak
classical client may delegate a classical computation to a powerful server, and may then wish to check whether the
server performed the computation correctly without having to compute the answer for itself. In this case, the client
can ask the server to execute a succinct interactive argument, in which the server (efficiently) convinces the client
beyond reasonable doubt that the computation was performed correctly, and the client only has to do work scaling
with polylogT in order to be convinced, where T is the time that it took to do the computation itself. The messages in
this succinct interactive protocol should also be polylogT in length.
Not long after it came to light that quantum algorithms could outperform the best known classical algorithms in
certain computational tasks, the question was posed of whether a quantum prover could convince a classical verifier of
the answer to a problem in BQP without requiring the classical verifier to simulate the computation itself. For certain
problems, like factoring, a classical verifier can check correctness by exploiting the fact that the problem lies in NP;
however, NP is not known to contain BQP, and for some problems this may be infeasible. This line of inquiry was
initiated by Gottesman in 2004 [Aar07], and has led to a long line of work on the problem now known as quantum
verification.
Succinct quantum verification with a single cryptographically bounded prover.
Mahadev‚Äôs work in 2018 [Mah18]
showed that it is indeed possible for an efficient quantum prover to convince a classical verifier of the answer to any
problem in BQP, given that the quantum prover is subject to certain (post-quantum) cryptographic assumptions. (In
fact, her work also showed that it is possible for an efficient quantum prover to convince a classical verifier of the
answer to any problem in QMA, assuming the prover is given polynomially many copies of the witness state for the
QMA problem.) Mahadev‚Äôs quantum verification protocol inspired a slew of followup work in which her techniques
were used to design other cryptographic quantum verification protocols with desirable additional properties, e.g. the
property of being non-interactive [BKVV20] or composable [GV19] or linear-time [Zha22]. In 2022, Bartusek et
al. [BKL+22] showed, assuming post-quantum iO, that some version of Mahadev‚Äôs protocol can be made succinct, in
the same sense that we described in the opening paragraph: the classical verifier only needs to read messages that are
polylogn bits long, where n is the size of the instance, and do work scaling with polylogT + Àú
O(n), where T is the
time required to execute the verification circuit.
iO, or indistinguishability obfuscation, is an immensely powerful and subtle primitive that has recently been con-
structed from a combination of several standard assumptions [JLS21]. However, some of these assumptions are not
post-quantum, and there is currently no construction of post-quantum iO from standard assumptions. Post-quantum
iO is known to imply other elusive cryptographic objects, e.g. public-key quantum money [Zha21], and constructing
it from standard post-quantum assumptions remains a difficult and important open problem.
The essential difficulty, and the reason for the use of iO in [BKL+22], is that Mahadev‚Äôs approach to verification is
in some sense a qubit-by-qubit approach, and requires ‚Ñ¶(ùúÜ) bits of communication (where ùúÜis the security parameter)
for every qubit in the prover‚Äôs witness state, because the verifier needs to send the prover as many ‚Ñ¶(ùúÜ)-sized public
keys as the witness has qubits. As a result, Mahadev‚Äôs approach is difficult to make succinct, since setting up the keys
already requires at least n¬∑‚Ñ¶(ùúÜ) bits of communication, where n is the number of qubits in the prover‚Äôs witness. The
authors of [BKL+22] use iO in a clever way to compress the keys and thus reduce the amount of required commu-
nication to poly(ùúÜ) ¬∑ polylogn; this is the bulk of their work. More specifically, the authors begin by constructing a
question-succinct (short questions, long answers) protocol for verifying QMA using iO. Then they present a general
compiler which uses a recent post-quantum analysis of Killian‚Äôs succinct arguments of knowledge [CMSZ22, LMS22]
to turn any question-succinct protocol that satisfies certain properties into a fully succinct protocol.
Our result.
Our main contribution in this paper is to construct succinct classical-verifier arguments for QMA from
standard (and even relatively general) assumptions, without relying on post-quantum iO. More specifically, we prove
the following theorem:
Theorem 1.1 (Informal version of Theorem 7.5). Assume that a quantum levelled homomorphic encryption scheme
3


exists which specialises to a classical encryption scheme when it is used on classical plaintexts.1 Assume also that
post-quantum succinct arguments of classical knowledge exist.2 Then a constant-round classical-verifier argument
system for any promise problem in QMA exists, in which:
(i) the honest quantum prover runs in quantum polynomial time, given polynomially many copies of an accepting
QMA witness state,
(ii) the completeness-soundness gap is a constant, and
(iii) the total communication required is of length polylogn¬∑polyùúÜ, where n is the instance size and ùúÜis the security
parameter. The verifier runs in time poly(logT,ùúÜ)+ Àú
O(n), where T is the size of the QMA verification circuit.
The main advantage of our protocol compared with Bartusek et al.‚Äôs protocol [BKL+22] is that our protocol does
not use post-quantum iO, which at this time cannot be instantiated from standard assumptions. Even setting aside the
issue of post-quantum iO, however, we remark that the non-iO assumptions that our approach relies on are more generic
than the Learning With Errors (LWE)‚Äìbased assumptions which Bartusek et al. use. For example, our approach avoids
using the delicate ‚Äòadaptive hardcore bit‚Äô property of LWE-based trapdoor claw-free functions (TCFs), which was
introduced in [BCM+21] and used in Mahadev‚Äôs original verification protocol (as well as Bartusek et al.‚Äôs protocol).
The main primitive we rely on, quantum homomorphic encryption (QHE), can be constructed in its usual form from
LWE without the adaptive hardcore bit assumption [Mah17]. Moreover, we do not in fact need all the properties of
standard QHE: for example, we do not use the standard notion of compactness, which says that decryption time cannot
depend on the size of the circuit being evaluated. Instead, we only need a weak notion of compactness which says that
classical ciphertexts encrypted under the QHE scheme should be classically decryptable (in any polynomial time, even
if the decryption time depends on the evaluated circuit). This more general notion of non-compact QHE with classical
decryption for classical ciphertexts plausibly exists from assumptions other than LWE: for instance, [GV24] represents
recent progress in this direction. As such, our approach shows that the important primitive of quantum verification‚Äî
and even succinct verification‚Äîmay exist from a wider range of assumptions than LWE only. (In contrast, a large
number of post-quantum primitives that use techniques from Mahadev‚Äôs original verification protocol can only, as far
as we can see, be constructed from LWE.)
We achieve Theorem 1.1 by combining powerful information-theoretic tools which originate in the study of non-
local games (e.g. those found in [dlS22]) with tools that cryptography offers (in particular, cryptographic succinct
arguments of knowledge turn out to be very useful for us). The resulting protocol is (compared with the protocol
designed by Bartusek et al.) a remarkably clean object which has a natural intuitive interpretation. The tool that allows
us to combine self-testing techniques with cryptographic techniques is a compilation procedure introduced by Kalai,
Lombardi, Vaikuntanathan, and Yang [KLVY21], which Natarajan and Zhang [NZ23a] recently exploited in order to
achieve classical-verifier quantum verification using a different approach from Mahadev‚Äôs original approach.
A different approach to verification based on nonlocal games.
Since Bell‚Äôs historical observation [Bel64] that
there are certain nonlocal games which quantum entangled players can win with higher probability than classical
players, the entangled two-prover model of computation has been a model of great interest in quantum complexity
theory and quantum foundations [Sca13]. A nonlocal game is a game played between a single efficient classical
referee (or verifier) and two or more unbounded players (or provers) who cannot communicate with each other but are
allowed to share entanglement. The study of the computational power of nonlocal games (i.e. what can the verifier
compute efficiently with the help of the provers, if the verifier doesn‚Äôt trust the provers?) has led to a fruitful line
of work which, in particular, has shown that the verifier in this setting can decide any problem in RE [JNV+20]. In
addition, it is known [Gri17] that, even if the honest provers are required to be efficient, the verifier can still decide any
1In fact, we do not need all the properties of a typical QHE scheme: for example, we do not use the standard notion of compactness, which
says that decryption time cannot depend on the size of the circuit being evaluated. Instead, we only need a weak notion of compactness which says
that classical ciphertexts encrypted under the QHE scheme should be classically decryptable (in any polynomial time, even if the decryption time
depends on the evaluated circuit). We also expect that the weaker primitive of classical-client quantum blind delegation (in which interaction is
allowed) would likely suffice. These weaker primitives could plausibly be instantiated from weaker assumptions than LWE, since they do not imply
classical FHE, which is only known assuming LWE to date. For recent progress towards this, see [GV24].
2These can be constructed from any collapsing hash function.
4


problem in BQP (or QMA, if one of the provers gets access to polynomially many copies of a witness). Put another
way, quantum verification in the entangled two-prover setting is known to exist.
In 2023 Natarajan and Zhang [NZ23a] presented a reproof of Mahadev‚Äôs result which took a different approach
to her original approach, building on previous work on quantum blind delegation [Mah17] and the work of Kalai,
Lombardi, Vaikuntanathan, and Yang [KLVY21]. Kalai, Lombardi, Vaikuntanathan, and Yang used quantum blind
delegation (in particular, quantum homomorphic encryption) in order to design a compilation scheme which maps any
entangled two-prover proof system to a single-prover argument, using cryptography to enforce the no-communication
assumption between the provers. Kalai et al. showed that their compilation scheme preserves quantum completeness
and classical soundness, and Natarajan and Zhang showed that it also preserves quantum soundness for a certain
restricted class of two-prover nonlocal games, which was sufficient to compile a two-prover quantum verification
protocol into a single-prover cryptographic protocol and thus recover Mahadev‚Äôs result.
From the point of view of designing succinct arguments, this approach is more attractive than Mahadev‚Äôs original
approach as a starting point, because the verifier only needs to send the prover a single public key of length poly(ùúÜ)
in order to allow it to do homomorphic evaluations. One might then hope to construct a succinct cryptographic
verification protocol for QMA in the following way: start with a succinct two-prover quantum verification protocol,
pass it through the KLVY compiler, and prove soundness using similar techniques to those which Natarajan and Zhang
used in [NZ23a]. This approach avoids using iO entirely, because the KLVY compiler is ‚Äònaturally‚Äô succinct when
applied to a succinct protocol.
Succinct quantum verification in the entangled two-prover setting.
It is therefore natural to ask whether succinct
quantum verification in the entangled two-prover setting is known. The answer to this question is‚Äîunfortunately‚Äîno,
but for surprisingly complicated reasons. Below is a list of the partial results in this area which are known:
(i) If the honest provers are allowed to be inefficient, and if the (classical) verifier is allowed to take polyn time,
then there is a protocol with polylogn total communication in the entangled two-prover setting to decide QMA
(in fact, to decide all of RE). This was shown by [NZ23b].
Unfortunately, this result is not useful to us if our goal is to compile a succinct two-prover proof system into a
succinct one-prover quantum verification protocol, since we want the honest prover to be efficient.
(ii) In a setting where the verifier interacts with seven provers instead of two, [NV18] claimed to show that efficient-
prover quantum verification of QMA is possible. However, the proof of this result had two substantial errors
in it. One of these errors has been resolved by [JNV+22]. The other one remains unresolved: see this erratum
notice with an explanation of the error [NN24].
Even assuming the errors in [NV18] can be fixed, a seven-prover protocol is not useful to us because the tech-
niques from [KLVY21, NZ23a] were only designed for nonlocal games with two provers. It seems difficult to
extend these techniques to a larger number of provers, which would be necessary to compile the seven-prover
protocol from [NV18].
(iii) Examining the proof of MIP‚àó= RE from [JNV+20] shows that it relies on two so-called compression theorems:
a question reduction theorem which takes a two-prover nonlocal game with long questions (messages from the
verifier to the provers) and maps it to a nonlocal game with exponentially smaller questions while preserving
most other properties of the game, and an answer reduction theorem which takes a two-prover nonlocal game
with long answers (messages from the provers to the verifier) and maps it to a nonlocal game with exponentially
smaller answers.
One would think that these theorems would make proving succinctness in the nonlocal setting easy. Unfortu-
nately, these compression theorems come with caveats: in particular, the answer reduction theorem can only
be applied to so-called oracularisable protocols, and no one has come up with a two-prover verification pro-
tocol for QMA with efficient honest provers which satisfies this property. Moreover, even supposing that we
had a protocol to which we could apply answer reduction, the answer reduction procedure itself happens to be
so complicated and delicate that there is no clear way to analyse its soundness in the compiled setting, even
given the techniques from [NZ23a] and the additional techniques for compiling nonlocal games which have
been developed since then [CMM+24].
5


Question reduction is both simpler and more lenient, however: while it has never been published, question-
succinct quantum verification for QMA in the two-prover setting can be elegantly obtained from known res-
ults [dlS22, Gri17].
The best of both worlds.
The essential reason that two-prover succinct verification remains an open problem is that
nonlocal answer reduction is hard. The only known way to make the answers in a nonlocal game shorter is to use
an ‚Äòentanglement-sound‚Äô classical PCPP, and constructing this object is arguably the most technical and delicate part
of the proof that MIP‚àó= RE. On the other hand, one can make the questions in certain (useful) classes of nonlocal
games shorter using only the elegant machinery of de la Salle [dlS22], who simplified the question reduction theorems
of [JNV+20] by rephrasing them in terms of sampling from ùúñ-biased sets. Therefore, in the nonlocal world, question
reduction is now considered to be relatively easy, and answer reduction remains hard.
In Bartusek et al.‚Äôs approach to succinct verification, meanwhile, the situation was just the opposite: shortening the
questions in the Mahadev protocol using only cryptography was a significant challenge, and shortening the answers
could be done using known techniques in a relatively black-box manner. Given that this is the case, one might hope to
combine the Bartusek et al. approach with the compilation approach in order that the strengths of each might cancel
out the weaknesses of the other.
This is precisely what we do in this work. We construct a succinct verification protocol for QMA by firstly
compiling, using the KLVY compiler, a question-succinct two-prover protocol for QMA, and then compressing the
answers in a generic way using Bartusek et al.‚Äôs Killian-based compiler.
The success of this approach makes a case for using the KLVY compiler as a general way to translate techniques
that are well-understood in the entangled two-prover world into the single-prover cryptographic world. Once this has
been done, they can be combined with ‚Äònatively‚Äô cryptographic techniques in order to marry the desirable properties
of both. It seems plausible that many of the existing results in the sphere of classical-client quantum delegation and
verification could have been obtained in a more unified way and from milder or more generic assumptions if the KLVY
compiler had been known at the time of their genesis, because many tasks that appear difficult in the cryptographic
single-prover setting are well-studied already in the nonlocal setting (and vice versa).
1.1
Technical overview
We focus here on how we obtain question-succinct quantum verification in the single-prover cryptographic setting,
since the Killian-based answer compression protocol and its analysis were already presented in [BKL+22, Section 9],
and we include an exposition-oriented sketch of these results in Section 7 only for completeness.
1.1.1
The basic template from [NZ23a]
Like [NZ23a], our starting point is a basic framework for QMA verification in the two-prover setting due to Grilo [Gri17].
The verifier and the two provers (who we will call Alice and Bob) receive as input an instance of the QMA-complete
promise problem 2-local XZ Hamiltonian [BL08]. In other words, the problem that the verifier is trying to decide is
whether a certain Hamiltonian H on n qubits, expressed as a sum of polynomially many 2-local X/Z Pauli terms (where
each term is a tensor product of n operators, each of which is chosen from {1,ùúéX,ùúéZ}, such that all but 2 factors in
the tensor product are 1), has lowest eigenvalue ‚â§ùõºor ‚â•ùõΩfor two real numbers (ùõº, ùõΩ), where we are promised that
ùõΩ‚àíùõº‚â•
1
poly(n).
Honest Alice and Bob start out by sharing n EPR pairs. The two-prover protocol underlying [NZ23a] for deciding
whether H has lowest eigenvalue ‚â§ùõºor ‚â•ùõΩconsists of two subtests, the Pauli braiding test and the energy test:
Protocol 1 (informal).
(i) Pauli braiding. Alice and Bob execute a version of the Pauli braiding protocol from [NV17], in which they
play interleaved copies of CHSH (or another similar game, like Magic Square) and a simple game known as the
‚Äòcommutation test‚Äô. This protocol is a robust self-test for the n-qubit Pauli group3, in the sense that entangled
3More precisely the Heisenberg-Weyl group, the group consisting of tensor products of 1, ùúéX, ùúéZ with ¬±1 signs, but we ignore this distinction
in this introduction.
6


players who win with high probability in this game must both be playing with measurement operators that are
close (up to local isometries) to actual Pauli measurements. In other words, the Pauli braiding test allows the
verifier to ‚Äòforce‚Äô entangled provers to perform Pauli measurements when requested to do so, even without
trusting the provers. The most modular analysis of this protocol proceeds via a theorem from approximate
representation theory that was first proven by Gowers and Hatami [GH15].
(ii) Energy testing via teleportation. Alice is asked to teleport the n-qubit witness state to Bob using their n
shared EPR pairs. She then reports the teleportation corrections to the verifier. Bob is asked to measure certain
Pauli operators and report the outcomes. The verifier corrects Bob‚Äôs reported outcomes using Alice‚Äôs reported
teleportation corrections, and interprets the result as a measurement of a term from H. It accepts or rejects
depending on whether this measurement indicates that the state which Alice was meant to teleport to Bob is
low-energy or high-energy.
The intuition for the soundness of Protocol 1 is as follows: the Pauli braiding test guarantees in some sense, through
the use of the Gowers-Hatami theorem [GH15], that all successful Bobs are in fact equivalent to honest Bob; and the
energy test is straightforward to analyse if Bob is honest. In order to translate the intuition into reality, we have to
make sure that Bob uses the same strategy in both subtests so that the guarantee on Bob in the Pauli braiding test also
applies to Bob in the energy test. That is, we must make sure he cannot play honestly only in the Pauli braiding test
and then deviate however he likes in the energy test.
Suppose for the moment that the two subtests can be made perfectly indistinguishable to Bob: that is, suppose
that Bob‚Äôs questions in both subtests are drawn from the same distribution. This would ensure that he does the same
measurements in both subtests, since he does not know which subtest is being performed. The Pauli braiding subtest
then guarantees that these measurements are ‚Äòclose‚Äô to honest measurements, and the soundness of subtest (ii) follows
directly from the soundness of subtest (ii) with an honest Bob.
In [NZ23a], following a template laid out by Vidick in [Vid20], the two subtests were indistinguishable because
Bob‚Äôs questions are very simple: in both subtests, Bob only ever receives one of two questions, each with 1
2 probability.
One of these two questions is an instruction to measure all of his qubits in the Z basis (and report all n outcomes), and
the other is an instruction to measure all his qubits in the X basis. Slightly more formally, honest Bob will in one case
apply the projective measurement {|z‚ü©‚ü®z| : z ‚àà{0,1}n}, and in the other case he will apply the projective measurement
{H‚äón|x‚ü©‚ü®x|H‚äón : x ‚àà{0,1}n}.
Measurements of this form, as it turns out, are particularly ‚Äòcompatible‚Äô with the Gowers-Hatami-based analysis
of the Pauli braiding test, in a sense that we will make somewhat more precise later (when we explain our ‚Äòmixed-vs-
pure basis test‚Äô later in this overview). It would therefore be convenient if this question structure was also sufficient
for the energy test. Fortunately, this happens to be the case in the non-succinct setting: it turns out that 2-local X/Z
Hamiltonian with inverse polynomial gap is complete for QMA even if we restrict the 2-local terms to XX and ZZ
terms, i.e., terms where the two non-identity components of the n-fold tensor product are always of the same type
(ùúéX or ùúéZ). Note that the verifier can reconstruct a measurement of any XX-type term from the outcomes of an all-X
measurement performed by Bob, and any ZZ-type term from the outcomes of an all-Z measurement performed by
Bob. This means that in [NZ23a], it was sufficient in both subtests to ask Bob the same two questions (all-X and
all-Z), each with 1
2 probability. Perfect indistinguishability of the two subtests in Protocol 1 then follows.
1.1.2
Obtaining succinctness
In designing a (question-)succinct protocol with two entangled provers (which we will later compile into a crypo-
graphically secure single-prover protocol), we are faced with two new challenges compared with [NZ23a]:
(i) The Pauli braiding test (subtest (i) of Protocol 1) does not have succinct questions. In particular, while Bob‚Äôs
questions can easily be made succinct (as we just described, it suffices to have only two Bob questions), Alice‚Äôs
questions are more complicated.
(ii) In the non-succinct setting,
1
poly(n) completeness-soundness gap is generally tolerated because it is assumed
that poly(n) many rounds of sequential repetition can be performed in order to boost the gap. In the succinct
setting, this is not feasible, since repeating a succinct protocol poly(n) times results in polylog(n) ¬∑ poly(n)
7


communication; therefore, in the succinct setting, we must design a protocol which has constant soundness gap
even without any repetition. This means that we cannot start with a 2-local XX/ZZ Hamiltonian, since it is not
known whether this problem is QMA-complete with a constant promise gap. If we are to take the same approach
of starting from some Hamiltonian problem, then it has to be a Hamiltonian problem with constant promise gap
such that the terms can be grouped into a small number of subsets (at most 2polylogn subsets), each of which
contains only terms that commute. If this is the case, then Bob can measure all the terms in a single subset
simultaneously and report all the outcomes together, and the verifier only needs to use polylogn bits to tell Bob
which subset to measure. If this is not the case, then the energy testing template from subtest (ii) of Protocol 1
will not work, since the verifier will not be able to tell Bob which terms he should measure in a succinct way.
Subsampling Hamiltonians.
We take a similar approach to Bartusek et al. [BKL+22] in order to deal with the
second issue. We use na√Øve QMA parallel amplification (first written down in [KSV02]; the procedure simply repeats
the QMA verifier in parallel a polynomial number of times) in order to boost the promise gap to a constant; this
results in a Hamiltonian that is a sum of exponentially many terms, each of which can be efficiently measured by
measuring each of the n qubits of the witness in either the X or the Z Pauli basis (with potentially different basis
choices for different qubits). We then use a generic PRG with soundness against adversaries with quantum advice in
order to ‚Äòsubsample‚Äô these terms and emerge with a Hamiltonian that is a sum of 2polylogn terms, each of which can be
efficiently measured by measuring each of the n qubits of the witness in either the X or the Z Pauli basis. This part of
the work is done in Section 6.4.
The mixed-vs-pure basis test and a new self-testing-oriented proof of Gowers-Hatami.
At this point we have
created a new problem: the terms of the Hamiltonian we want to use in the energy subtest can no longer be measured by
a Bob who only ever measures every qubit of his state in either the X basis or the Z basis. This is because the amplified
Hamiltonian contains tensor products of arbitrary combinations of XX and ZZ terms from the original Hamiltonian,
and not only tensor products of terms in the same basis. These mixed terms can be measured by a Bob who does
what we call mixed basis measurements (measurements that involve measuring each of n qubits in either the X or the
Z basis, with potentially different basis choices for different qubits). However, if the verifier picks the mixed bases
depending on the distribution induced by the constant-gap Hamiltonian, the resulting distribution over Bob questions
is not necessarily ‚Äòcompatible‚Äô with even the regular Pauli braiding test. Moreover, it becomes even more difficult to
use anything other than the all-X and all-Z measurements when we consider the succinct version of Pauli braiding, for
reasons that we will elaborate on shortly (in the section ‚ÄòSuccinct Pauli braiding‚Äô).
The natural solution is to use the all-X and all-Z measurements when we play Pauli braiding, use the mixed basis
measurements when we do the energy test, and introduce some sort of consistency test to ensure that the operators that
Bob uses in the energy test are in some sense the same ones as the ones he uses in Pauli braiding. (We call this test
the mixed-vs-pure basis test; the protocol is described in Protocol 7.) Such tests have been analysed in the nonlocal
setting before [NW19], but we are the first to attempt to analyse such a test in the compiled setting, and the compilation
introduces unforeseen difficulties (see ‚ÄòDifficulties in the analysis of the mixed-vs-pure basis test‚Äô below).
The easiest solution to the difficulties that we were able to come up with involves reproving the Gowers-Hatami
theorem (or, rather, the parts of the theorem relevant for self-testing) in a way that supports arbitrary non-uniform
expectations. The (informal) theorem statement for our version of Gowers-Hatami is as follows:
Theorem 1.2 (informal). Let f : G ‚ÜíU(H) be a function from a finite group G to the set of unitaries on some
Hilbert space H. Then there exists a finite-dimensional Hilbert space H‚Ä≤, an isometry V : H ‚ÜíH‚Ä≤, and a unitary
representation ùúã: G ‚ÜíU(H‚Ä≤) of G such that for all measures ùúáover G,
E
g‚àºùúá,h‚àºWn ‚à•f(h) f(g)‚àíf(hg)‚à•2 ‚â§ùúñ=
‚áí
E
g‚àºùúá‚à•f(g)‚àíV ‚Ä†ùúã(g)V‚à•2 ‚â§ùúñ,
where we are being purposefully vague about the norm.
The difference between this theorem and the more typical formulation is that the typical formulation has uniform
expectations over the group everywhere. A version of Gowers-Hatami similar to Theorem 1.2 is often needed in
the self-testing setting when ùúáis in particular the uniform distribution over {ùúéZ(a) : a ‚àà{0,1}n} or {ùúéX(b) : b ‚àà
{0,1}n}, and it is plausible that Theorem 1.2 could also be proven by modifying in some way Gowers and Hatami‚Äôs
8


original proof of their theorem. Nonetheless, the proof that we present under Theorem 3.1 (the formal version of
Theorem 1.2) is an entirely different proof that only uses basic tools from quantum information, namely Stinespring
dilation (instead of matrix Fourier analysis on non-Abelian groups [GH15]). We emphasise that our proof is not a
reproof of the full Gowers-Hatami theorem, because the original theorem gets bounds on the dimension of the ‚Äòpost-
rounding‚Äô Hilbert space H‚Ä≤ (which one typically does not need in self-testing-related applications of Gowers-Hatami).
However, our proof has the advantage that it is completely elementary and self-contained. We believe this proof may
be of independent interest, because the fact that it is simple and self-contained makes it easier to modify the statement
when necessary to incorporate additional desirable properties (such as, for example, the tolerance for non-uniform
expectations that we needed for this work). Together with a ‚Äòdistribution-switching‚Äô trick presented in Lemma 3.3, we
are able to use this version of Gowers-Hatami to work out an analysis of the mixed-vs-pure basis test. We give more
details about how we did this at the end of the following section.
Difficulties in the analysis of the mixed-vs-pure basis test.
Now we elaborate more thoroughly on the nature of
the difficulties that we encountered in analysing the mixed-vs-pure basis test, which we finally resolved by using
Theorem 3.1 and Lemma 3.3. We firstly justify the sense in which the all-X and all-Z measurements are particularly
‚Äòcompatible‚Äô with Pauli braiding, in order to clarify why the consistency test is necessary in the first place.
Why the mixed-vs-pure basis test is necessary.
The reason why the all-X and all-Z measurements are particularly suit-
able for use in the Pauli braiding protocol is that the all-Z question can be interpreted as a simultaneous measurement
of the 2n binary observables {ùúéZ(a) : a ‚àà{0,1}n}, where ùúéZ(a) is the binary observable that is the tensor product of
ùúéZ on all the qubits i where ai = 1 and identity otherwise; and, similarly, the all-X question can be interpreted as a sim-
ultaneous measurement of the 2n binary observables {ùúéX(b) : b ‚àà{0,1}n}. Another (more precise) way to say this is
that, given the (potentially cheating) projective measurement {PZ
u : u ‚àà{0,1}n} that Bob applies when he receives the
instruction to measure everything in the Z basis, we can construct a set of 2n binary observables {Z(a) : a ‚àà{0,1}n}
which are exactly linear, in the sense that
Z(a)Z(a‚Ä≤) = Z(a+a‚Ä≤),
(1.1)
even if Bob is dishonest: simply take
Z(a) :=
‚àë
u‚àà{0,1}n
(‚àí1)u¬∑aPZ
u .
A similar statement holds true for the all-X measurement: we can define a set of 2n binary observables {X(b) : b ‚àà
{0,1}n} such that
X(b)X(b‚Ä≤) = X(b+b‚Ä≤).
(1.2)
We can use the CHSH game and the commutation test in order to certify that these 2¬∑2n binary observables {Z(a),X(b) :
a,b ‚àà{0,1}n} satisfy the commutation relations that would hold if they were genuine Paulis, i.e.
‚à•Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)‚à•2 ‚â§O(ùúñ).
(1.3)
Taking the linearity (Equation (1.1) and Equation (1.2)) and commutation (Equation (1.3)) relations together, we can
prove that {Z(a) : a ‚àà{0,1}n} and {X(b) : b ‚àà{0,1}n} approximately satisfy the relations satisfied by the corres-
ponding elements of the Pauli group. Moreover, by taking products, we can extend Z(a) and X(b) to a matrix-valued
function f(s,a,b) = (‚àí1)sZ(a)X(b) that approximately obeys the multiplication law of the Pauli group. The Gowers-
Hatami theorem then implies that there is a rounding of f which exactly satisfies the Pauli group relations (up to
isometry). That is, there exists a representation ùúåof the Pauli group such that, on average over s,a,b, f(s,a,b) is close
to ùúå(s,a,b) conjugated by the isometry.
Zooming back out to the level of designing Bob‚Äôs questions, note that the all-Z and all-X questions were par-
ticularly nice for the Pauli braiding test because (1) the sets {ùúéZ(a) : a ‚àà{0,1}n} and {ùúéX(b) : b ‚àà{0,1}n} taken
together generate the entire n-qubit Pauli group, and (2) the trick of constructing many binary observables from a
9


single projective measurement gave us exact linearity on the Z side and the X side individually almost for free: that is,
{Z(a) : a ‚àà{0,1}n} is automatically an exact representation of Zn
2, and the same is true of {X(b) : b ‚àà{0,1}n}.
There is no guarantee that these nice properties hold if we consider (instead of the all-X and all-Z questions) the
set of mixed-basis questions induced by the energy test for our constant-gap Hamiltonian. In particular, there is no
guarantee that the binary observables which can be constructed from Bob‚Äôs set of mixed basis measurements will
generate the whole Pauli group, in the way that {ùúéZ(a) : a ‚àà{0,1}n} and {ùúéX(b) : b ‚àà{0,1}n} generate the whole
Pauli group. It becomes even more important to use the all-X and all-Z questions if we want to eventually make the
Pauli braiding test question-succinct: we give some intuition as to why this is the case in the section ‚ÄòSuccinct Pauli
braiding‚Äô.
The easiest solution seems to be to introduce a consistency test between Bob‚Äôs mixed basis measurements (that
we would like Bob to use when he plays the energy test) and Bob‚Äôs pure basis measurements (that we would like
Bob to use when he plays the Pauli braiding test). More specifically‚Äîfollowing the standard template for designing
tests of this form‚Äîwe will introduce two new questions into Alice‚Äôs question set that are identical to Bob‚Äôs pure basis
questions (i.e. ‚Äòmeasure all in X‚Äô and ‚Äòmeasure all in Z‚Äô); we will ask Bob to play his pure basis operators against
Alice‚Äôs pure basis operators, in order to check that Bob‚Äôs pure basis operators are consistent with Alice‚Äôs pure basis
operators; and then we will ask Bob to play his mixed basis operators against Alice‚Äôs pure basis operators, and check
that they agree whenever the bases align, which (since we checked that Bob‚Äôs and Alice‚Äôs pure basis operators agree) is
essentially equivalent to checking that Bob‚Äôs mixed basis operators are consistent with Bob‚Äôs pure basis operators. We
might hope that this test, combined with the usual analysis, will be sufficient to allow us to ‚Äòround‚Äô Bob‚Äôs mixed operat-
ors in the same way that we can round Bob‚Äôs all-X and all-Z measurements by using the usual Gowers-Hatami analysis.
Difficulties in the analysis.
Unfortunately, instantiating this intuition proves to be nontrivial in the compiled setting,
even though the analysis is fairly routine in the nonlocal setting. The tensor product structure of the provers‚Äô Hilbert
space in the nonlocal setting is useful because it supports a large range of convenient operations that are loosely
grouped together under the name of ‚Äòprover-switching‚Äô. The ordinary nonlocal analysis of a consistency test like this
one would proceed primarily through prover-switching calculations. While we did find it necessary to prove some
lemmas which capture certain applications of prover-switching in the compiled setting (see Section 6.1), we found
that these lemmas were insufficient in order to analyse the mixed-vs-pure basis test.
More specifically, the main difficulty we encountered was the following. The statement we would like to show, in
order to make the energy test work in the presence of mixed terms, is of the following form. Let w ‚àà{1,X,Z}n be a
string indicating which Pauli bases to measure n qubits in. We want to show that, if Alice and Bob win in our protocol
with high probability, then there exists an isometry V such that, for the distribution D on Pauli basis choices induced
by the constant-gap Hamiltonian,
E
w‚àºD
E
a‚àà{0,1}n ‚à•Ow(a)‚àíV ‚Ä†(ùúéw(a)‚äó1aux)V‚à•2 ‚â§small,
where ùúéw(a) is the honest Pauli observable that corresponds to the tensor product
ùúéw(a) =
O
i
ùúéai
wi .
and Ow(a) is Bob‚Äôs potentially cheating version of ùúéw(a).
Normal pure-basis Gowers-Hatami tells us that, if Alice and Bob win with high probability in Pauli braiding, then
for any W ‚àà{X,Z} it is the case that
E
a‚àà{0,1}n ‚à•W(a)‚àíV ‚Ä†(ùúéW(a)‚äó1aux)V‚à•2 ‚â§small,
(1.4)
for some fixed isometry V. One idea for proceeding with the analysis might be to show that Ow(a) ‚âàZ(c)X(d) using
the mixed-vs-pure basis test (with c being the string such that ci = 1 iff ai = 1 and wi = W, and similarly for d),
and then to ‚Äòround‚Äô Z(c) and X(d) separately using Equation (1.4). Unfortunately, rounding something of the form
Z(c)X(d) na√Øvely using Equation (1.4) produces something of the form
V ‚Ä†(ùúéZ(c)‚äó1aux)VV ‚Ä†(ùúéX(d)‚äó1aux)V.
10


Since V is an isometry and not a unitary, VV ‚Ä† is not necessarily 1, and it is unclear how to get rid of it: we call this
the ‚ÄòVV ‚Ä† problem‚Äô. There are ways to bypass this problem in the nonlocal setting using tensor product structure, but
we were not able to replicate these techniques in the compiled setting.
Instead, we bypass the problem by ‚Äòdirectly‚Äô proving a form of Gowers-Hatami that, perhaps surprisingly, allows
us to round in expectation over any distribution over the Pauli group, even though the Pauli braiding test is only played
with the uniform distribution. More specifically, we prove our version of Gowers-Hatami (Theorem 3.1, stated earlier
informally as Theorem 1.2), which can be used to round arbitrary distributions over the underlying group, provided
with the right hypothesis; and then we prove, using a ‚Äòdistribution-switching‚Äô trick (Lemma 3.3), that the hypothesis
of Theorem 3.1 can be obtained for any distribution ùúáeven if we only start with commutation relations that hold on
uniform average over pure-basis elements (and a few other conditions, such as exact linearity), which is what we have
access to through the pure-basis Pauli braiding test.
Succinct Pauli braiding.
Finally, armed with the mixed-vs-pure basis test, we can focus on making the Pauli braid-
ing test succinct (where, by ‚ÄòPauli braiding test‚Äô, we mean the version in which Bob always gets asked either the all-X
or the all-Z question). Our starting point for this mission is de la Salle‚Äôs elegant simplification [dlS22] of ‚Äòquestion
reduction‚Äô from [JNV+20], in which he introduces a version of Pauli braiding where Alice‚Äôs questions are sampled
from ùúñ-biased sets. The normal Pauli braiding game proceeds as follows:
‚Ä¢ The verifier chooses two strings a,b ‚àà{0,1}n uniformly at random.
‚Ä¢ The verifier decides what to do next based on the parity of a¬∑b:
‚Äì If a¬∑b = 0, the verifier referees a commutation game (in which honest Alice plays with ùúéZ(a) and ùúéX(b)).
‚Äì If a¬∑b = 1, the verifier referees an anticommutation game (in which, again, honest Alice plays by embed-
ding ùúéZ(a) and ùúéX(b) into her strategy).
The commutation game is designed to test that two particular operators commute, and the anticommutation game
(based on CHSH or Magic Square) is designed to test that two particular operators anticommute.
Note that the verifier has to send a,b to Alice for this protocol to work. The protocol was made succinct by de
la Salle simply by choosing a,b from ùúñ-biased sets instead of from all of {0,1}n. This is a natural idea, but it is at
first surprising that it works at all: after all, the sets of Paulis {ùúéZ(a) : a ‚ààS} and {ùúéX(b) : b ‚ààS} for some ùúñ-biased
S, where |S| = poly(n), only cover an exponentially small fraction of the Pauli group! All that the protocol directly
certifies is commutation and anticommutation relations among pairs of operators in these sets. Na√Øvely, to deduce
relations about representations of general group elements, one would need to write these elements as poly(n)-length
words in the group elements from the ùúñ-biased sets, and apply the relations on the ùúñ-biased sets poly(n)-many times.
This would seemingly rule out a test with constant soundness.
Miraculously, however, everything still works as before, and the reason is that we do probe the entire group through
Bob, who still measures the all-X and all-Z mesaurements. In particular, we have ‚Äòfor free‚Äô (or by construction)
that Bob‚Äôs X(b) operators, taken as a set, form an exact representation of Zn
2, and the same for his Z(a) operators.
Meanwhile, all elements of the Pauli group can be written as words of constant length in the operators {ùúéZ(a) : a ‚àà
{0,1}n} and {ùúéX(b) : b ‚àà{0,1}n}. In some sense, de la Salle‚Äôs test works because probing the commutation relations
between two exact representations of Zn
2 on only an ùúñ-biased set is sufficient to establish the commutation relations
everywhere, because the function of ùúñ-biased sets is precisely to ‚Äòfool‚Äô exactly linear functions. In fact, de la Salle‚Äôs
test and its analysis are analogous to the ‚Äúderandomized BLR test‚Äù for linear functions and the Fourier-based analysis
of it presented in Section 6.4 of [O‚ÄôD14].
In order to use the succinct version of Pauli braiding in our protocol, we have to come up with a version of the
analysis that works in the compiled setting. Unfortunately, de la Salle‚Äôs original proof in the nonlocal case is written in
the ‚Äòsynchronous‚Äô setting, in which the provers (even malicious provers) are assumed to start out by sharing EPR pairs.
This assumption simplifies the calculations because it allows us to move (‚Äòprover switch‚Äô) measurements freely from
one prover to the other. The synchronicity assumption is without loss of generality in the nonlocal setting by [Vid22],
but no compiled version of this result exists. Therefore, we have to redo the proof in our setting using the state-
dependent distance, and come up with ways to use the cryptography to simulate the ‚Äúprover switching" steps in de
la Salle‚Äôs analysis. (At the time of [NZ23a] it was not known whether the cryptography could in fact simulate these
11


properties.) In the process, we pare down de la Salle‚Äôs proof to the parts that are essential for analysing succinct Pauli
braiding and state it in more computer-science-like language, which may be useful for future readers with a computer
science background. Our version of de la Salle‚Äôs analysis is presented as Lemma 3.5.
Related work.
Simultaneously, a succinct argument system for QMA based only on the post-quantum security
of LWE (a standard assumption) was achieved by [GKNV24]. Both of these works use tools from [BKL+22], in
particular the technique of ‚Äúsubsampling‚Äù a Hamiltonian using a PRG, and the technique of transforming a semi-
succinct protocol into a fully succinct one by using succinct arguments of knowledge. However, the methods they use
to solve the key technical challenge of succinctly delegating many-qubit Pauli measurements are essentially disjoint.
In particular, for us, the ‚Äúheavy lifting" to achieve question-succinctness is performed information theoretically, in
our question-succinct two-prover self-test for EPR pairs, whereas for them, succinctness is achieved by using specific
technical features of a cryptographic construction using LWE.
Acknowledgements.
We are grateful to Fermi Ma for allowing us to rewind him until we could extract an under-
standing from the succinct arguments in Section 9 of [BKL+22]. We also thank Yael Kalai, Alex Lombardi, and
Thomas Vidick for useful discussions. TM acknowledges support from the ETH Zurich Quantum Center and an ETH
Doc.Mobility Fellowship.
2
Preliminaries
2.1
Notation
We assume basic familiarity with quantum states and measurements. We consider finite dimensional Hilbert spaces,
which we commonly denote by H. The set of linear operator A : H ‚ÜíH is L(H), the set of positive semidefinite
A : H ‚ÜíH is Pos(H), and the set of unitaries U : H ‚ÜíH is U(H). For A ‚ààL(H), we use ‚à•A‚à•p := Tr[(A‚Ä†A)p/2]1/p to
denote its Schatten p-norm. For any (subnormalised) pure state |ùúì‚ü©, we denote the (subnormalised) density matrix by
ùúì.
For a probability distribution D over some set X, we write x ‚àºD to denote a sample drawn according to D. We
write x ‚àºX to denote a sample drawn uniformly from X.
For a,b ‚ààC and ùõø> 0, we write a ‚âàùõøb if |a‚àíb| ‚â§ùõø.
2.2
Nonlocal games
In a non-local game, a verifier (or referee) sends questions to multiple non-communicating provers, receives an answer
from each prover, and evaluates the question-answer combination using a verification predicate to decide whether the
provers ‚Äúwin‚Äù or ‚Äúlose‚Äù the game. Formally, a two-prover non-local game is specified by the following.
Definition 2.1. A nonlocal game G is given by natural numbers n1,n2,m1,m2, a distribution Q over pairs (x,y) ‚àà
{0,1}n1 √ó {0,1}n2, and a polynomial-time verification predicate V(x,y,a,b) ‚àà{0,1}, where a ‚àà{0,1}m1 and b ‚àà
{0,1}m2.
2.3
Pauli matrices and Heisenberg-Weyl group
We use the usual Pauli matrices ùúéX,ùúéY,ùúéZ. We will also find it convenient to set ùúé1 = 1. For w ‚àà{1,X,Z}n and
a ‚àà{0,1}n, we define
ùúéw(a) =
O
i
ùúéai
wi .
We also write ùúéw = ùúéw(
‚Éó
1) = ‚äóiùúéwi.
12


In addition, we define the Pauli projections ùúãw
a as
ùúãw
u =
O
i
1+(‚àí1)uiùúéwi
2

=
E
a‚àà{0,1}n(‚àí1)u¬∑aùúéw(a).
(2.1)
The Heisenberg-Weyl group on n qubits, denoted Wn, is the group generated by {ùúéX(a),ùúéZ(b)}a,b‚àà{0,1}n, where the
group operation is induced by matrix multiplication. More formally, to differentiate between the group in the abstract
and its concrete representation in terms of Pauli matrices, we view Wn as a group with generators X1,...,Xn,Z1,...,Zn,
with the multiplication rule given by associating Xi with ùúéX(ei) and Zj with ùúéX(ej) (where ei ‚àà{0,1}n is 0 everywhere
except on position i, where it is 1). We record the representations of Wn in the following lemma.
Lemma 2.2. The irreducible representations of the Heisenberg-Weyl group Wn consist of
‚Ä¢ The one-dimensional representations, given by choosing an assignment of 1 or ‚àí1 for each of the generators
X1,Z1,...,Xn,Zn
and filling out the rest of the multiplication table accordingly. Note that for any one-dimension irrep ùúã, ùúã(‚àíid) =
ùúã(X1Z1X1Z1) = 1, where the first equality uses that X1Z1X1Z1 = ‚àíid according to the group relations, and the
second equality uses the representation property and the fact that multiplication of scalars is commutative.
‚Ä¢ The ‚Äòfundamental representation‚Äô given by the 2n-dimensional Pauli matrices: that is,
‚àÄj,
Xj 7‚ÜíùúéX(e j),
Zj 7‚ÜíùúéZ(ej).
2.4
Reduced measurements
We will frequently consider measurements that return tuples as outcomes. For those measurements, it is convenient to
define reduced (or marginalised) measurements, where we only care about some of the elements of the outcome tuple
and ignore the others. For this, we define the following notation.
Definition 2.3. For any alphabet Œ£, let u ‚ààŒ£n, and let S = {i1,i2,...,ik} ‚äÜ[n]. Then u|S := (ui1,...,uik) ‚ààŒ£k is the
restriction of u to S.
Definition 2.4. For any alphabet Œ£, w ‚ààŒ£n, and W ‚ààŒ£, the set {w = W} is defined as {i ‚àà[n] : wi = W}.
Definition 2.5 (Reduced measurements). For any alphabet Œ£, measurement {Qu}u‚ààŒ£n, and set S ‚äÜ[n], we define the
reduced measurement
(Q|S)v‚ààŒ£|S| = ‚àë
u:u|S=v
Qu.
We will often apply this definition to measurements that measure many qubits, each in one of the Pauli bases, to
select the outcomes corresponding to a single basis. Specifically, for Œ£ = {0,1}, and for any Pauli string w ‚àà{X,Z}n,
basis choice W ‚àà{X,Z}, and string v ‚àà{0,1}|{w=W}|, we have
(Q|{w=W})v =
‚àë
u:u|{w=W}=v
Qu ,
In other words (Q|{w=W})v is the marginalisation over all outcomes on indices where wi Ã∏= W.
13


2.5
State dependent norm
Definition 2.6 (State-dependent inner product and norm). Let H be a finite-dimensional Hilbert space and A,B ‚ààL(H)
be linear operators on H. Let ùúì‚ààPos(H). We define the state-dependent (semi) inner product of A and B w.r.t ùúìas
‚ü®A,B‚ü©ùúì= Tr[A‚Ä†Bùúì].
This induces the state-dependent (semi) norm
‚à•A‚à•2
ùúì= ‚ü®A,A‚ü©ùúì= Tr[A‚Ä†Aùúì].
Remark 2.7. The state dependent (semi) norm can also be expressed as a Schatten 2-norm (also called the Hilbert-
Schmidt norm):
‚à•A‚à•ùúì=



Aùúì1/2


2 .
We collect a number of basic properties of the state dependent norm. These are standard properties and easy to
prove from the definitions.
Lemma 2.8 (Basic properties of the state dependent norm). For all (not necessarily normalised) states ùúì,ùúì‚Ä≤ ‚ààPos(H)
and linear operators A,B ‚ààL(H) on some finite-dimensional Hilbert space H:
(i) ‚à•A‚à•BùúìB‚Ä† = ‚à•AB‚à•ùúì.
(ii) ‚à•AB‚à•ùúì‚â§‚à•A‚à•‚àû‚à•B‚à•ùúì.
(iii) For any unitary U, ‚à•UA‚à•ùúì= ‚à•A‚à•ùúì.
(iv) Linearity of the squared norm in the state: ‚à•A‚à•2
ùúì+ùúì‚Ä≤ = ‚à•A‚à•2
ùúì+‚à•A‚à•2
ùúì‚Ä≤.
(v) Triangle inequality for the squared norm: ‚à•A+B‚à•2
ùúì‚â§2‚à•A‚à•2
ùúì+2‚à•B‚à•2
ùúì.
Lemma 2.9. For an observable A on H and two states ùúì,ùúìon H with ‚à•ùúì‚àíùúì‚Ä≤‚à•1 ‚â§ùúñ, we have that
‚à•A‚à•2
ùúì‚âà‚à•A‚à•2
‚àûùúñ‚à•A‚à•2
ùúì‚Ä≤ .
Proof. This follows immediately from the definition of the state dependent norm and H√∂lder‚Äôs inequality.
Lemma 2.10. For all i ‚ààI (for some index set I) let Ai ‚ààL(H) and ùúìi ‚ààPos(H) such that ‚àëi Tr[ùúìi] ‚â§1. Then
‚àë
i
‚à•Aiùúìi‚à•1 ‚â§
r
‚àë
i
‚à•Ai‚à•2
ùúìi .
Proof. We first split ùúìi = ùúì1/2
i
ùúì1/2
i
and apply H√∂lder‚Äôs inequality:
‚àë
i
‚à•Aiùúìi‚à•1 ‚â§‚àë
i



Aiùúì1/2
i



2



ùúì1/2
i



2 .
Now applying Cauchy Schwarz:
‚â§
s
‚àë
i



Aiùúì1/2
i



2
2 ¬∑
s
‚àë
i



ùúì1/2
i



2
2 ‚â§
r
‚àë
i
‚à•Ai‚à•2
ùúìi ,
where in the last line we rewrote the first factor as a state-dependent norm and for the second factor] observed that
‚àëi



ùúì1/2
i



2
2 = ‚àëi Tr[ùúìi] ‚â§1.
14


2.6
Efficient observables and computational indistinguishability
Definition 2.11 (Computational indistinguishability). Two families of (subnormalized) states {ùúì1(ùúÜ)}ùúÜand {ùúì2(ùúÜ)}ùúÜ,
indexed by a security parameter ùúÜ, are compuationally indistinguishable if for any family of computationally eficient
two-outcome POVMs {M(ùúÜ),1‚àíM(ùúÜ)}ùúÜindexed by ùúÜ, it holds that
Tr[M(ùúÜ)(ùúì1(ùúÜ)‚àíùúì2(ùúÜ)] ‚â§negl(ùúÜ).
We typically indicate this by
ùúì1
c
‚âàùúì2,
suppressing the dependence on ùúÜin the notation.
Lemma 2.12. Let {U1
a }a‚ààA,...,{Uk
a}a‚ààA and {V 1
b }b‚ààB,...,{V ‚Ñì
b }b‚ààB be families of efficient unitaries on some Hilbert
space H, s : Ak √ó B‚Ñì‚Üí{0,1} an efficiently computable function, and ùúáan efficiently sampleable distribution over
A√ók √óB√ó‚Ñì.
Consider two states ùúì
c
‚âàùõøùúì‚Ä≤. Then
E
(a1,...,ak,b1,...,b‚Ñì)‚àºùúá



U1
a1 ¬∑¬∑¬∑Uk
ak ‚àí(‚àí1)s(a1,...,ak,b1,...,b‚Ñì)V 1
b1 ¬∑¬∑¬∑V ‚Ñì
b‚Ñì



2
ùúì
‚âàùõø
E
(a1,...,ak,b1,...,b‚Ñì)‚àºùúá



U1
a1 ¬∑¬∑¬∑Uk
ak ‚àí(‚àí1)s(a1,...,ak,b1,...,b‚Ñì)V 1
b1 ¬∑¬∑¬∑V ‚Ñì
b‚Ñì



2
ùúì‚Ä≤ .
Proof. Note that the product of efficient unitaries is another efficient unitary. Then this follows directly from the
definition of computational indistinguishability (Definition 2.11), linearity of expectation, and [MV21, Lemma 2.6].
2.7
Quantum homomorphic encryption
The following definitions are taken with some modifications from [KLVY21]. Note that this definition of quantum
homomorphic encryption requires, among other specialised requirements, that the scheme specialises to a classical
encryption scheme when applied to classical messages: we need this property in our constructions.
Definition 2.13 (Quantum Homomorphic Encryption (QHE)). A quantum homomorphic encryption scheme QHE =
(Gen,Enc,Eval,Dec) for a class of quantum circuits C is a tuple of algorithms with the following syntax:
‚Ä¢ Gen is a PPT algorithm that takes as input the security parameter 1ùúÜand outputs a (classical) secret key sk of
poly(ùúÜ) bits;
‚Ä¢ Enc is a PPT algorithm that takes as input a secret key sk and a classical input x, and outputs a classical
ciphertext ct;
‚Ä¢ Eval is a QPT algorithm that takes as input a tuple (C,|Œ®‚ü©,ctin), where C : H√ó(C2)‚äón ‚Üí(C2)‚äóm is a quantum
circuit, |Œ®‚ü©‚ààH is a quantum state, and ctin is a ciphertext corresponding to an n-bit classical plaintext. Eval
computes a quantum circuit EvalC(|Œ®‚ü©‚äó|0‚ü©‚äópoly(ùúÜ,n),ctin) which outputs a ciphertext ctout. If C has classical
output, we require that EvalC also has classical output.
‚Ä¢ Dec is a QPT algorithm that takes as input a secret key sk and ciphertext ct, and outputs a state |ùúô‚ü©. Additionally,
if ct is a classical ciphertext, the decryption algorithm outputs a classical string y.
We require the following three properties from (Gen,Enc,Eval,Dec):
‚Ä¢ Correctness with auxiliary input: For every security parameter ùúÜ‚ààN, any quantum circuitC : HA√ó(C2)‚äón ‚Üí
{0,1}‚àó(with classical output), any quantum state |Œ®‚ü©AB ‚ààHA ‚äóHB, any message x ‚àà{0,1}n, any secret key
sk ‚ÜêGen(1ùúÜ) and any ciphertext ct ‚ÜêEnc(sk,x), the following states have negligible trace distance:
15


Game 1. Start with (x,|Œ®‚ü©AB). Evaluate C on x and register A, obtaining classical string y. Output y and the
contents of register B.
Game 2. Start with ct ‚ÜêEnc(sk,x) and |Œ®‚ü©AB. Compute ct‚Ä≤ ‚ÜêEvalC(¬∑‚äó|0‚ü©poly(ùúÜ,n),ct) on register A. Compute
y‚Ä≤ = Dec(sk,ct‚Ä≤). Output y‚Ä≤ and the contents of register B.
In words, ‚Äúcorrectness with auxiliary input‚Äù requires that if QHE evaluation is applied to a register A that is
a part of a joint (entangled) state in HA ‚äóHB, the entanglement between the QHE evaluated output and B is
preserved.
‚Ä¢ IND-CPA security against quantum distinguishers: For any two messages x0,x1 and any QPT adversary A:



Pr

AEncsk(¬∑)(ct0) = 1




sk ‚ÜêGen(1ùúÜ)
ct0 ‚ÜêEnc(sk,x0)

‚àíPr

AEncsk(¬∑)(ct1) = 1




sk ‚ÜêGen(1ùúÜ)
ct1 ‚ÜêEnc(sk,x1)




‚â§negl(ùúÜ) .
‚Ä¢ Relaxed compactness: We do not need the typical notion of homomorphic encryption compactness, which
states that decryption must not depend on the evaluated circuit. However, we do require the following (much
weaker) properties:
‚Äì Classical-quantum (CQ) compactness. There is a PPT algorithm DecClassical which, for any entirely
classical ciphertext ct‚Ä≤ originating from the experiment ‚ÄòGame 2‚Äô described in ‚ÄòCorrectness with auxiliary
input‚Äô, satisfies the definition of correctness with auxiliary input when substituted for Dec.
‚Äì Compactness of encryption. The running time of Enc on input single-bit messages should not be larger
than poly(L)¬∑polylog(S)¬∑poly(ùúÜ), where L is a depth upper bound on the circuits that need to be evaluated
and S is a size upper bound. (Note that this restriction does not apply to Eval.)
Compactness of encryption, which we require in order to achieve the question-succinctness of Protocol 2, is a
property satisfied by most levelled homomorphic encryption schemes. This property suffices for us because all of the
‚ÄòAlice‚Äô computations in Protocol 3 can be done by log depth circuits (log in the instance size n), and for question
succinctness we just need the verifier‚Äôs questions to be polylogn in length (and computable in the same time).
3
Approximate representation theory
3.1
Gowers-Hatami theorem with non-uniform measures
The Gowers-Hatami theorem [GH15] states that if a function f : G ‚ÜíU(H) from a finite group to unitary matrices
approximately behaves like a representation, then it can be ‚Äúrounded‚Äù to an exact representation. The formulation of
this statement in [GH15] required that the ‚Äúapproximate representation behaviour‚Äù hold on average over uniformly
sampled pairs of group elements. As explained in the introduction, we require a similar statement, but for arbitrary
measures over the group. Formally, we show the following.
Theorem 3.1. Let f : G ‚ÜíU(H). Then there exists a finite-dimensional Hilbert space H‚Ä≤, an isometry V : H ‚ÜíH‚Ä≤,
and a unitary representation ùúã: G ‚ÜíU(H‚Ä≤) of G such that for all measures ùúáover G and all normalised states ùúì,
E
g‚àºùúá,h‚àºWn ‚à•f(h)f(g)‚àíf(hg)‚à•2
ùúì‚â§ùúñ=
‚áí
E
g‚àºùúá‚à•f(g)‚àíV ‚Ä†ùúã(g)V‚à•2
ùúì‚â§ùúñ.
Proof. Let HG be the complex space of formal sums of group elements and define a representation ùúã: G ‚ÜíL(HG) by
ùúã(g) = ‚àë
h‚àºWn
|h‚ü©‚ü®hg|.
16


It is clear that ùúãis a unitary representation of G (in fact, ùúãis just the regular representation, written in Dirac notation).
We define the convolution of f with itself as
f ‚àó(g) = E
h‚àºWn f(h)‚Ä† f(hg).
With this, we can define a superoperator ùúô: L(HG) ‚ÜíL(H) by taking the linear extension of
ùúô(|g‚ü©‚ü®h|) = 1
|G| f ‚àó(g‚àí1h).
Since f(g) is always unitary, it follows immediately that ùúôis unital, i.e. ùúô(1) = 1. We further claim that ùúôis completely
positive. To show this, it suffices to show that the Choi operator
C = ‚àë
g,h
ùúô(|g‚ü©‚ü®h|)‚äó|g‚ü©‚ü®h| ‚ààL(H‚äóHG)
is positive. For this, take any |x‚ü©‚ààH‚äóHG and decompose it as
|x‚ü©= ‚àë
g
|xg‚ü©|g‚ü©.
Here, |xg‚ü©are not necessarily orthogonal or normalised. Then,
‚ü®x|C|x‚ü©= ‚àë
g,h
‚ü®xg|ùúô(|g‚ü©‚ü®h|)|xh‚ü©
= 1
|G| ‚àë
g,h
‚ü®xg|f ‚àó(g‚àí1h)|xh‚ü©
=
1
|G|2 ‚àë
g,h,l
‚ü®xg|f(l)‚Ä† f(lg‚àí1h)|xh‚ü©
=
1
|G|2 ‚àë
g,h,l
‚ü®xg|f(lg)‚Ä† f(lh)|xh‚ü©
=
1
|G|2 ‚àë
l
‚ü®ùúâl|ùúâl‚ü©‚â•0,
with |ùúâl‚ü©= ‚àëg f(lg)|xg‚ü©, where we relabelled l 7‚Üílg in the fourth line.
Having shown that ùúôis unital and completely positive, we can apply Stinespring‚Äôs dilation theorem to deduce that
there exists some auxiliary space K and an isometry V : H ‚ÜíHG ‚äóK such that for all A ‚ààL(HG),
ùúô(A) = V ‚Ä†(A‚äó1K)V .
To relate this back to the original question of rounding the approximate representation f, we observe that
f ‚àó(g) = ùúô(ùúã(g)) = V ‚Ä†(ùúã(g)‚äó1K)V .
Taking the isometry in the theorem statement to be V and the exact representation ùúã(g)‚äó1K (which, in a slight abuse
of notation, we again just call ùúã), we can therefore bound
E
g‚àºùúá‚à•f(g)‚àíV ‚Ä†ùúã(g)V‚à•2
ùúì= E
g‚àºùúá‚à•f(g)‚àíf ‚àó(g)‚à•2
ùúì
= E
g‚àºùúá‚à•E
h‚àºWn( f(g)‚àíf(h)‚Ä† f(hg))‚à•2
ùúì
‚â§
E
g‚àºùúá,h‚àºWn ‚à•f(g)‚àíf(h)‚Ä† f(hg)‚à•2
ùúì
=
E
g‚àºùúá,h‚àºWn ‚à•f(h) f(g)‚àíf(hg)‚à•2
ùúì‚â§ùúñ,
where the inequality follows from Cauchy-Schwarz and the last line uses left-unitary invariance of the state dependent
norm (Item (iii)) and the assumption that f is an approximate representation.
Remark 3.2. Observe that if f is exactly left-multiplicative over some ùúá, i.e. if f(g) f(h) = f(gh) for all g ‚ààsupp(ùúá)
and for all h ‚ààG, then f(g) = V ‚Ä†ùúã(g)V for all g ‚ààsupp(ùúá).
17


3.2
Switching distributions for approximate Heisenberg-Weyl group representations
We will be particularly concerned with approximate representations of the Heisenberg-Weyl group. The following
lemma shows that if a collection of operators {Z(a),X(b)}a,b‚àà{0,1}n satisfies certain properties for uniform expectations
over the group, these operators can be rounded to Pauli operators for arbitrary expectations. We note that this switch
from uniform to arbitrary measures does not work in general and crucially relies on each of {Z(a)} and {X(b)} being
an exact representation of Zn
2.
Lemma 3.3. Suppose we have collections of efficient binary observables {Z(a)}a‚àà{0,1}n and {X(b)}b‚àà{0,1}n on a
Hilbert space H that each form exact representations of Zn
2, i.e. for all a,b ‚àà{0,1}n, Z(a + b) = Z(a)Z(b) and
X(a+b) = X(a)X(b). Consider a state ùúìand suppose that the following conditions hold: Suppose that
E
a Z(a)ùúìZ(a)
c
‚âàùúì,
(3.1)
E
a X(a)ùúìX(a)
c
‚âàùúì,
(3.2)
E
a,b‚àà{0,1}n



Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)



2
ùúì‚â§ùúñ.
(3.3)
Then there exists an isometry V : H ‚ÜíC2n ‚äóHaux such that for all distributions ùúáon {0,1}n √ó{0,1}n,
E
(a,b)‚àºùúá


Z(a)X(b)‚àíV ‚Ä†(ùúéZ(a)ùúéX(b)‚äó1Haux)V


2
ùúì‚â§O(ùúñ).
Proof. Define the following function from the Heisenberg-Weyl group to U(H):
f(¬±ùúéZ(a)ùúéX(b)) = ¬±Z(a)X(b).
Our proof strategy is as follows: first show that f is an approximate representation over arbitrary measures ùúá, i.e. that
it satisfies the hypothesis of Theorem 3.1; then use Theorem 3.1 and the structure of the irreps of the Heisenberg-Weyl
group to round Z(a) and X(b) to the corresponding Pauli operators.
To show that f is an approximate representation, we first bound the following quantity for an arbitrary measure ùúá
on {0,1}n √ó{0,1}n.
E
a,b‚àà{0,1}n
E
(c,d)‚àºùúá



X(a)Z(b)X(c)Z(d)‚àí(‚àí1)b¬∑cX(a+c)Z(b+d)



2
ùúì
By Lemma 2.12 and Lemma 2.8 Item (iv):
‚âànegl
E
u‚àà{0,1}n
E
a,b‚àà{0,1}n
E
(c,d)‚àºùúá



X(a)Z(b)X(c)Z(d)‚àí(‚àí1)b¬∑cX(a+c)Z(b+d)



2
Z(u)ùúìZ(u)
By Lemma 2.8 Item (i):
=
E
u‚àà{0,1}n
E
a,b‚àà{0,1}n
E
(c,d)‚àºùúá



X(a)Z(b)X(c)Z(d +u)‚àí(‚àí1)b¬∑cX(a+c)Z(b+d +u)



2
ùúì
Again applying Lemma 2.12 and Lemma 2.8 Item (i) and Item (iv) to Ev X(v)ùúìX(v)
c
‚âàùúì:
‚âànegl
E
u,v‚àà{0,1}n
E
a,b‚àà{0,1}n
E
(c,d)‚àºùúá



X(a)Z(b)X(c)Z(d +u)X(v)‚àí(‚àí1)b¬∑cX(a+c)Z(b+d +u)X(v)



2
ùúì
By Equation (3.3) (noting that the marginal distributions of d +u and b+d +u are both uniform and independent from
v) and Lemma 2.8 Item (ii):
=
E
u,v‚àà{0,1}n
E
a,b‚àà{0,1}n
E
(c,d)‚àºùúá



(‚àí1)v¬∑(d+u)X(a)Z(b)X(c+v)Z(d +u)‚àí(‚àí1)b¬∑c+v¬∑(b+d+u)X(a+c+v)Z(b+d +u)



2
ùúì+O(ùúñ)
18


Repeating the same step (now noting that c+v and d +u are independent and uniform, and likewise for a+c+v and
b+d +u) and cancelling phases:
=
E
u,v‚àà{0,1}n
E
a,b‚àà{0,1}n
E
(c,d)‚àºùúá



(‚àí1)c¬∑(d+u)X(a)Z(b+d +u)X(c+v)‚àí(‚àí1)b¬∑c+v¬∑(b+d+u)X(a+c+v)Z(b+d +u)



2
ùúì+O(ùúñ)
With one more repetition of the same step, we finally get:
=
E
u,v‚àà{0,1}n
E
a,b‚àà{0,1}n
E
(c,d)‚àºùúá‚à•X(a+c+v)Z(b+d +u)‚àíX(a+c+v)Z(b+d +u)‚à•2
ùúì+O(ùúñ) = O(ùúñ).
From the above calculation and the fact that f is exactly multiplicative under ¬±1 we get that f is an approximate
representation of the Heisenberg-Weyl group Wn for any distribution ùúáover the group. Expressed in equations, we
have shown that for any distribution ùúáon Wn,
E
g‚àºùúá,h‚àºWn ‚à•f(h) f(g)‚àíf(hg)‚à•2
ùúì‚â§O(ùúñ).
Furthermore from the definition of f we have that f is exactly multiplicative under ¬±1, which we can also write
(slightly cumbersomely) as
E
g‚àºùúá‚àí,h‚àºWn ‚à•f(h)f(g)‚àíf(hg)‚à•2
f = 0,
where ùúá‚àíis the point distribution that has all its weight on the ‚àí1-element of Wn.
We can therefore apply Theorem 3.1 and, noting that in that theorem the representation ùúãand the isometry V are
independent of the distribution ùúá, get that there exists an isometry V : H ‚ÜíH‚Ä≤ and a unitary representation ùúãof Wn on
H‚Ä≤ such that
E
g‚àºùúá


f(g)‚àíV ‚Ä†ùúã(g)V


2
ùúì‚â§O(ùúñ),
(3.4)
E
g‚àºùúá‚àí


 f(g)‚àíV ‚Ä†ùúã(g)V


2
ùúì=


1+V ‚Ä†ùúã(‚àí1)V


2
ùúì= 0.
(3.5)
For Equation (3.5), we used that f(‚àí1) = ‚àí1.
Equation (3.4) shows that f can be rounded to some representation of the Heisenberg-Weyl group. However, we
want a stronger statement: we want to show that we can round f to the actual Pauli matrices (tensored with identity),
whereas an arbitrary representation might contain other representations of Wn.
For this, we write ùúã(g) = ùúã+(g) ‚äïùúã‚àí(g) where ùúã¬±(¬∑) is a representation satisfying ùúã¬±(‚àíg) = ¬±ùúã¬±(g) for all g.
By Lemma 2.2, any representation of the Pauli group can be written this way, by decomposing it into a direct sum
of irreducible representations, and grouping together all the one-dimensional irreps into ùúã+, and all the copies of the
fundamental representation into ùúã‚àí. Moreover, by padding with copies of the trivial representation (and adding all-0
rows to V appropriately), we can ensure that dim(ùúã+) = kdim(ùúã‚àí). As such, we assume without loss of generality
that dim(ùúã+) = kdim(ùúã‚àí).
The intuition for the remainder of the proof is as follows: we will simply replace the ùúã+-part of the representation
with k copies of the ùúã‚àí-part; call this modified representation ùúã‚Ä≤. Of course ùúãand ùúã‚Ä≤ now differ a lot as representations,
but we need to show that after applying the isometry V and in the state-dependent norm, this difference does not matter.
This will follow from Equation (3.5).
More formally, we define
ùúã‚Ä≤(g) :=

ùúã‚àí(g)‚äóIk
ùúã‚àí(g)

h‚Ä≤(g) := V ‚Ä†ùúã‚Ä≤(g)V .
We will also use the notational shorthand
h(g) = V ‚Ä†ùúã(g)V.
19


Note that because ùúã‚àíonly consists of copies of the fundamental representation (the Pauli matrices), so does ùúã‚Ä≤.
This means that ùúã‚Ä≤ is of the form we claimed in the theorem, i.e. it is a tensor product of the Pauli matrices with
identities.
It therefore suffices to show that ‚à•h‚Ä≤(g)‚àíh(g)‚à•ùúì= 0. To see that this is the case, note that since ùúã‚àí(g) ‚â§1,
‚à•h‚Ä≤(g)‚àíh(g)‚à•2
ùúì= ‚à•V ‚Ä†

ùúã‚àí(g)‚äóIk ‚àíùúã+(g)
0

V‚à•2
ùúì
‚â§




V ‚Ä†

2¬∑1
0

V




2
ùúì
=


V ‚Ä†(ùúã(1)+ ùúã(‚àí1))V


2
ùúì
=


1+V ‚Ä†ùúã(‚àí1)V


2
ùúì= 0.
The last line uses Equation (3.5). This completes the proof.
3.3
Lifting (anti-)commutation from small-bias sets
In [dlS22], de la Salle gave a question-succinct version of the Pauli braiding test of [NV17]. The key step in his proof is
to show that if (anti-)commutation statements for a certain set of observables hold on average over a ùúÜ-biased set, they
also hold on average over all observables (up to small corrections). We need a similar statement, but unfortunately
we cannot use the result from [dlS22] directly since it is proven in the Frobenius norm, whereas we need it in the
state-dependent norm. Additionally, since we want to use this step for compiled games, we cannot use the full suite of
techniques from non-local games (in particular, we cannot use prover switching). We remedy this situation by proving
the following variant of de la Salle‚Äôs result. This also gives a more elementary proof of de la Salle‚Äôs original result.
Definition 3.4. A set S ‚äÜ{0,1}n is ùúÜ-biased if for all b ‚àà{0,1}n such that b Ã∏= 0n,
| E
a‚ààS(‚àí1)a¬∑b| ‚â§ùúÜ.
It is known how to efficiently construct a ùúÜ-biased set S of size O(n/poly(ùúÜ)) using error correcting codes [NN90].
In our applications, ùúÜwill always be a universal constant.
Lemma 3.5. Let M and {W(a)}a‚àà{0,1}n be efficient binary observables acting on a Hilbert space H satisfying
W(a)W(b) = W(a+b) and ùúåa state on H such that
ùúå
c
‚âàùõøE
a W(a)ùúåW(a).
Further let S ‚àà{0,1}n be a ùúÜ-biased set. Then
E
a‚àà{0,1}n ‚à•W(a)M ‚àíMW(a)‚à•2
ùúå‚â§
1
1‚àíùúÜE
a‚ààT ‚à•W(a)M ‚àíMW(a)‚à•2
ùúå+
2ùõø
1‚àíùúÜ.
Proof. Let T ‚äÜ{0,1}n be an arbitrary set (later we will set T = S or T = {0,1}n). Define Àú
ùúå= EaW(a)ùúåW(a). By
Lemma 2.12, for any a ‚àà{0,1}n it holds that
‚à•W(a)M ‚àíMW(a)‚à•2
ùúå‚â•‚à•W(a)M ‚àíMW(a)‚à•2
Àú
ùúå‚àíùõø.
Consequently, this also holds on average over a ‚ààT, i.e.
E
a‚ààT ‚à•W(a)M ‚àíMW(a)‚à•2
ùúå‚â•E
a‚ààT ‚à•W(a)M ‚àíMW(a)‚à•2
Àú
ùúå‚àíùõø.
(3.6)
Using that M and Z(a) are binary observables,
E
a‚ààT ‚à•W(a)M ‚àíMW(a)‚à•2
Àú
ùúå= 2‚àí2‚ÑúE
a‚ààT Tr[MW(a)MW(a) Àú
ùúå] .
20


Our goal is therefore to relate the trace expression for T = Zn
2 and T = S. For this, observe that W(a) forms a unitary
representation of Zn
2, which we can decompose into a direct sum of irreducible representations:
W(a) = Àú
UD(a) Àú
U‚Ä† ,
D(a) = ‚äïi ((‚àí1)ùõæi¬∑a ‚äó1mi)
for U ‚ààU(H) and distinct strings ùõæi ‚ààZn
2 with multiplicities mi such that ‚àëi mi = dimH. In this basis, Àú
ùúåhas a
block-diagonal structure made up of blocks of size mi, i.e.
Àú
U‚Ä† Àú
ùúåÀú
U = ‚äïiùúåi
for positive semi-definite blocks ùúåi of dimension mi. For each i, let Wi ‚ààU(mi) be a unitary that diagonalises ùúåi and
define
U = Àú
U(‚äïiWi).
This is a unitary and by construction,
ùúé:= U‚Ä† Àú
ùúåU = diag(ùúé1,...,ùúédimH)
is diagonal. Furthermore, (‚äïiWi) commutes with all matrices D(a), so that we also have
W(a) = UD(a)U‚Ä† ,
D(a) = ‚äïdimH
i
((‚àí1)ci¬∑a) ,
where ci ‚àà{0,1}n are the same as the ùõæi above, except that for the rest of the proof we find it more convenient to
repeat strings rather than keeping track of their multiplicities by tensoring with identity.
For convenience, we define
Œì = U‚Ä†MU .
Then, we can rewrite
E
a‚ààT Tr[MW(a)MW(a) Àú
ùúå] = E
a‚ààT Tr[ŒìD(a)ŒìD(a)ùúé]
= E
a‚ààT ‚àë
i, j,k
Œìij(‚àí1)c j¬∑aŒì jk(‚àí1)ck¬∑aùúéki
= ‚àë
i, j,k

E
a‚ààT(‚àí1)(c j+ck)¬∑a

ŒìijŒì jkùúéki
Since ùúé= diag(ùúéi):
= ‚àë
i, j

E
a‚ààT(‚àí1)(c j+ci)¬∑a

ŒìijŒì jiùúéi
Since M is Hermitian, so is Œì, so that Œìji = Œì‚àó
i j:
= ‚àë
i, j

E
a‚ààT(‚àí1)(c j+ci)¬∑a

|Œìij|2ùúéi .
We now divide up the indices i, j over which we sum into two sets:
C = {(i, j) | ci Ã∏= cj},
¬Ø
C = [dimH]2 \C.
If (i, j) ‚àà¬Ø
C, then
E
a‚ààZn
2
(‚àí1)(c j+ci)¬∑a = E
a‚ààS(‚àí1)(c j+ci)¬∑a = 1.
21


On the other hand, if (i, j) ‚ààC, then since S is ùúÜ-biased we have that
E
a‚ààZn
2
(‚àí1)(c j+ci)¬∑a = 0,
| E
a‚ààS(‚àí1)(c j+ci)¬∑a| ‚â§ùúÜ.
We therefore get
E
a‚àà{0,1}n ‚à•W(a)M ‚àíMW(a)‚à•2
Àú
ùúå= 2‚àí2 ‚àë
i, j‚àà¬Ø
C
|Œìij|2ùúéi
and, since |Œìij|2ùúéi ‚â•0,
E
a‚ààS‚à•W(a)M ‚àíMW(a)‚à•2
Àú
ùúå‚â•2‚àí2 ‚àë
i, j‚àà¬Ø
C
|Œìij|2ùúéi ‚àí2ùúÜ‚àë
i, j‚ààC
|Œìij|2ùúéi .
We can simplify this by observing that since Œì is a binary observable,
‚àë
i j
|Œìij|2ùúéi = Tr[Œì‚Ä†Œìùúé] = 1.
As a result,
E
a‚ààS‚à•W(a)M ‚àíMW(a)‚à•2
Àú
ùúå‚â•2‚àí2 ‚àë
i, j‚àà¬Ø
C
|Œìij|2ùúéi ‚àí2ùúÜ
 
1‚àí‚àë
i, j‚àà¬Ø
C
|Œìij|2ùúéi
!
= (1‚àíùúÜ) E
a‚ààZn
2
‚à•W(a)M ‚àíMW(a)‚à•2
Àú
ùúå.
The lemma now follows by first switching from ùúåto Àú
ùúåon both sides using Equation (3.6) (incurring an error ùõø+
ùõø
1‚àíùúÜ‚â§
2ùõø
1‚àíùúÜ) and then using the above bound.
Lemma 3.5 implies the following corollary on anti-commutation relations.
Corollary 3.6. Let {X(a)}a‚àà{0,1}n and {Z(a)}a‚àà{0,1}n be families of efficient binary observables acting on a Hilbert
space H satisfying W(a)W(b) = W(a+b) for all W ‚àà{X,Z} and a,b ‚àà{0,1}n. Let ùúåbe a state on H such that
ùúå
c
‚âàùõøE
a W(a)ùúåW(a).
for all W ‚àà{X,Z}. Further, let S ‚àà{0,1}n be a ùúÜ-biased set. Then
E
a,b‚àà{0,1}n ‚à•Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)‚à•2
ùúå‚â§
1
(1‚àíùúÜ)2
E
a,b‚ààS‚à•Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)‚à•2
ùúå+ 2ùõø(2‚àíùúÜ)
(1‚àíùúÜ)2 .
Proof. Let ùúå‚Ä≤
AB = ùúåA ‚äó1
2n IB. For W ‚àà{X,Z}, define
Àú
W(a)AB = W(a)A ‚äóùúéW(a)B.
Observe that
[ Àú
Z(a), Àú
X(b)] = (Z(a)X(b)‚àí(‚àí1)a,bX(b)Z(a))‚äóùúéZ(b)ùúéX(a).
Moreover, for any operators M on the A system and N on the B system, it holds that
‚à•M ‚äóN‚à•2
ùúå‚Ä≤ = Tr[M‚Ä†M ‚äóN‚Ä†Nùúå‚Ä≤]
= 1
2n Tr[M‚Ä†Mùúå]¬∑Tr[N‚Ä†N]
= ‚à•M‚à•2
ùúå¬∑ 1
2n Tr[N‚Ä†N].
22


Thus, we have
E
a,b‚àà{0,1}n‚à•Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)‚à•2
ùúå
=
E
a,b‚àà{0,1}n ‚à•[ Àú
Z(a), Àú
X(b)]‚à•2
ùúå‚Ä≤
‚â§
1
1‚àíùúÜE
a‚ààS
E
b‚àà{0,1}n ‚à•[ Àú
Z(a), Àú
X(b)]‚à•2
ùúå‚Ä≤ +
2ùõø
1‚àíùúÜ
‚â§
1
(1‚àíùúÜ)2
E
a,b‚ààS‚à•[ Àú
Z(a), Àú
X(b)]‚à•2
ùúå‚Ä≤ +2ùõø

1
1‚àíùúÜ+
1
(1‚àíùúÜ)2

=
1
(1‚àíùúÜ)2
E
a,b‚ààS‚à•Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)‚à•2
ùúå+2ùõø

1
1‚àíùúÜ+
1
(1‚àíùúÜ)2

.
4
Description of the question-succinct protocol
4.1
Compiling nonlocal games using cryptography: the KLVY transformation
Kalai, Lombardi, Vaikuntanathan and Yang give a transformation that maps a k-player 1-round nonlocal game into a
2k-message (k-round) interactive protocol between a single prover and verifier. For simplicity, we will only present
their transformation as it is applied to two-player nonlocal games, because this is the only context in which we need
to use it. The general transformation, applicable to k-player nonlocal games for arbitrary k, is described in [KLVY21,
Section 3.2]. The following presentation is taken with some modifications from [KLVY21, Section 3.1].
[KLVY21] presents a PPT-computable transformation that converts any 2-prover non-local game G with question
set Q and verification predicate V into a single-prover protocol (associated with security parameter ùúÜ), defined as
follows. Fix a quantum homomorphic encryption scheme QHE = (Gen,Enc,Eval,Dec).
(i) The verifier samples (x,y) ‚ÜêQ, sk ‚ÜêGen(1ùúÜ), and c ‚ÜêEnc(sk,x). The verifier then sends c to the prover as
its first message.
(ii) The prover replies with a message ùõº.
(iii) The verifier sends y to the prover in the clear.
(iv) The prover replies with a message b.
(v) Define a := Dec(sk,ùõº). The verifier accepts if and only if V(x,y,a,b) = 1.
4.2
Description of question-succinct protocol for QMA
In the following, we will denote the syntax of the protocol in regular font, and we will denote the actions of the honest
prover(s) in italics.
Protocol 2. Question-succinct argument system for QMA
Inputs: An instance x ‚àà{0,1}‚àó, an algorithm C which is the verifier for a QMA promise problem A =
(Ayes,Ano) such that A ‚ààQMA, and a security parameter ùúÜ‚ààN. The protocol is given by applying the KLVY
compiler (described in Section 4.1) with security parameter ùúÜto Protocol 3.
23


Protocol 3. Question-succinct (two-prover) proof system for QMA
Inputs: An instance x ‚àà{0,1}‚àóand an algorithm C which is the verifier for a QMA promise problem
A = (Ayes,Ano) such that A ‚ààQMA.
On input x,C, execute the reduction given in Theorem 6.21 to produce a Hamiltonian problem (H,ùõº(n), ùõΩ(n))
(see Definition 6.12) with ùõΩ(n)‚àíùõº(n) = 1‚àínegl(n), where H is an n-qubit operator (n = poly(|x|)) with the
following form:
H = 1‚àíE
w‚ààD ‚àë
u‚ààQ(w)
ùúãw
u
where
‚Ä¢ w ‚àà{1,X,Z}n is a Pauli string,
‚Ä¢ {ùúãw
u }u is the projective measurement corresponding to measuring n qubits in the natural way in the Pauli
bases specified by w (see Equation (2.1) for a formal definition),
‚Ä¢ Q(w) ‚äÜ{0,1}n is a set for which membership can be decided in polynomial time in n given w, and
‚Ä¢ D is a distribution over {1,X,Z}n which can be efficiently sampled from using sampling randomness of
length 2polylog(n).
In words, if H is of this form, then the quantity 1‚àíTr[Hùúå] for any n-qubit state ùúåcan be estimated by a QPT
(in n) verifier who samples a w from D, measures the n qubits of ùúåin the Pauli bases specified by w, obtains
outcomes a, and accepts iff a ‚ààQ(w).
Assume that we are considering a yes-instance x ‚ààAyes. Honest Alice receives a witness that x ‚ààAyes as
input, and converts it in polynomial time to a n-qubit witness ùúåthat the ground energy of H is ‚â§ùõº(n). Honest
Alice and Bob then share n+1 EPR pairs between themselves; most of the tests in the following protocol use
only the last n EPR pairs, but the first EPR pair will be used in Protocol 6.
The verifier executes each of the following tests with Alice and Bob with equal probability.
(i) Pauli braiding test. Described in Protocol 4; n will be the number of qubits on which H acts.
(ii) Mixed-versus-pure basis test. Described in Protocol 7; the distribution D will be the D such that
H = 1‚àíE
w‚àºD‚àëu‚ààQ(w) ùúãw
u .
(iii) Hamiltonian test. Described in Protocol 8; the distribution D and the sets {Q(w)}w will be those such
that H = 1‚àíE
w‚àºD‚àëu‚ààQ(w) ùúãw
u .
24


Protocol 4. Pauli braiding test with succinct questions
Input: an integer n.
Let S ‚äÜ{0,1}n be a ùúá-biased set. The verifier picks a,b uniformly at random from S ‚äÜ{0,1}n. Assuming
that |S| = poly(n), this process takes O(logn) bits of randomness. Let the randomness which the verifier uses
in this process be denoted r = (ra,rb), where ra determines a and rb determines b.
(i) (Commutation): If a¬∑b = 0, the verifier executes the commutation test (Protocol 5) with questions ra,rb.
(ii) (Anticommutation): If a¬∑b = 1, the verifier executes the anticommutation test (Protocol 6) with ques-
tions ra,rb.
Protocol 5. Commutation test
Input: questions ra and rb which index two elements a and b in S ‚äÜ{0,1}n.
1. The verifier sends (com,ra,rb) to Alice, and recieves responses (ua,ub) with ua,ub ‚àà{0,1}. Honest Alice
computes a and b from ra and rb, measures ùúéZ(a) and ùúéX(b) on her last n qubits, and returns the results
as ua and ub respectively.
2. The verifier picks W ‚àà{X,Z} uniformly at random and sends W to Bob. Bob responds with v ‚àà{0,1}n.
Note that Bob is not told that he is playing the commutation test: he receives only the question label W.
Honest Bob measures his last n qubits in the W basis.
3. If W = Z, the verifier accepts iff ‚àèi:ai=1 vi = ua. If W = X, the verifier accepts iff ‚àèi:bi=1 vi = ub.
25


Protocol 6. Anticommutation test
Input: questions ra and rb which index two elements a and b in S ‚äÜ{0,1}n.
In this protocol, the verifier plays a version of the Mermin-Peres Magic Square game [Ara02, Mer90, Per90]
with the provers, in which Alice is asked to measure three observables forming a row or column of the square,
and Bob is asked to measure an observable from a single cell of the square. Both provers are instructed to use
the observables labeled by ra and rb for two specific cells in the square (the top centre and centre left cells), as
indicated below.
1. The verifier chooses a cell index j ‚àà[9] uniformly at random; it then chooses uniformly at random a row
or a column on a 3√ó3 grid which contains cell j. Suppose that the cell indices of the 3 cells in this row
or column are (i1,i2,i3) (one of these will be equal to j).
2. The verifier sends (MS,ra,rb,i1,i2,i3) to Alice, and receives responses u1,u2,u3 ‚àà{0,1}. Honest Alice
computes a and b from ra,rb. Then she measures the three (n + 1)-qubit observables associated with
cells i1,i2,i3 in the following grid, and returns all three 1-bit outcomes to the verifier:
ùúéZ ‚äó1
1‚äóùúéZ(a)
ùúéZ ‚äóùúéZ(a)
1‚äóùúéX(b)
ùúéX ‚äó1
ùúéX ‚äóùúéX(b)
‚àíùúéZ ‚äóùúéX(b)
‚àíùúéX ‚äóùúéZ(a)
‚àíùúéZùúéX ‚äóùúéZ(a)ùúéX(b)
Operators before the tensor product are understood always to act on the first qubit of Alice‚Äôs halves of
the shared EPR pairs, and operators after the tensor product on the last n qubits.
3. If j = 2 (i.e. Bob‚Äôs question indicates the top centre cell), the verifier sends Z to Bob, receives v ‚àà{0,1}n
as an answer, and accepts iff ‚àèi:ai=1 vi is equal to u2 (if Alice was asked a row question) or u1 (if Alice
was asked a column question). If j = 4 (i.e. Bob‚Äôs question indicates the centre left cell), the verifier
sends X to Bob, receives v ‚àà{0,1}n as an answer, and accepts iff ‚àèi:bi=1 vi is equal to u1 (if Alice was
asked a row question) or u2 (if Alice was asked a column question. In all other cases, the verifier sends
(MS,ra,rb, j) to Bob, receives a single-bit answer v ‚àà{0,1}, and accepts iff v = uk for the k ‚àà[3] such
that uk = j. Honest Bob measures all his qubits in the W basis when he receives a single bit question W,
and in all other cases uses the same strategy as honest Alice, except that he only measures a single cell
instead of 3.
26


Protocol 7. Mixed-versus-pure basis test
Input: a distribution D over {1,X,Z}n which can be sampled from using no more than 2polylogn random
bits.
1. The verifier selects a basis W from {X,Z} uniformly at random and sends W to Alice. It receives answer
u ‚àà{0,1}n. Honest Alice measures all of her qubits in the W basis.
2. The verifier selects a uniformly random b ‚Üê{0,1}.
(i) If b = 0, the verifier sends W to Bob, and receives answer v ‚àà{0,1}n. It accepts iff u = v. Honest
Bob measures all of his qubits in the W basis.
(ii) If b = 1, the verifier samples a Pauli string w from D and sends its sampling randomness (which is
polylogn bits in length) to Bob. It accepts iff for all i where wi =W, it is the case that ui = vi. Honest
Bob measures his last n qubits in the Pauli bases designated by w and reports all the measurement
results. For qubits where wi = 1, he always reports the measurement result 0.
Protocol 8. Hamiltonian test
Input: a distribution D over {1,X,Z}n which can be sampled from using no more than 2polylogn random
bits, along with a collection of sets {Q(w) : w ‚àà{1,X,Z}n} such that Q(w) ‚äÜ{0,1}n (described in a way such
that membership in Q(w) can be efficiently decided given w).
1. The verifier sends question tele to Alice, and receives in response two strings, ux,uz ‚àà{0,1}n. Honest
Alice teleports her ground state to Bob through their last n shared EPR pairs and reports the teleportation
corrections.
2. The verifier samples a Pauli string w from D and sends its sampling randomness (which is polylogn bits
in length) to Bob. The verifier then receives measurement outcomes from Bob, corrects Bob‚Äôs outcomes
using Alice‚Äôs reported teleportation corrections, and does the appropriate energy test. More specifically,
the verifier receives answer v from Bob, and computes for every i such that wi Ã∏= 1
si =
vi
|{z}
Bob‚Äôs measurement
‚äï[(ux)i]1[wi=Z] ‚äï[(uz)i]1[wi=X]
|
{z
}
correction from Alice
Then the verifier sets si = 0 for every i such that wi = 1, and accepts iff s ‚ààQ(w). Honest Bob measures
his last n qubits in the Pauli bases designated by w and reports all the measurement results. For qubits
where wi = 1, he always reports the measurement result 0.
4.3
Question types
For convenience, we summarise the different question types that Alice and Bob may each see in Protocol 3 here.
(These are not necessarily in one-to-one correspondence with the subgames of the protocol, since some subgames are
indistinguishable from Bob‚Äôs point of view.)
We denote the set of Alice questions by QA and the set of Bob questions by QB.
Alice questions:
27


‚Ä¢ (com,ra,rb): compute a and b from ra and rb and measure ùúéZ(a) and ùúéX(b).
‚Ä¢ (MS,ra,rb,i1,i2,i3): compute a and b and play magic square for the cells indicated by i1,i2,i3 with the operators
for cells 1 and 5 coinciding with the ùúéX(a) and ùúéZ(b) operators.
‚Ä¢ X or Z: measure all qubits in ùúéX or ùúéZ basis.
‚Ä¢ w for Pauli string w ‚àà{1,X,Z}n: do mixed basis measurement in Pauli bases given by w.
‚Ä¢ tele: do teleportation measurement.
Bob questions:
‚Ä¢ X or Z: measure all qubits in ùúéX or ùúéZ basis.
‚Ä¢ (MS,ra,rb, j): compute a and b and play magic square for the cell indicated by j with the operators for cells 1
and 5 coinciding with the ùúéX(a) and ùúéZ(b) operators.
‚Ä¢ w for Pauli string w ‚àà{1,X,Z}n: do mixed basis measurement in Pauli bases given by w.
5
Modeling and state-dependent norms for the compiled game
5.1
Modelling the prover in any compiled game
We recall the formalism used by [NZ23a] to model the prover‚Äôs strategy in a compiled nonlocal game. In general, the
prover‚Äôs actions in any compiled game can be modeled as follows. The prover starts with some initial (pure) state |ùúì‚ü©.
In the first round, it performs a projective measurement depending on the ciphertext question c to obtain an outcome
ùõº, followed by a unitary depending on c and ùõº, to obtain a post-measurement state. In the second round, it performs a
projective measurement on its residual state depending on the plaintext question y, to obtain an outcome b.
We note that both measurements can be assumed to be projective without loss of generality, by the Naimark dilation
theorem. We also note that the post-measurement unitary is necessary in the compiled case, since both ‚Äúprovers" act
sequentially on the same register; it is usually ignored in the case of nonlocal games, since the provers act on separate
subsystems.
Mathematically, we model the strategy of the prover as follows:
(i) The initial pure state is denoted |ùúì‚ü©. We often write ùúìfor |ùúì‚ü©‚ü®ùúì|.
(ii) The first measurement (the ‚ÄúAlice measurement") is modeled by a collection of non-Hermitian operators Ac
ùõº.
These satisfy the condition that for each c, the collection of operators {(Ac
ùõº)‚Ä†(Ac
ùõº)} forms a projective measure-
ment. Thus, the probability that Alice returns outcome ùõºin response to question c is
Pr[ùõº] = ‚ü®ùúì|(Ac
ùõº)‚Ä†(Ac
ùõº)|ùúì‚ü©.
(iii) The un-normalized post-measurement state after receiving question c and responding with answer ùõºis
|ùúìc
ùõº‚ü©= Ac
ùõº|ùúì‚ü©.
(5.1)
Note that ‚à•|ùúìc
ùõº‚ü©‚à•2 = Pr[ùõº]. The post-measurement state marginalizing over outcomes for question c is the mixed
state
ùúìc = ‚àë
ùõº
ùúìc
ùõº= ‚àë
ùõº
|ùúìc
ùõº‚ü©‚ü®ùúìc
ùõº|.
(iv) The second measurement (the ‚ÄúBob measurement") is modeled by a POVM measurement {By
b} for each question
y. While this measurement can always be taken to be projective without loss of generality, in the analysis it will
sometimes be convenient to construct strategies where this measurement is a POVM.
28


Altogether, then, we can specify a strategy for a compiled nonlocal game by a triple (|ùúì‚ü©,{Ac
ùõº},{By
b}), where each
element of the triple is implicitly a function of the security parameter ùúÜand the encryption key sk.
For notational convenience, given any Alice question q ‚ààQA, we sometimes use the shorthand
ùúìEnc(q)
ùõº
= E
sk
E
c‚ÜêEncsk(q)ùúìc
ùõº,
ùúìEnc(q) = E
sk
E
c‚ÜêEncsk(q)ùúìc
Remark 5.1 (Implicit expectation over keys). The security of an encryption scheme (Gen,Enc,Dec) requires the
encryption keys to be chosen randomly by Gen. In particular, this means that certain indistinguishability statements
we will want to make hold only in expectation over keys sk output by Gen: for example, when we claim that two
Alice post-measurement (mixed) states ùúìEnc(q) and ùúìEnc(q‚Ä≤) are indistinguishable to Bob, we really mean that, for any
two-outcome measurement {M,I ‚àíM} that can be implemented by a circuit with size poly(ùúÜ), there exists a negligible
function ùúÇ(ùúÜ) such that
E
sk‚ÜêGen(ùúÜ)


Tr[MùúìEnc(q)]‚àíTr[MùúìEnc(q‚Ä≤)]


 ‚â§ùúÇ(ùúÜ).
(5.2)
We will frequently leave the expectation over these keys implicit: in other words, in the above example, we may
simply write


Tr[MùúìEnc(q)]‚àíTr[MùúìEnc(q‚Ä≤)]


 ‚â§ùúÇ(ùúÜ).
Whenever we have expressions that include both Enc and Dec, it is understood that both functions use the same keys,
i.e. that there is one global implicit expectation over keys. For example, when we write ‚à•O(Dec(ùõº))‚à•2
ùúìEnc(q)for some
observables O(¬∑) that depend on the decryption of a ciphertext ùõº, this is understood to mean
E
sk‚ÜêGen(ùúÜ)‚à•O(Decsk(ùõº))‚à•2
ùúìEncsk(q) ,
where, analogously to before, ùúìEncsk(q) := Ec‚ÜêEncsk(q) ùúìc. We usually use this convention for the squared norm, where
it is justified by the linearity property (Lemma 2.8 Item (iv)).
We record the following fact, which follows directly from the security of the QHE scheme used in the KLVY
compiler in Protocol 2, as defined in Definition 2.13.
Lemma 5.2. For any two Alice questions q1,q2 ‚ààQA,
ùúìEnc(q1) c
‚âàùúìEnc(q2) .
Measuring closeness of strategies.
In the analysis of a compiled nonlocal game, it often occurs that we wish to
show if we replace Bob‚Äôs measurements {By
b} with new measurements {Cy
b} that are close in the appropriate distance
metric, then the winning probability of the strategy is approximately preserved. Specifically, we will often measure
closeness in terms of the state-dependent norm on the post-measurement state, after Alice‚Äôs measurement has been
applied:
E
x,y‚àºDG‚àë
ùõº,y
‚à•By
b ‚àíCy
b‚à•2
ùúìEnc(x)
ùõº
‚â§ùúñ,
where DG is the distribution over questions sampled in the game.
In some special cases, Lemma 2.10 can be applied to relate this state-dependent distance bound to the winning
probability. Specifically, it applies for the case of unique games where every answer for Bob determines a unique
winning answer for Alice and vice versa; this lets us define ùúìi in the lemma to be Alice‚Äôs post-measurement state
for this unique outcome, which satisfies the condition ‚àëi Trùúìi ‚â§1. However, for general games, the situation is
more complicated, and there is a nice relation between state-dependent distance and success probability only if one
of the two strategies being compared consists of projective measurements. The following lemma, based on Fact 4.31
from [NW19], gives us the statement we will need.
29


Lemma 5.3. Let G be a nonlocal game, |ùúì‚ü©a state, {Ac
ùõº} be a collection of compiled Alice measurements, and {By
b}
and {Cy
b} be two collections of Bob measurements such that By
b is projective, and
E
x,y‚àºDG‚àë
ùõº‚àë
b
‚à•By
b ‚àíCy
b‚à•2
ùúìEnc(x)
ùõº
‚â§ùúñ,
where DG is the distribution over question pairs in the game. Then the success probabilities of the strategy using
(|ùúì‚ü©,{Ac
ùõº},{By
b}) and the strategy using (|ùúì‚ü©,{Ac
ùõº},{Cy
b}) are O(‚àöùúñ)-close.
Proof. Define
‚àÜy
b = Cy
b ‚àíBy
b.
For any c,ùõº,y, let S be a subset of Bob‚Äôs outcome space. Then we claim that
‚àë
b‚ààS
Tr[Cy
bùúìc
ùõº] ‚â•‚àë
b‚ààS
Tr[By
bùúìc
ùõº]‚àí2
r
‚àë
b‚ààS
‚à•‚àÜy
b‚à•2
ùúìc
ùõº.
(5.3)
Before we prove this claim, let us see why it implies the conclusion of the Lemma. For each c,ùõº,y, let Sc,ùõº,y be the
set of answers b such that (c,y,ùõº,b) is an accepting question and answer tuple for the compiled game verifier. Then
the success probability of the Bob strategy {Cy
b} is given by
ùúî‚àó({Cy
b}) =
E
x,y‚àºDG
E
c‚ÜêEnc(x)‚àë
ùõº
‚àë
b‚ààSb,ùõº,y
Tr[Cy
bùúìc
ùõº]
‚â•
E
x,y‚àºDG
E
c‚ÜêEnc(x)‚àë
ùõº
Ô£´
Ô£≠‚àë
b‚ààSb,ùõº,y
Tr[By
bùúìc
ùõº]‚àí2
s
‚àë
b‚ààS(b,ùõº,y)
‚à•‚àÜy
b‚à•2
ùúìc
ùõº
Ô£∂
Ô£∏
‚â•ùúî‚àó({By
b})‚àí2
E
x,y‚àºDG
E
c‚ÜêEnc(x)‚àë
ùõº
s
‚àë
b‚ààS(b,ùõº,y)
‚à•‚àÜy
b‚à•2
ùúìc
ùõº
‚â•ùúî‚àó({By
b})‚àí2
r
E
x,y‚àºDG
E
c‚ÜêEnc(x)‚àë
ùõº‚àë
b
‚à•‚àÜy
b‚à•2
ùúìc
ùõº
= ùúî‚àó({By
b})‚àí2‚àöùúñ.
Applying the same logic with Sc,y,ùõºtaken to be the set of rejecting Bob answers b yields the statement
1‚àíùúî‚àó({Cy
b}) ‚â•(1‚àíùúî‚àó({By
b}))‚àí2‚àöùúñ
ùúî‚àó({Cy
b}) ‚â§ùúî‚àó({By
b})+2‚àöùúñ.
Thus, the conclusion of the Lemma follows.
Now it remains to prove Equation (5.3). First, let us observe that
Cy
b ‚™∞(Cy
b)2
= By
b +(‚àÜy
b)2 +By
b‚àÜy
b +‚àÜy
bBy
b.
Here, the first line follows from the fact that, as a valid POVM element, CY
b ‚™ØI, and the second line uses the projectivity
of By
b to replace (By
b)2 by By
b. We will now prove Equation (5.3) by lower-bounding the success probability of a
30


‚Äúsubnormalized‚Äù strategy using the squared operators (Cy
b)2 as POVM elements.
‚àë
b‚ààS
Tr[Cy
bùúìc
ùõº] ‚â•‚àë
b‚ààS
Tr[(Cy
b)2ùúìc
ùõº]
= ‚àë
b‚ààS
Tr[By
bùúìc
ùõº]+ ‚àë
b‚ààS
‚à•‚àÜy
b‚à•2
ùúìc
ùõº+ ‚àë
b‚ààS
Tr[(By
b‚àÜy
b +‚àÜy
bBy
b)ùúìc
ùõº]
‚â•‚àë
b‚ààS
Tr[By
bùúìc
ùõº]‚àí2 ‚àë
b‚ààS
‚à•By
b(ùúìc
ùõº)1/2‚à•2‚à•‚àÜy
b(ùúìc
ùõº)1/2‚à•2
‚â•‚àë
b‚ààS
Tr[By
bùúìc
ùõº]‚àí2
r
‚àë
b‚ààS
‚à•By
b(ùúìc
ùõº)1/2‚à•2
2
r
‚àë
b‚ààS
‚à•‚àÜy
b(ùúìc
ùõº)1/2‚à•2
2
‚â•‚àë
b‚ààS
Tr[By
bùúìc
ùõº]‚àí2
r
‚àë
b‚ààS
‚à•‚àÜy
b‚à•2
ùúìc
ùõº.
Here, we used H√∂lder for the first inequality, Cauchy-Schwarz for the second, and the fact that {By
b} is a normalized
measurement for the third.
5.2
Modelling the prover in Protocol 2
We will also need to establish some notation specific to the prover‚Äôs ‚ÄòBob‚Äô operators in Protocol 2.
Definition 5.4 (Projective measurements).
(i) Pure basis measurements. In the Pauli braiding test (Protocol 4), and also in the b = 0 case of the mixed versus
pure basis test (Protocol 7), Bob is asked a single bit question corresponding to a basis setting (X or Z). For
each basis setting W ‚àà{X,Z}, we notate Bob‚Äôs projective measurement after receiving question W as a set of
projectors {PW
u }u with outcomes u ‚àà{0,1}n.
(ii) Mixed basis measurements. In the mixed versus pure basis test (Protocol 7), Bob receives a question w ‚àà
{1,X,Z}n corresponding to n Pauli basis settings (one for each of n qubits). For each Pauli string w ‚àà{1,X,Z}n,
we notate Bob‚Äôs projective measurement after receiving question w as a set of projectors {Mw
u }u‚àà{0,1}n. We can
assume without loss of generality that Bob always answers ‚Äú0‚Äù on indices where he was asked to measure the
identity, i.e. formally we can assume that Mw
u = 0 if there exists an index i ‚àà[n] for which wi = 1 but ui = 1.
The reason that this assumption is without loss of generality is that we can always replace Bob‚Äôs measurements
by a post-processed version that has this property; since the verifier ignores all indices for which wi = 1, this
post-processing affects neither Bob‚Äôs success probability nor any of the rigidity statements we show below.
Definition 5.5 (Pure basis observables). For W ‚àà{X,Z} and a ‚àà{0,1}n, define the binary observable
W(a) := ‚àë
u
(‚àí1)u¬∑aPW
u .
Definition 5.6 (Mixed basis observables). For w ‚àà{1,X,Z}n and a ‚àà{0,1}n, define the binary observables
Ow(a) =
‚àë
u‚àà{0,1}n
(‚àí1)a¬∑uMw
u ,
Ow
W(a) =
‚àë
u‚àà{0,1}n
(‚àí1)
‚Éó
1w=W‚àßa=1¬∑uMw
u .
We also write Ow = Ow(
‚Éó
1) and Ow
W = Ow
W(
‚Éó
1).
Remark 5.7. Recall that Mw
u = 0 if there exists an index i for which wi = 1 but ui = 1. This implies that if two bitstrings
a,a‚Ä≤ ‚àà{0,1}n only differ on indices i for which wi = 1, then Ow(a) = Ow(a‚Ä≤). By the same reasoning, if a,a‚Ä≤ ‚àà{0,1}n
only differ on indices i for which wi Ã∏= W, then Ow
W(a) = Ow
W(a‚Ä≤).
31


For the same reason, we can also restrict the sum over u only to those indices that matter, i.e. we can drop the sum
over those u for which Mw
u = 0. In particular, this yields another expression for Ow and Ow
W, which will occasionally
be more convenient to use:
Ow =
‚àë
u‚àà{0,1}|{uÃ∏=1}|
(‚àí1)
‚Éó
1¬∑u(Mw|{wÃ∏=1})u ,
Ow
W =
‚àë
u‚àà{0,1}|{w=W}|
(‚àí1)
‚Éó
1¬∑u(Mw|{w=W})u .
Lemma 5.8. For all w ‚àà{1,X,Z}n,
Ow = Ow
XOw
Z .
Proof. First observe that for any u ‚àà{0,1}|{wÃ∏=1}|,
(Mw|{w=X})u|{w=X}(Mw|{w=Z})u|{w=Z} =
Ô£´
Ô£≠
‚àë
a:a|{w=X}=u|{w=X}
Mw
a
Ô£∂
Ô£∏
Ô£´
Ô£≠
‚àë
b:b|{w=Z}=u|{w=Z}
Mw
b
Ô£∂
Ô£∏
=
‚àë
a s.t.
a|{w=X}=u|{w=X}
‚àßa|{w=Z}=u|{w=Z}
Mw
a
=
‚àë
a:a|{wÃ∏=1}=u
Mw
a
= (Mw|{wÃ∏=1})u .
Here, the second equality uses orthogonality of the projectors {Mw
a }a. With the expressions from Remark 5.7, we get
that
Ow
XOw
Z =
Ô£´
Ô£≠
‚àë
uX‚àà{0,1}|{w=X}|
(‚àí1)
‚Éó
1¬∑uX (Mw|{w=X})uX
Ô£∂
Ô£∏
Ô£´
Ô£≠
‚àë
uZ‚àà{0,1}|{w=Z}|
(‚àí1)
‚Éó
1¬∑uZ(Mw|{w=Z})uZ
Ô£∂
Ô£∏
=
‚àë
u‚àà{0,1}|{uÃ∏=1}|
(‚àí1)
‚Éó
1¬∑u(Mw|{w=X})u|{w=X}(Mw|{w=Z})u|{w=Z}
=
‚àë
u‚àà{0,1}|{uÃ∏=1}|
(‚àí1)
‚Éó
1¬∑u(Mw|{wÃ∏=1})u = Ow .
6
Analysis of the question-succinct protocol
6.1
Consistency test and ‚Äúprover switching‚Äù
The following lemma shows that the consistency test (the b = 0 case in Protocol 7 that just checks whether Alice‚Äôs and
Bob‚Äôs answers are consistent) implies that on Alice‚Äôs post-measurement state, Bob‚Äôs measurement in the same basis
has a definite outcome. This is formalised by saying that Bob‚Äôs measurement operator is close to identity (with a sign
indicating the outcome) on Alice‚Äôs post-measurement state.
Lemma 6.1. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1‚àíùúñin the
compiled version of Protocol 7. Then for all b ‚àà{0,1}n and W ‚àà{X,Z},
‚àë
ùõº



W(b)‚àí(‚àí1)Dec(ùõº)¬∑b1



2
ùúìEnc(W)
ùõº
‚â§O(ùúñ).
32


Proof. Expanding out the definition of the state-dependent distance, we see that it suffices to show that
E
c‚ÜêEnc(W)‚àë
ùõº
(‚àí1)Dec(ùõº)¬∑b Tr[W(b)Ac
ùõºùúìAc
ùõº] ‚â•1‚àíO(ùúñ).
The winning condition of the pure-basis case in Protocol 7 (i.e. the b = 0 case in the notation of Protocol 7) implies
E
c‚ÜêEnc(W)‚àë
ùõº
Tr[PW
Dec(ùõº)Ac
ùõºùúìAc
ùõº] ‚â•1‚àíO(ùúñ).
(6.1)
Since the prover‚Äôs measurements are normalised, this is equivalent to
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
vÃ∏=Dec(ùõº)
Tr[PW
v Ac
ùõºùúìAc
ùõº] ‚â§O(ùúñ).
(6.2)
Inserting the definition of W(b):
E
c‚ÜêEnc(W)‚àë
ùõº
(‚àí1)Dec(ùõº)¬∑b Tr[W(b)Ac
ùõºùúìAc
ùõº]
=
E
c‚ÜêEnc(W)‚àë
ùõº‚àë
v
(‚àí1)(Dec(ùõº)+v)¬∑b Tr[PW
v Ac
ùõºùúìAc
ùõº]
=
E
c‚ÜêEnc(W)‚àë
ùõº
Tr[PW
Dec(ùõº)Ac
ùõºùúìAc
ùõº]+
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
vÃ∏=Dec(ùõº)
(‚àí1)(Dec(ùõº)+v)¬∑b Tr[PW
v Ac
ùõºùúìAc
ùõº]
Since Tr[PW
v Ac
ùõºùúìAc
ùõº] ‚â•0:
‚â•
E
c‚ÜêEnc(W)‚àë
ùõº
Tr[PW
Dec(ùõº)Ac
ùõºùúìAc
ùõº]‚àí
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
vÃ∏=Dec(ùõº)
Tr[PW
v Ac
ùõºùúìAc
ùõº] ‚â•1‚àíO(ùúñ),
where in the last line we used Equation (6.1) to bound the first term and Equation (6.2) to bound the second term.
We can use Lemma 6.1 to show that Bob‚Äôs observables W(b) commute with Alice‚Äôs post-measurement state
ùúìEnc(W). This lemma can be seen as a substitute for the ‚Äúprover switching‚Äù technique from the non-local games
literature.
Lemma 6.2. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1‚àíùúñin the
compiled version of Protocol 7. Then for all b ‚àà{0,1}n and W ‚àà{X,Z},



W(b)ùúìEnc(W)W(b)‚àíùúìEnc(W)


1 ‚â§O(‚àöùúñ).
Proof. We first use the triangle inequality:



W(b)ùúìEnc(W)W(b)‚àíùúìEnc(W)


1
‚â§‚àë
ùõº



W(b)ùúìEnc(W)
ùõº
W(b)‚àíùúìEnc(W)
ùõº



1
‚â§‚àë
ùõº



W(b)ùúìEnc(W)
ùõº
W(b)‚àí(‚àí1)Dec(ùõº)¬∑bùúìEnc(W)
ùõº
W(b)



1 +



(‚àí1)Dec(ùõº)¬∑bùúìEnc(W)
ùõº
W(b)‚àíùúìEnc(W)
ùõº



1
For the first term, we use the unitary invariance of the 1-norm, and for the second term we use that the 1-norm is
invariant under taking the dagger (and W(b) and ùúìc
ùõºare Hermitian):
= ‚àë
ùõº



W(b)ùúìEnc(W)
ùõº
‚àí(‚àí1)Dec(ùõº)¬∑bùúìEnc(W)
ùõº



1 +



W(b)ùúìEnc(W)
ùõº
‚àí(‚àí1)Dec(ùõº)¬∑bùúìEnc(W)
ùõº



1
= 2‚àë
ùõº



(W(b)‚àí(‚àí1)Dec(ùõº)¬∑b)ùúìEnc(W)
ùõº



1
We can now apply Lemma 6.1 and Lemma 2.10:
‚â§O(‚àöùúñ).
33


6.2
Analysis of compiled Pauli braiding test: obtaining the group relations
Lemma 6.3. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1‚àíùúñin the
compiled version of Protocol 4. Then the prover‚Äôs observables satisfy the following properties for any Alice question
q ‚ààQA:
E
a,b‚àà{0,1}n



Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)



2
ùúìEnc(q) ‚â§O(ùúñ)+negl(ùúÜ).
(6.3)
To prove this lemma, we first examine what each subtest of the Pauli braiding test lets us conclude.
Lemma 6.4. Suppose a computationally efficient prover P succeeds with probability 1‚àíùúñin the compiled anticommut-
ation test (Protocol 6) with inputs ra,rb, and let Bra and Brb be the Bob observables corresponding to these questions.
Then for any Alice question x ‚ààQA, there exists a negligible function ùúÇ(ùúÜ) (depending on P and on x,ra,rb) such that
‚à•{Bra,Brb}‚à•2
ùúìEnc(x) ‚â§O(ùúñ)+ùúÇ(ùúÜ).
Proof. In Theorem 5.7 of [CMM+24], essentially the same statement is shown for the Magic Square game. In that the-
orem, it is shown that for the Bob‚Äôs observables B2,B4 used for cells 2 and 4 in the square, the expected anticommutator
is bounded by
E
sk ‚ÜêGen(1ùúÜ)
E
c‚ÜêEnc(x)‚àë
ùõº
‚à•{B2,B4}|ùúìc
ùõº‚ü©‚à•2
2 ‚â§17280ùúñ+ùúÇ(ùúÜ).
In our setting, B2 = Bra and B4 = Brb, and the quantity on the left-hand side is exactly the average squared state-
dependent norm, by Definition 2.6.
Lemma 6.5 (Lemma 23 of [NZ23a]). Suppose a computationally efficient prover P modelled as in Section 5 succeeds
with probability 1 ‚àíùúñin the compiled commutation test (Protocol 5) with inputs ra,rb, and let Bra,Brb be Bob‚Äôs
observables corresponding to the questions ra,rb. Then for any Alice question x ‚ààQA, there exists a negligible
function ùúÇ(ùúÜ) (depending on P and on x,ra,rb) such that
‚à•[Bra,Brb]‚à•2
ùúìEnc(x) ‚â§O(ùúñ)+ùúÇ(ùúÜ).
Proof. Lemma 23 of [NZ23a] shows that, for all (ra,rb),
‚à•[Bra,Brb]‚à•2
ùúìEnc((com,ra,rb)) ‚â§O(ùúñ).
To obtain the conclusion of the lemma, it suffices to use computational indistinguishability together with the fact that
the commutator is efficiently measurable, which follows from Lemma 2.12.
Proof of Lemma 6.3. We are given that P succeeds with probability 1‚àíùúñin Protocol 4. This means that it holds that
‚àë
a,b‚ààS:a¬∑b=0
1
|S|2 ¬∑(1‚àíPr[P passes commutation on Z(a),X(b)])
+
‚àë
a,b‚ààS:a¬∑b=1
1
|S|2 ¬∑(1‚àíPr[P passes anticommutation on Z(a),X(b)])
‚â§ùúñ.
For any given a,b, suppose a¬∑b = 0, and let 1‚àíùúña,b = Pr[P passes commutation on Z(a),X(b)]. Then by Lemma 6.5,
it holds that
‚à•[Z(a),X(b)]‚à•2
ùúìEnc(q) ‚â§O(ùúña,b)+ùúÇa,b(ùúÜ),
and O(¬∑) is a convex function.
Likewise, suppose a¬∑b = 1, and let 1‚àíùúña,b = Pr[P passes anticommutation on Z(a),X(b)]. Then by Lemma 6.4,
it holds that
‚à•{Z(a),X(b)}‚à•2
ùúìEnc(q) ‚â§O(ùúña,b)+ùúÇa,b(ùúÜ),
34


and O(¬∑) is a convex function.
Putting these relations together, we have
‚àë
a,b‚ààS
1
|S|2 ‚à•Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)‚à•2
ùúìEnc(q) ‚â§O(ùúñ)+ùúÇ(ùúÜ),
where ùúÇ(ùúÜ) = maxa,b ùúÇa,b(ùúÜ). Finally, applying Corollary 3.6, we get
E
a,b‚àà{0,1}n ‚à•Z(a)X(b)‚àí(‚àí1)a¬∑bX(b)Z(a)‚à•2
ùúìEnc(q) ‚â§
1
(1‚àíùúÜ)2 O(ùúñ)+ùúÇ‚Ä≤(ùúÜ),
where ùúÇ‚Ä≤ is some negligible function. Here we have used that ùúìEnc(q) c
‚âànegl Ea‚ààSW(a)ùúìEnc(q)W(a) for W ‚àà{X,Z},
which follows from Lemma 6.2.
6.3
Analysis of compiled mixed-vs-pure basis test
Theorem 6.6. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1 ‚àíùúñin
both Protocol 4 and Protocol 7. Then there exists a Hilbert space H‚Ä≤ = C2n ‚äóHaux (where n is the number of qubits
an honest prover would use) and an isometry V : H ‚ÜíH‚Ä≤ such that for every Alice question q ‚ààQA
E
w‚àºD
E
a‚àà{0,1}n ‚à•Ow(a)‚àíV ‚Ä†(ùúéw(a)‚äó1aux)V‚à•2
ùúìEnc(q) ‚â§O(‚àöùúñ)+negl(ùúÜ).
Theorem 6.6 also implies that the prover‚Äôs projective measurements {Mw
u } in the mixed vs pure basis test must
be close to the corresponding Pauli projectors. More formally, we show the following statement about the prover‚Äôs
measurements.
Corollary 6.7. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1 ‚àíùúñin
both Protocol 4 and Protocol 7. Then there exists a Hilbert space H‚Ä≤ = C2n ‚äóHaux (where n is the number of qubits an
honest prover would use) and an isometry V : H ‚ÜíH‚Ä≤ such that for every Alice question q ‚ààQA, and for any subset
S ‚äÜ{0,1}n,
E
w‚àºD ‚àë
u‚ààS
‚à•Mw
u ‚àíV ‚Ä†(ùúãw
u ‚äó1aux)V‚à•2
ùúìEnc(q) ‚â§O(‚àöùúñ)+negl(ùúÜ).
(6.4)
Here, {Mw
u } are the prover‚Äôs measurements in the mixed vs pure basis test, and ùúãw
a are the Pauli projectors, i.e.
ùúãw
u =
O
i
1+(‚àí1)uiùúéwi
2

=
E
a‚àà{0,1}n(‚àí1)u¬∑aùúéw(a).
Proof. Since each of the terms in Equation (6.4) is non-negative, it suffices to show this for S = {0,1}n. Recall that
for any a ‚àà{0,1}n,
Ow(a) =
‚àë
u‚àà{0,1}n
(‚àí1)a¬∑uMw
u .
In other words, Ow(a) and {Mw
u }u are related by a Fourier transform. We can invert this Fourier transform to get that
Mw
u =
E
a‚àà{0,1}n(‚àí1)u¬∑aOw(a).
The proof now is essentially that of Parseval‚Äôs identity, but we spell out the details for completeness: inserting this and
35


the expansion of ùúãw
u in terms of Pauli observables, we get that for any w ‚àà{1,X,Z}n,
‚àë
u‚àà{0,1}n
‚à•Mw
u ‚àíV ‚Ä†(ùúãw
u ‚äó1aux)V‚à•2
ùúìEnc(q) =
‚àë
u‚àà{0,1}n
‚à•
E
a‚àà{0,1}n(‚àí1)u¬∑a Ow(a)‚àíV ‚Ä†(ùúéw(a)‚äó1aux)V

|
{z
}
:=Œì(a)
‚à•2
ùúìEnc(q)
=
‚àë
u‚àà{0,1}n

E
a‚àà{0,1}n(‚àí1)u¬∑aŒì(a),
E
a‚Ä≤‚àà{0,1}n(‚àí1)u¬∑aŒì(a‚Ä≤)

ùúìEnc(q)
=
E
a,a‚Ä≤‚àà{0,1}n
 
‚àë
u‚àà{0,1}n
(‚àí1)u¬∑(a+a‚Ä≤)
!

Œì(a),Œì(a‚Ä≤)

ùúìEnc(q)
=
E
a,a‚Ä≤‚àà{0,1}n 2nùõøa,a‚Ä≤ 
Œì(a),Œì(a‚Ä≤)

ùúìEnc(q)
=
E
a‚àà{0,1}n ‚à•Œì(a)‚à•2
ùúìEnc(q)
=
E
a‚àà{0,1}n ‚à•Ow(a)‚àíV ‚Ä†(ùúéw(a)‚äó1aux)V‚à•2
ùúìEnc(q)
Here, ‚ü®¬∑,¬∑‚ü©ùúìis the state-dependent inner product defined in Definition 2.6. Taking V to be the isometry from The-
orem 6.6 and inserting the expectation over w ‚àºD, the result now follows directly from Theorem 6.6.
Before proving Theorem 6.6, we introduce a piece of notation that will be useful throughout the rest of the section.
Definition 6.8. Let D be the distribution over Pauli strings in {1,X,Z}n from Protocol 7. Then we define D‚Ä≤ to be
distribution over Pauli strings in {1,X,Z}n induced by the following sampling procedure: to sample w‚Ä≤ ‚àºD‚Ä≤, first
sample w ‚àºD and a ‚àº{0,1}n, then set
w‚Ä≤
i =
(
wi
if ai = 1,
1
otherwise.
The utility of this notation is that we can now collapse the expectations Ew‚àºD Ea‚àº{0,1}n into one expectation.
Concretely, this allows us to restate the conclusion of Theorem 6.6 as
E
w‚àºD‚Ä≤ ‚à•Ow ‚àíV ‚Ä†(ùúéw ‚äó1aux)V‚à•2
ùúìEnc(q) ‚â§O(‚àöùúñ).
(6.5)
Proof of Theorem 6.6. We will show that Equation (6.5) holds.
By the triangle inequality for the squared norm
(Lemma 2.8 Item (v)) we have that
E
w‚àºD‚Ä≤ ‚à•Ow ‚àíV ‚Ä†(ùúéw ‚äóId)V‚à•2
ùúìEnc(q)
‚â§2 E
w‚àºD‚Ä≤


Ow ‚àíX(1{w=X})Z(1{w=Z})


2
ùúìEnc(q) +2 E
w‚àºD‚Ä≤


X(1{w=X})Z(1{w=Z})‚àíV ‚Ä†(ùúéw ‚äóId)V


2
ùúìEnc(q) .
The first term is at most O(‚àöùúñ) by Lemma 6.11, which we prove below. The second term is at most O(ùúñ) by combining
Lemma 6.3 and Lemma 3.3.
It remains to prove Lemma 6.11. For this, we first establish a few auxiliary lemmas.
Lemma 6.9. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1 ‚àíùúñin
Protocol 7. Then for all W ‚àà{X,Z},
E
w‚àºD‚Ä≤‚àë
ùõº



Ow
W ‚àí(‚àí1)Dec(ùõº)¬∑1{w=W}1



2
ùúìEnc(W)
ùõº
‚â§O(ùúñ).
36


Proof. The proof is similar to Lemma 6.1. Expanding out the definition of the state dependent distance, we see that it
suffices to show
E
w‚àºD‚Ä≤
E
c‚ÜêEnc(W)‚àë
ùõº
(‚àí1)Dec(ùõº)¬∑1{w=W} Tr[Ow
ZAc
ùõºùúìAc
ùõº] ‚â•1‚àíO(ùúñ).
Recalling the definition of D‚Ä≤ from Definition 6.8, this is equivalent to
E
w‚àºD
E
a‚àº{0,1}n
E
c‚ÜêEnc(W)‚àë
ùõº
(‚àí1)Dec(ùõº)¬∑1{w=W‚àßa=1} Tr[Ow
Z(a)Ac
ùõºùúìAc
ùõº] ‚â•1‚àíO(ùúñ).
(6.6)
The winning condition of Protocol 7 implies that
E
w‚àºD
E
c‚ÜêEnc(W)‚àë
ùõº
Tr[(Mw|{w=W}])Dec(ùõº)|{w=W}Ac
ùõºùúìAc
ùõº] ‚â•1‚àíO(ùúñ).
(6.7)
We now need to use Equation (6.7) to show Equation (6.6). For this, first recall that
Ow
W(a) =
‚àë
u‚àà{0,1}n
(‚àí1)
‚Éó
1w=W‚àßa=1¬∑uMw
u .
Inserting this definition into the l.h.s. of Equation (6.6), we get that
E
w‚àºD
E
a‚àº{0,1}n
E
c‚ÜêEnc(W)‚àë
ùõº
(‚àí1)Dec(ùõº)¬∑
‚Éó
1{w=W‚àßa=1} Tr[Ow
Z(a)Ac
ùõºùúìAc
ùõº]
= E
w‚àºD
E
a‚àº{0,1}n
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
u‚àà{0,1}n
(‚àí1)(Dec(ùõº)+u)¬∑
‚Éó
1{w=W‚àßa=1} Tr[Mw
u Ac
ùõºùúìAc
ùõº]
We now split the sum over u into the terms for which u|{w=W‚àßa=1} = Dec(ùõº)|{w=W‚àßa=1} and the remaining terms, and
note that the phase (‚àí1)(Dec(ùõº)+u)¬∑
‚Éó
1{w=W‚àßa=1} disappears when u|{w=W‚àßa=1} = Dec(ùõº)|{w=W‚àßa=1}:
= E
w‚àºD
E
a‚àº{0,1}n
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
u‚àà{0,1}n s.t.
u|{w=W‚àßa=1}=Dec(ùõº)|{w=W‚àßa=1}
Tr[Mw
u Ac
ùõºùúìAc
ùõº]
+ E
w‚àºD
E
a‚àº{0,1}n
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
u‚àà{0,1}n s.t.
u|{w=W‚àßa=1}Ã∏=Dec(ùõº)|{w=W‚àßa=1}
(‚àí1)(Dec(ùõº)+u)¬∑
‚Éó
1{w=W‚àßa=1} Tr[Mw
u Ac
ùõºùúìAc
ùõº]
For the second term we note that the trace expression is always non-negative, so we can bound
‚â•E
w‚àºD
E
a‚àº{0,1}n
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
u‚àà{0,1}n s.t.
u|{w=W‚àßa=1}=Dec(ùõº)|{w=W‚àßa=1}
Tr[Mw
u Ac
ùõºùúìAc
ùõº]
‚àíE
w‚àºD
E
a‚àº{0,1}n
E
c‚ÜêEnc(W)‚àë
ùõº
‚àë
u‚àà{0,1}n s.t.
u|{w=W‚àßa=1}Ã∏=Dec(ùõº)|{w=W‚àßa=1}
Tr[Mw
u Ac
ùõºùúìAc
ùõº]
Using the normalisation of the measurements, we can see that (second term) = 1 - (first term). Using this and changing
the order of sums and expectations, we can simplify this to
=

2
E
c‚ÜêEnc(W)‚àë
ùõº
E
w‚àºD
E
a‚àº{0,1}n
‚àë
u‚àà{0,1}n s.t.
u|{w=W‚àßa=1}=Dec(ùõº)|{w=W‚àßa=1}
Tr[Mw
u Ac
ùõºùúìAc
ùõº]

‚àí1
Restricting the sum over u to a subset of the summands and using that each summand Tr[Mw
u Ac
ùõºùúìAc
ùõº] is non-negative,
we can bound
‚â•

2
E
c‚ÜêEnc(W)‚àë
ùõº
E
w‚àºD
E
a‚àº{0,1}n
‚àë
u‚àà{0,1}n s.t.
u|{w=W}=Dec(ùõº)|{w=W}
Tr[Mw
u Ac
ùõºùúìAc
ùõº]

‚àí1
37


Since there is no remaining dependence on a, we can simply remove the expectation over a. We can also rewrite this
more compactly using the notation from Definition 2.5:
=

2
E
c‚ÜêEnc(W)‚àë
ùõº
E
w‚àºDTr[(Mw|{w=W})Dec(ùõº)|{w=W}Ac
ùõºùúìAc
ùõº]

‚àí1
Finally, we note that the term in parentheses is bounded in Equation (6.7), so we get
‚â•1‚àíO(ùúñ).
This proves Equation (6.6).
Lemma 6.10. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1 ‚àíùúñin
Protocol 7. Then for all W ‚àà{X,Z},
E
w‚àºD‚Ä≤


W(1{w=W})‚àíOw
W


2
ùúìEnc(W) = O(ùúñ).
Proof. By Lemma 2.8 Item (iv):
E
w‚àºD‚Ä≤


W(1{w=W})‚àíOw
W


2
ùúìEnc(W)
= E
w‚àºD‚Ä≤‚àë
ùõº


W(1{w=W})‚àíOw
W


2
ùúìEnc(W)
ùõº
By Lemma 2.8 Item (v):
‚â§2 E
w‚àºD‚Ä≤‚àë
ùõº



W(1{w=W})‚àí(‚àí1)Dec(ùõº)¬∑1{w=W}1



2
ùúìEnc(W)
ùõº
+2 E
w‚àºD‚Ä≤‚àë
ùõº



Ow
W ‚àí(‚àí1)Dec(ùõº)¬∑1{w=W}1



2
ùúìEnc(W)
ùõº
These are exactly the terms we bounded in Lemma 6.1 (which holds for every choice of w and consequently also in
expectation over w ‚àºD‚Ä≤) and Lemma 6.9, so we get:
= O(ùúñ).
We are now in a position to prove Lemma 6.11, the missing ingredient in the proof of Theorem 6.6.
Lemma 6.11. Suppose a computationally efficient prover P modelled as in Section 5 wins with probability 1 ‚àíùúñin
both Protocol 4 and Protocol 7. Then for any Alice question q ‚ààQA,
E
w‚àºD‚Ä≤


Ow ‚àíX(1{w=X})Z(1{w=Z})


2
ùúìEnc(q) = O(‚àöùúñ)+negl(ùúÜ).
Proof. By Lemma 5.2, for all q ‚ààQA we have that ùúìEnc(q) c
‚âànegl(ùúÜ) ùúìEnc(Z). We can therefore use Lemma 2.12 to get
that
E
w‚àºD‚Ä≤


Ow ‚àíX(1{w=X})Z(1{w=Z})


2
ùúìEnc(q)
‚â§E
w‚àºD‚Ä≤


Ow ‚àíX(1{w=X})Z(1{w=Z})


2
ùúìEnc(Z) +negl(ùúÜ)
By Lemma 6.2 and Lemma 2.9:
‚â§E
w‚àºD‚Ä≤


Ow ‚àíX(1{w=X})Z(1{w=Z})


2
Ea‚àà{0,1}n Z(a)ùúìEnc(Z)Z(a) +negl(ùúÜ)+O(‚àöùúñ)
38


By Lemma 2.8 Item (iv) and Lemma 2.8 Item (i):
= E
w‚àºD‚Ä≤
E
a‚àà{0,1}n


OwZ(a)‚àíX(1{w=X})Z(1{w=Z} +a)


2
ùúìEnc(Z) +negl(ùúÜ)+O(‚àöùúñ)
Since the expectation over a is uniform, we can shift it by 1{w=Z}:
= E
w‚àºD‚Ä≤
E
a‚àà{0,1}n


OwZ(1{w=Z} +a)‚àíX(1{w=X})Z(a)


2
ùúìEnc(Z) +negl(ùúÜ)+O(‚àöùúñ)
= E
w‚àºD‚Ä≤
E
a‚àà{0,1}n


OwZ(1{w=Z})Z(a)‚àíX(1{w=X})Z(a)


2
ùúìEnc(Z) +negl(ùúÜ)+O(‚àöùúñ)
Now performing the same steps in reverse:
= E
w‚àºD‚Ä≤
E
a‚àà{0,1}n


OwZ(1{w=Z})‚àíX(1{w=X})


2
Z(a)ùúìEnc(Z)Z(a) +negl(ùúÜ)+O(‚àöùúñ)
‚â§E
w‚àºD‚Ä≤


OwZ(1{w=Z})‚àíX(1{w=X})


2
ùúìEnc(Z) +negl(ùúÜ)+O(‚àöùúñ)
From Lemma 5.8 we have that Ow = Ow
XOw
Z. Inserting this and using Lemma 2.8 Item (iii), we get that:
= E
w‚àºD‚Ä≤


Ow
ZZ(1{w=Z})‚àíOw
XX(1{w=X})


2
ùúìEnc(Z) +negl(ùúÜ)+O(‚àöùúñ)
By Lemma 2.8 Item (v):
‚â§2 E
w‚àºD‚Ä≤


Ow
ZZ(1{w=Z})‚àí1


2
ùúìEnc(Z) +


Ow
XX(1{w=X})‚àí1


2
ùúìEnc(Z) +negl(ùúÜ)+O(‚àöùúñ)
By Lemma 2.8 Item (iii):
‚â§2 E
w‚àºD‚Ä≤


Z(1{w=Z})‚àíOw
Z


2
ùúìEnc(Z) +


X(1{w=X})‚àíOw
X


2
ùúìEnc(Z) +negl(ùúÜ)+O(‚àöùúñ)
By Lemma 6.10:
‚â§negl(ùúÜ)+O(‚àöùúñ).
6.4
Subsampled Hamiltonian
Definition 6.12 (Hamiltonian problem). We refer to a tuple of the form (H,ùõº, ùõΩ), where H is a Hermitian operator
and ùõºand ùõΩare both real numbers, as a Hamiltonian problem. We may refer to such a tuple where H acts on n qubits
as n-qubit Hamiltonian problems.
Definition 6.13 (deciding a Hamiltonian problem). Given a tuple of the form (H,ùõº, ùõΩ), where H is a Hermitian
operator and ùõºand ùõΩare both real numbers, we refer to the problem of deciding whether the ground energy of H is
‚â§ùõº(yes case) or ‚â•ùõΩ(no case) as the problem of deciding (H,ùõº, ùõΩ).
Definition 6.14 (family of Hamiltonians). We will use the notation H = {H(n)}n‚ààN to refer to a family of Hamilto-
nians, i.e., a collection of sets H(n) (one for every value of n ‚ààN) such that the nth set H(n) contains only n-qubit
Hamiltonian problems. We assume that the length of the binary description of (H,ùõº, ùõΩ) for any (H,ùõº, ùõΩ) ‚ààH(n) is
poly(n).
Definition 6.15 (QMA-completeness of a family of Hamiltonians). We say a family of Hamiltonians H = {H(n)}n‚ààN
is QMA-complete if, for every promise problem A = (Ayes,Ano) in QMA, and every instance x ‚àà{0,1}‚àó, the problem
of deciding whether x ‚ààAyes or x ‚ààAno can be Karp reduced in polynomial time (in |x|, given as input x and also the
algorithm C which characterises the verifier for A) to the problem of deciding some element of H(n) for n = poly(|x|).
39


Definition 6.16 (2-local X/Z Hamiltonian family with inverse polynomial promise gap). A 2-local X/Z Hamiltonian
family is a family of Hamiltonians where H(n) contains only (H,ùõº, ùõΩ) such that H is a sum of at most m(n) terms for
m(n) = poly(n), each one of which is an n-qubit tensor product of ùúéZ, ùúéX and 1 such that at most 2 of the n factors in
the tensor product are not 1. If, in addition, the tuples in H(n) all have the same values of ùõºand ùõΩ(for every n), and it
is the case that ùõΩ(n)‚àíùõº(n) (where ùõºand ùõΩare considered as functions of n) is lower bounded by
1
poly(n), then we say
H = {H(n)}n‚ààN is a 2-local X/Z Hamiltonian family with inverse-polynomial promise gap.
Lemma 6.17. There is a family of 2-local X/Z Hamiltonians with inverse-polynomial promise gap which is QMA-
complete.
Proof. This is Theorem 2 of [BL08].
Lemma 6.18. Let H = {H(n)}n‚ààN be a QMA-complete 2-local X/Z Hamiltonian family. Then there exists a poly-
nomial t(n) (the amplification parameter) such that deciding any (H,ùõº(n), ùõΩ(n)) ‚ààH(n) can be efficiently reduced
to deciding a problem of the form (H‚Ä≤,ùõº‚Ä≤(n), ùõΩ‚Ä≤(n)), where there exists a negligible function negl(¬∑) such that ùõΩ‚Ä≤(n)‚àí
ùõº‚Ä≤(n) ‚â•1‚àínegl(n), and H‚Ä≤ (which acts on t(n)¬∑n qubits) has the following form:
H‚Ä≤ = 1‚àíE
w‚àºD ‚àë
a‚ààT(w)
ùúãw
a
where D is a distribution over {1,X,Z}t(n)¬∑n which can be efficiently sampled from, and membership in T(w) ‚äÜ
{0,1}t(n)¬∑n can be decided in time polynomial in n given w.
Proof. We do this reduction in two stages. Firstly, we note that instead of taking a 2-local X/Z Hamiltonian problem
(H,ùõº(n), ùõΩ(n)) as our starting point, we can take a tuple (H‚Ä≤‚Ä≤,ùõº‚Ä≤‚Ä≤(n), ùõΩ‚Ä≤‚Ä≤(n)) where H‚Ä≤‚Ä≤ is in the form
H‚Ä≤‚Ä≤ = 1‚àíE
w‚àºD‚Ä≤‚Ä≤ ‚àë
a‚ààS(w)
ùúãw
a
where D‚Ä≤‚Ä≤ is an efficiently sampleable distribution over {1,X,Z}n, and S(w) ‚äÜ{0,1}n is a set for which membership
can be decided efficiently given w. (The ‚Äò1‚àí‚Äô is merely to make sure that the yes case is the low-energy case.) The
promise gap will decrease at most by a factor of
1
poly(n) as a result of this conversion (so that ùõΩ‚Ä≤‚Ä≤(n)‚àíùõº‚Ä≤‚Ä≤(n) is still at
least
1
poly(n)). To get H‚Ä≤‚Ä≤, we will use the Morimae-Fitzsimons energy test [MF16]. This procedure will have an inverse-
polynomial promise gap if the original Hamiltonian had an inverse-polynomial promise gap and constant locality, as
Morimae and Fitzsimons calculate. It is straightforward to see that the success probability of the procedure on any
given pure state |ùúì‚ü©can be expressed as 1‚àí‚ü®ùúì|H‚Ä≤‚Ä≤|ùúì‚ü©for some H‚Ä≤‚Ä≤ of the form above.
Then, to amplify the gap, we apply the technique from Lemma 14.1 in Kitaev, Shen and Vyalyi [KSV02] to H‚Ä≤‚Ä≤,
to obtain the desired Hamiltonian H‚Ä≤. The amplification technique is to measure a independent randomly chosen term
from H‚Ä≤‚Ä≤ on t(n) many n-qubit registers, and to accept if the number of accepting outcomes is above a certain threshold.
Concretely,
H‚Ä≤ = 1‚àíE
w‚àºD ‚àë
a‚ààT(w)
ùúãw
a ,
where D = (D‚Ä≤‚Ä≤)‚äót(n), and T(w) is defined implicitly by the following algorithm to decide membership in it:
(i) Divide up the answer string a into t(n) blocks Bi of n bits each. Also divide up w into t(n) blocks wi such that
each wi is in {1,X,Z}n.
(ii) For each block Bi,i ‚àà[t(n)], compute the quantity (in {‚àí1,+1}, for notational convenience) bi = (‚àí1)1[a|Bi‚ààS(wi)].
This results in t(n) quantities b1,¬∑¬∑¬∑ ,bt(n) ‚àà{‚àí1,+1}.
(iii) a is in T(w) iff
t(n)
‚àë
i=1
bi < t(n)¬∑ ùõº‚Ä≤‚Ä≤(n)+ ùõΩ‚Ä≤‚Ä≤(n)
2
.
40


It is clear that this algorithm runs in time poly(n). As for the condition on eigenvalues of H‚Ä≤, it is shown in [KSV02]
that the bound ùõΩ‚Ä≤(n)‚àíùõº‚Ä≤(n) ‚â•1‚àínegl(n) holds if t(n) is chosen to be polynomial in n.
Lemma 6.19. Fix a PRG family F = { fùúÜ: {0,1}ùúÜ‚Üí{0,1}ùúÜ}ùúÜ‚ààN. Assuming that F is secure against (non-uniform)
QPT adversaries, and for any function ‚Ñì(¬∑) such that ‚Ñì(x) = ùúî(log(x)), there exists a PRG family G = {gùúÜ: {0,1}‚Ñì(ùúÜ) ‚Üí
{0,1}ùúÜ}ùúÜ‚ààN which is secure against (non-uniform) QPT adversaries.
Proof. Standard arguments to show that PRGs can be used to construct PRFs [GGM86] suffice.
Theorem 6.20. Let H = {H(n)}n‚ààN be a QMA-complete 2-local X/Z Hamiltonian family.
Then there exists a
polynomial t(n) (the amplification parameter) such that deciding any (H,ùõº(n), ùõΩ(n)) ‚ààH(n) can be efficiently re-
duced to deciding a problem of the form (H‚Ä≤,ùõº‚Ä≤(n), ùõΩ‚Ä≤(n)), where there exists a negligible function negl(¬∑) such that
ùõΩ‚Ä≤(n)‚àíùõº‚Ä≤(n) ‚â•1‚àínegl(n), and H‚Ä≤ (which acts on t(n)¬∑n qubits) has the following form:
H‚Ä≤ = 1‚àíE
w‚àºD ‚àë
a‚ààT(w)
ùúãw
a
where membership in T(w) ‚äÜ{0,1}t(n)¬∑n can be decided in time polynomial in n given w, and D is a distribution over
{1,X,Z}t(n)¬∑n which can be efficiently sampled from using sampling randomness of length 2polylog(n).
Proof. Fix a PRG family G = {gùúÜ: {0,1}‚Ñì(ùúÜ) ‚Üí{0,1}ùúÜ}ùúÜ‚ààN with ‚Ñì(ùúÜ) = polylog(ùúÜ) which is secure against non-
uniform QPT adversaries. (Such a family exists by Lemma 6.19.) Take an X/Z Hamiltonian family H = {H(n)}n‚ààN
with gap ùõΩ(n) ‚àíùõº(n) = 1 ‚àínegl(n) which is QMA-complete, such that any H such that (H,ùõº(n), ùõΩ(n)) ‚ààH(n) is a
Hamiltonian on t(n)¬∑n qubits with the following form:
H = 1‚àíE
w‚àº‚àÜ‚àë
a‚ààT(w)
ùúãw
a
(6.8)
where ‚àÜis a distribution over {1,X,Z}t(n)¬∑n which can be efficiently sampled from, and membership in T(w) ‚äÜ
{0,1}t(n)¬∑n can be decided in time polynomial in n given w. (Such a family exists by Lemma 6.18.)
The following algorithm accepts any given state ùúåwith probability exactly 1‚àíTr[Hùúå]:
Process 1.
(i) Sample w from D. We will assume this takes R(n) bits of randomness for some polynomial R.
(ii) Measure every qubit of ùúåin the Pauli bases determined by w. Let the outcome be a ‚àà{0,1}t(n)¬∑n.
(iii) Accept iff a ‚ààT(w).
Now consider the following derandomised version of this algorithm:
Process 2 (Derandomised version of Process 1).
(i) Use the PRG g‚Ñì(R(n)) (i.e. the ‚Ñì(R(n))th PRG in the family G) in order to generate a pseudorandom seed s of
length R(n) using ‚Ñì(R(n)) bits of true randomness. Use s to sample w from D.
(ii) Measure every qubit of ùúåin the Pauli bases determined by w. Let the outcome be a ‚àà{0,1}t(n)¬∑n.
(iii) Accept iff a ‚ààT(w).
It is clear that this algorithm accepts any given state ùúåwith probability exactly 1 ‚àíTr[H‚Ä≤ùúå], where H‚Ä≤ is the
following Hamiltonian:
H‚Ä≤ = 1‚àíE
w‚àºD ‚àë
a‚ààT(w)
ùúãw
a
(6.9)
41


where we define D to be the distribution which step (i) in Process 2 samples from. Since R is a polynomial and
‚Ñì(n) = polylog(n), this setting of parameters yields sampling randomness for D of 2polylog(n), as desired.
Now we show that there exist ùõº‚Ä≤(¬∑), ùõΩ‚Ä≤(¬∑) with ùõΩ‚Ä≤(n)‚àíùõº‚Ä≤(n) ‚â•1‚àíùúá(n) for some negligible function ùúá(¬∑) such that
the problem of deciding H‚Ä≤ is QMA-complete. Consider a sequence of Hamiltonians {H(n) : n ‚ààN} such that, for all
n, (H(n),ùõº(n), ùõΩ(n)) ‚ààH(n). (We fix a single Hamiltonian per value of n for notational simplicity; the same argument
can be applied to all the elements of H(n).) For each n, let H‚Ä≤(n) be the Hamiltonian defined by the ‚Äòsubsampling‚Äô
procedure above applied to H(n), i.e. the Hamiltonian defined in Equation (6.9). We will show that there exists a
negligible function negl(¬∑) such that the lowest eigenvalue of H‚Ä≤(n) differs from the lowest eigenvalue of H(n) by at
most a negl(n) amount.
Suppose, for contradiction‚Äôs sake, that this is not the case; then, defining v(n) to be the lowest eigenvalue of H(n)
and v‚Ä≤(n) to be the lowest eigenvalue of H‚Ä≤(n), (wlog) it is the case that v‚Ä≤(n) ‚àív(n) ‚â•p(n) for some non-negligible
function p(n). Then we construct a QPT adversary A taking non-uniform quantum advice which can break the security
of G. Let r(¬∑) be a sufficiently large polynomial, to be set later. We assume (wlog by standard reductions) that, on
input security parameter ùúÜ, A either receives a challenge consisting of r(ùúÜ) samples from the range of the PRG gùúÜ
or r(ùúÜ) uniformly random strings of length ùúÜ. On input security parameter ùúÜ, A gets as advice the following. Let n
be such that R(n) = ùúÜ. A gets r(ùúÜ) many copies of a ground state for the Hamiltonian H(n); the value of v(n), the
lowest eigenvalue of H(n); and the value of p(n) = v‚Ä≤(n) ‚àív(n). It then receives its challenge strings s1,...,sr, and
does the following for each string si: use si to sample a term from H(n); measure this term of H(n) on the ith copy
of the ground state it was given as advice; compute the average of all its measurement outcomes; output ‚ÄòPRG‚Äô if the
average is greater than v(n)+ p(n)
2 , and ‚Äòuniform‚Äô otherwise.
This procedure is clearly polynomial time in ùúÜ. We now analyse A‚Äôs success probability. In the case where s
is a uniformly random string, the average energy of a term in H(n) measured against the ground state of H(n) is at
most v(n). Then, by a Chernoff bound, the probability that A guesses wrongly in this case is upper bounded by the
following calculation (letting X be the random variable associated with the sum of A‚Äôs measurement outcomes):
Pr[X ‚â•(1+ ùõø)ùúá] ‚â§exp

‚àí2ùõø2ùúá2
r(ùúÜ)

Pr[X ‚â•(v(n)+ 1
2 p(n))r(ùúÜ)] ‚â§exp

‚àí2
1
2
p(n)
v(n)
2
¬∑(v(n)¬∑r(ùúÜ))2/r(ùúÜ)

‚â§exp
1
2 p(n)2r(ùúÜ)

.
Therefore, setting r(ùúÜ) to be a sufficiently large polynomial (i.e. sufficiently larger than
1
p(n)
2), we can ensure that the
probability that A guesses wrongly in the uniform case is negligible.
The calculation for the PRG case is similar. By a union bound, then, we can conclude that A distinguishes between
the PRG and the uniform cases with 1 ‚àínegl(ùúÜ) probability, which contradicts the non-uniform security of the PRG
family G. It follows that the lowest eigenvalue of H‚Ä≤(n) differs from the lowest eigenvalue of H(n) by at most a negl(n)
amount.
Theorem 6.21. Let C be a QMA verification algorithm for a QMA promise problem A = (Ayes,Ano), and let x be an
input of length n. Then there is a Hamiltonian problem (H,ùõº(n), ùõΩ(n)) that can be efficiently computed from the input
(x,C), such that if x ‚ààAyes, then H is a YES instance of the Hamiltonian problem, and if x ‚ààAno, then H is a NO
instance, and ùõΩ(n)‚àíùõº(n) = 1‚àínegl(n).
H has the form
H‚Ä≤ = 1‚àíE
w‚àºD ‚àë
a‚ààT(w)
ùúãw
a
Proof. The statement of QMA completeness in Lemma 6.17 implies that there is an efficient mapping (x,C) to a 2-
local X/Z Hamiltonian problem (HXZ,ùõºXZ(n), ùõΩXZ(n)). Applying Theorem 6.20 to this family of Hamiltonians yields
the result.
42


6.5
Analysis of the compiled Hamiltonian test
Lemma 6.22. Given an instance x, let H(n) be the corresponding Hamiltonian generated in Protocol 2, and let P be
a prover that succeeds in the compiled Pauli braiding and mixed-versus-pure tests (Protocol 4 and Protocol 7) with
probability 1‚àíùõø, and in the Hamiltonian test (Protocol 8) with probability pH. Then there exists a state ùúåsuch that
Tr[ùúåH(n)] ‚â§(1‚àípH)+O(ùõø1/4)+negl(ùúÜ).
Proof. First, since P succeeds with probability 1‚àíùõøin the Pauli braiding and mixed-versus-pure tests, by Corollary 6.7
it holds that there exists a Hilbert space H‚Ä≤ = C2n ‚äóHaux (where n is the number of qubits an honest prover would
use) and an isometry V : H ‚ÜíH‚Ä≤ such that for every Alice question q ‚ààQA, and for any subset S ‚äÜ{0,1}n,
E
w‚àºD ‚àë
u‚ààS
‚à•Mw
u ‚àíV ‚Ä†(ùúãw
u ‚äó1aux)V‚à•2
ùúìEnc(q) ‚â§O(
‚àö
ùõø)+negl(ùúÜ).
(6.10)
where D is the set of Pauli strings D(n) corresponding to the Hamiltonian H(n).
In particular, setting q = tele, we have that
E
w‚àºD ‚àë
u‚ààS
E
c‚ÜêEnc(tele)‚àë
ùõº
‚à•Mw
u ‚àíV ‚Ä†(ùúãw
u ‚äó1aux)V‚à•2
ùúìc
ùõº‚â§O(
‚àö
ùõø)+negl(ùúÜ).
(6.11)
where ùúìc
ùõº= Ac
ùõºùúì(Ac
ùõº)‚Ä†.
Now, recall that the Hamiltonian H(n) has the form
H(n) = 1‚àíE
w‚àºD ‚àë
u‚ààQ(w)
ùúãw
u ,
where ùúãw
u is a Pauli basis projector. From the success in the Hamiltonian test, we know that
E
w‚àºD‚àë
u
E
c=Enc(tele)‚àë
ùõº
Tr[Mw
u Ac
ùõºùúì(Ac
ùõº)‚Ä†]¬∑1[correct(w,u,Dec(ùõº)) ‚ààQ(w)] = pH,
(6.12)
where the function correct implements the Pauli corrections from the teleportation step, and is defined by
correct(w,u,(ux,uz))i =
(
ui ‚äï[(ux)i]1[wi=Z] ‚äï[(uz)i]1[wi=X]
wi Ã∏= 1
0
wi = 1
Also note that the right hand side of Equation (6.12) is 1 ‚àípH, because of the left we are summing over corrected
outcomes that are contained in Q(w); the test was defined to accept if the outcome is not in Q(w). (This is so that a
high success probability corresponds to a low energy according to the Hamiltonian.)
By Equation (6.11) together with Lemma 5.3, with By
b taken to be Mw
u and Cy
b taken to be V ‚Ä†(ùúãw
u ‚äó1aux)V, it thus
follows that
E
w‚àºD‚àë
u
E
c‚ÜêEnc(tele)‚àë
ùõº
Tr[V ‚Ä†(ùúãw
u ‚äó1aux)VAc
ùõºùúì(Ac
ùõº)‚Ä†]¬∑1[correct(w,u,Dec(ùõº)) ‚ààQ(w)] ‚â•pH ‚àíO(ùõø1/4)‚àínegl(ùúÜ).
We will now show how to construct the desired state ùúå. We will do this by simulating the effect of the Pauli
corrections by actual Pauli operators applied to Alice‚Äôs post-measurement state.
First, we need to deal with a technical inconvenience: the function correct is defined differently for wi = 1 and for
wi Ã∏= 1, and in the wi = 1 case, it acts by replacing the measurement outcome with 0. Fortunately, we recall that by
the definition of
ùúãw
u =
n
O
i=1
I +(‚àí1)uiùúéwi
2

,
it follows that whenever wi = 1 and ui Ã∏= 0 for any i, the corresponding projector ùúãw
u = 0. Thus, we may freely assume
that whenever wi = 1, ui = 0. This enables us to replace correct with the modified function correct‚Ä≤ defined by
correct‚Ä≤(w,u,(ux,uz))i = ui ‚äï[(ux)i]1[wi=Z] ‚äï[(uz)i]1[wi=X].
43


With respect to this modified function, we have
E
w‚àºD‚àë
u
E
c‚ÜêEnc(tele)‚àë
ùõº
Tr[V ‚Ä†(ùúãw
u ‚äó1aux)VAc
ùõºùúì(Ac
ùõº)‚Ä†]¬∑1[correct‚Ä≤(w,u,Dec(ùõº)) ‚ààQ(w)]
‚â•pH ‚àíO(ùõø1/4)‚àínegl(ùúÜ).
By shifting the sum over u, this may be equivalently rewritten as
E
w‚àºD ‚àë
u‚ààQ(w)
E
c‚ÜêEnc(tele)‚àë
ùõº
Tr[V ‚Ä†(ùúãw
correct‚Ä≤(w,u,(ux,uz)) ‚äó1aux)VAc
ùõºùúì(Ac
ùõº)‚Ä†] ‚â•pH ‚àíO(ùõø1/4)‚àínegl(ùúÜ).
Now, we observe that the Pauli corrections have the following simple form:
ùúãw
correct‚Ä≤(w,u,(ux,uz)) = ùúéZ(uz)ùúéX(ux)ùúãw
u ùúéX(ux)ùúéZ(uz).
Applying this observation, plus the cyclicity of the trace, we get
E
w‚àºD ‚àë
u‚ààQ(w)
E
c‚ÜêEnc(tele)‚àë
ùõº
Tr[(ùúãw
u ‚äó1aux)ùúéX(ux)ùúéZ(uz)VAc
ùõºùúì(Ac
ùõº)‚Ä†V ‚Ä†ùúéZ(uz)ùúéX(ux)]
‚â•pH ‚àíO(ùõø1/4)‚àínegl(ùúÜ),
where (ux,uz) = Dec(ùõº). Now, let us define
ùúå= Traux
E
c‚Üêtele‚àë
ùõº
ùúéX(ux)ùúéZ(uz)VAc
ùõºùúì(Ac
ùõº)‚Ä†V ‚Ä†ùúéZ(uz)ùúéX(ux).
It is clear that ùúåis a normalized quantum state. Moreover, we have that
Tr[H(n)ùúå] = 1‚àíE
w‚àºD ‚àë
u‚ààQ(w)
Tr[ùúãw
u ùúå] ‚â§(1‚àíph)+O(ùõø1/4)+negl(ùúÜ),
which was the desired conclusion.
6.6
Analysis of full compiled protocol
Theorem 6.23. The protocol Protocol 2 is a question-succinct argument system for QMA assuming a QHE scheme
satisfying the definition given in Definition 2.13.
More precisely, let V be the verifier, and P be the honest prover described in the protocol. Then for any promise
problem A = (Ayes,Ano) in QMA with verification algorithm C, the following hold:
‚Ä¢ Completeness: Let x ‚ààAyes , and let |ùúì‚ü©be an accepting QMA witness for x. Then the verifier V on input
(x,C,1ùúÜ), in interaction with the honest prover P on input (x,C,|ùúì‚ü©polyn,1ùúÜ), accepts with probability ‚â•1 ‚àí
negl(n).
‚Ä¢ Soundness: Let x ‚ààAno, and let |ùúô‚ü©be any state on poly(n+ùúÜ) qubits. Then the verifier V on input (x,C,1ùúÜ), in
interaction with any QPT prover P‚àóon input (x,C,|ùúô‚ü©,1ùúÜ), accepts with probability at most s for some universal
constant s < 1.
‚Ä¢ Question-succinctness: On any input x and for security parameter ùúÜ, the number of bits sent by V to P is
O(polylogn+poly(ùúÜ)).
Proof. We recall that the protocol Protocol 2 is obtained by applying the KLVY compilation to Protocol 3. This in
turn consists of three subtests: the Pauli braiding test (Protocol 4), the mixed-versus-pure basis test (Protocol 7), and
the Hamiltonian test (Protocol 8).
44


Completeness:
For the completeness, we observe that the honest prover passes the Pauli braiding test (Protocol 4)
and the mixed-versus-pure basis test (Protocol 7) with certainty, and, using a state |ùúô‚ü©, passes the Hamiltonian test
(Protocol 8) with probability equal to 1‚àí‚ü®ùúô|H(n)|ùúô‚ü©. Taking H(n) to be the Hamiltonian computed in Protocol 2, and
|ùúô‚ü©to be the appropriate polynomial number of copies of |ùúì‚ü©, we have ‚ü®ùúô|H|ùúô‚ü©= 1‚àínegl(n).
Soundness:
We now establish soundness of this protocol. Suppose x is a NO instance of the QMA language. Then
the Hamiltonian H from Protocol 3 has minimum eigenvalue at least
ùúÜmin(H) ‚â•1‚àínegl(n).
Moreover, we can assume by a padding argument that without loss of generality, that ùúÜmin(H) ‚â•2/3 for all n.
Now, suppose that P‚Ä≤ is a prover that succeeds in Protocol 2 with probability 1‚àíùõø. This means that P‚Ä≤ succeeds in
the KLVY compilations of the Pauli braiding test (Protocol 4), the mixed-versus-pure basis test (Protocol 7), and the
Hamiltonian test (Protocol 8) each with probability at least 1‚àí3ùõø. By Lemma 6.22, this means that there exists a state
ùúåsuch that
tr[ùúåH] ‚â§3ùõø+O(ùõø1/4).
For any ùõøbelow some universal ùõø0, the RHS of the expression above will be at most 1/2, and thus in contradiction
with the fact that ùúÜmin(H) ‚â•2/3.
Succinctness:
The question-succinctness property is evident from the description of the protocol. We note that the
longest messages are sent in the mixed-versus-pure basis test (Protocol 7), and the Hamiltonian test Protocol 8, where
to describe a term in H the verifier must send polylog(n) bits. In all other tests, the verifier sends at most O(log(n))
bits to the prover.
7
Compiling from a question-succinct protocol into a fully succinct protocol
using succinct arguments of knowledge
Protocol 2 is a question-succinct cryptographic single-prover protocol, in the sense that the messages the verifier sends
to the prover are polylogn ¬∑ polyùúÜbits long, where n is the size of the instance and ùúÜis the security parameter. In
[BKL+22, Section 9], Bartusek et al. present two compilers which map any question-succinct single-prover argument
system for QMA satisfying a certain obliviousness property into a fully succinct single-prover argument system for
QMA. More specifically, for their compilers to work, Bartusek et al. require that the verifier‚Äôs questions in the question-
succinct protocol can be computed independently of the prover‚Äôs answers and also the QMA instance (except for its
length). They also require implicitly that the verifier‚Äôs questions can be generated extremely efficiently, namely, in
time Àú
O(n)+polylog(n)¬∑poly(ùúÜ).
It can be easily verified that Protocol 2 satisfies the obliviousness property. However, the efficiency property is not
quite satisfied because of the commutation and anticommutation tests. Specifically, the choice of which test to execute
is a function of a ¬∑ b, where a and b are strings of length poly(n), and so na√Øvely, computing this inner product takes
time poly(n). However, there is an easy fix for this: after sampling ra,rb, the verifier decides uniformly at random
whether to run the commutation or anticommutation test, and then afterwards, if it chose wrongly, it automatically
accepts. This affects the soundness gap by at most a constant factor.
With this modification made, the verifier of Protocol 2 is indeed oblivious and efficient. In fact, all the information
the verifier sends to the prover in this modified version of Protocol 2 takes one of the following forms:
‚Ä¢ Encryptions of uniform randomness of some predetermined length.
‚Ä¢ Non-encrypted uniform randomness of some predetermined length.
Its decision process about which messages to send can also be made completely independent of the prover‚Äôs answers.
As such, the compilers presented in [BKL+22, Section 9] apply in a black-box fashion to the modified version of
Protocol 2. Nonetheless, because the presentation of the analysis in [BKL+22, Section 9] is fairly terse, we present
for the reader‚Äôs benefit some additional intuition about how Bartusek et al.‚Äôs first compiler works when applied to
45


Protocol 2 in particular. We emphasise that this is only for intuition and not meant as a full (re-)proof of the [BKL+22]
compiler.
7.1
Post-quantum succinct arguments of knowledge
The central building block for Bartusek et al.‚Äôs first compiler is a post-quantum succinct argument of knowledge (based
on Killian‚Äôs work [Kil92]) with the following commit-and-open structure. Fix some instance x, some NP language
L, and some associated predicate RL(¬∑,¬∑) (that is, RL(x,w) checks whether w is a valid witness that x ‚ààL, and can be
computed in polynomial time). Suppose also that the verifier has already sent the prover the hash key hk for some
collapsing4 hash function family. Then the following protocol allows the prover to succinctly prove knowledge of
some w such that RL(x,w) = 1:
Protocol 9 (Three-message succinct argument of knowledge).
1. The prover encodes the witness w under an error correcting code E (with corresponding decoding D) to
obtain a string Àú
w = E(w). The prover also constructs a PCPP proof ùúãthat R(x,D( Àú
w)) = 1. The prover
then constructs a Merkle tree [Mer87] on m = ( Àú
w,ùúã) using hk, computes the root of this tree rtm, and
sends the verifier rtm. The prover also constructs a Merkle tree on w itself, computes the root of this tree
rtw, and sends the verifier rtw. For notational convenience, we will call the algorithm that constructs rt
using hk by the name Merklehk(¬∑). We will also use rt to denote the combination rt = (rtm,rtw).
2. The verifier sends the prover a challenge string j = (j1,..., jk) which indicates a set of indices for which
it wants the prover to reveal m j1,...,m jk.
3. The prover reveals m j1,...,m jk and also some auxiliary information (namely, the path of hashes in the
Merkle tree leading from the root to m ji), which allows the verifier to verify whether or not (m j1,...,m jk)
were valid openings and also to compute the verification predicate for the PCPP proof that R(x,D( Àú
w)) =
1.
Clarifying information about Merkle trees and their uses in commit-and-open protocols like this can be found in
[CMSZ22, Section 2.1], but for us the important part is the message structure of this protocol. In particular, note that
all the messages in this protocol are polylog|x|¬∑polyùúÜin length, where ùúÜis the security parameter for hk.
Protocol 9 is similar to Killian‚Äôs classic protocol [Kil92] (instantiated in a form that allows for extraction of the
witness w): the only change which must be made to the protocol to make it post-quantum (apart from using a collapsing
instead of a collision-resistant hash function) is the ‚Äòextra‚Äô Merkle commitment to w in the first message in addition
to the commitment to m = ( Àú
w,ùúã).5 However, the analysis of this protocol in the post-quantum setting is significantly
more subtle than its analysis in the classical setting. In particular, the soundness statement for Protocol 9‚Äîwhich says
that, given a prover who wins with high probability, there is an efficient extractor that extracts w given black-box access
to the prover‚Äîis usually proven in the classical setting via a rewinding argument, in which the extractor reconstructs
some significant fraction of m by choosing an index j, obtaining mj, rewinding the prover, choosing another index
j‚Ä≤, obtaining m j‚Ä≤, etc., and finally using the ‚Äòerror robustness‚Äô properties of both the PCPP and of the encoding E in
order to extract w and to be sure that it satisfies R(x,¬∑) despite the missing indices. Rewinding arguments that are
secure against quantum adversaries with quantum auxiliary input tend to be much more difficult than their classical
counterparts, because of the possibility that executing the protocol even once will destroy the auxiliary input and
prevent rewinding from succeeding.
In [CMSZ22], it was shown how to analyse Protocol 9 in the post-quantum setting using a clever technique in-
volving alternating projections. However, the analysis of Protocol 9 presented in [CMSZ22] was not particularly
composable. If the succinct argument of knowledge in Protocol 9 is used as a subprotocol in some longer protocol,
4Collapsing is a post-quantum strengthening of collision resistance; see [Unr16] for a definition.
5It is not clear whether this additional commitment is necessary; however, the authors of [LMS22] were not able to make the state-preserving
extraction analysis work without it, although for the analysis in the setting of [CMSZ22] the original Killian protocol is sufficient.
46


and there are other tests in the full protocol which follow after the succinct argument of knowledge‚Äîthis is the case
for us‚Äîthen it may be necessary to ensure that running extraction does not hinder the prover‚Äôs ability to pass in
the remainder of the protocol. To motivate this requirement, consider a situation in which we are trying to design
a reduction R which reduces the security of a succinct protocol called SuccinctProtocol, in which Protocol 9 is used
as a subprotocol, to the security of a non-succinct protocol OriginalProtocol. OriginalProtocol requires the prover to
output a full witness w instead of merely passing in a succinct argument of knowledge for w; therefore, given some
prover P who is successful in SuccinctProtocol, the reduction has to run extraction on P in order to recover w, so that
it can succeed with the challenger/verifier for OriginalProtocol. However, if OriginalProtocol contains tests (mirrored in
SuccinctProtocol) that happen after its prover is supposed to output w, the reduction R will not necessarily succeed
if extracting w destroys P‚Äôs ability to succeed in the remainder of SuccinctProtocol, because then R may be unable to
answer the remaining questions in OriginalProtocol.
In order to ensure that, even after extraction has been performed, the prover continues to pass with high prob-
ability in the rest of the protocol, the prescribed extractor from [CMSZ22] was required to measure a projector that
corresponded to coherently computing whether or not the verifier would accept in the remainder of the protocol and
conditioning on the accept outcome. The issue is that the verifier‚Äôs final decision predicate might depend on secret
information (that is: the entire protocol might not be public-coin, even though Protocol 9 is public-coin), and so an
efficient extractor might be unable to do this.
In followup work [LMS22], it was shown how to analyse Protocol 9 in a more composable way, so that the extractor
only needs to measure the projection which corresponds to the verifier of Protocol 9 accepting (note that this verifier‚Äôs
decision predicate is public, so the extractor will always be able to do this), but even so the extractor‚Äôs activity is
essentially undetectable to the prover, meaning that the prover (who uses the extractor‚Äôs ‚Äòleftover state‚Äô instead of its
original state) will continue to succeed in the rest of the protocol (if it succeeded with high probability to begin with)
even after extraction has been performed. This condition on the extractor is true by default in the classical setting,
but it is nontrivial in the quantum setting. Because this guarantee may be somewhat surprising, we sketch in the next
section how this guarantee is shown.
7.2
[LMS22] extraction
The following (taken largely from [BKL+22, Definition 9.1]) is the formal statement of succinctness and security
for Protocol 9 for which we will sketch a proof in this section.
Lemma 7.1. Protocol 9 satisfies the following properties:
‚Ä¢ Succinctness. When invoked on security parameter ùúÜfor the hash function family, instance size |x| = n, and a
relation R decidable in time T, the communication complexity of the protocol is poly(ùúÜ,logT). The verifier‚Äôs
computational complexity is poly(ùúÜ,logT)+ Àú
O(n).
‚Ä¢ ùúñ-state-preserving extraction. There exists an extractor E(¬∑)(x,ùúñ) with the following properties.
‚Äì Efficiency: E(¬∑)(x,ùúñ) runs in time poly(n,ùúÜ,1/ùúñ) as a quantum oracle algorithm (with the ability to apply
controlled U-gates given an oracle U(¬∑)), outputting a classical transcript Àú
ùúèand a classical string w.
‚Äì State-preserving: Let |ùúì‚ü©‚ààA‚äóI be any poly(ùúÜ)-qubit pure state and let ùúå= TrA(|ùúì‚ü©) ‚ààD(I).6 Consider
the following two games:
* Game 0 (real): Generate a transcript ùúèby running P‚àó(ùúåI,x) with the honest verifier V. Output ùúè
along with the residual state on A‚äóI.
* Game 1 (simulated): Generate a transcript-witness pair ( Àú
ùúè,w) ‚ÜêEP‚àó(ùúåI,x). Output Àú
ùúèand the residual
state on A‚äóI.
Then, we have that the output distributions of Game 0 and Game 1 are computationally ùúÄ-indistinguishable
to any quantum distinguisher.
6In general, the prover‚Äôs input state on I may be entangled with some external register A, and we ask that computational indistinguishability
holds even given A. Our definition is stated this way for maximal generality, though we remark that the applications in this section do not require
indistinguishability in the presence of an entangled external register.
47


‚Äì Extraction correctness: for any P‚àóas above, the probability that Àú
ùúèis an accepting transcript but w is not
in Rx is at most ùúñ+negl(ùúÜ).
In order to describe the extractor which is guaranteed by Lemma 7.1, we firstly fix some notation related to the
prover‚Äôs state and actions in Protocol 9. We can model any prover P‚àóin Protocol 9 as a process which does the
following:
Process 3.
(i) Send some message rt to the verifier. Let the state that P‚àóhas left over after sending rt be |ùúìP‚àó‚ü©(held in a private
register P).
(ii) Receive a challenge j from the verifier. We assume that j is provided as a state |j‚ü©in a message register M
which is accessible both to the verifier and to the prover.
(iii) Apply some unitary UP‚àówhich acts on both P and M.
(iv) Measure some part of the resulting state (wlog in the standard basis) to get a response z, and send this to the
verifier.
The verifier will then check its decision predicate Vrt( j,z), and accept iff Vrt( j,z) evaluates to 1. If Protocol 9 is a
subprotocol in some longer protocol, then the verifier rejects immediately if Vrt( j,z) = 0.
Now we will ‚Äòpurify‚Äô the prover in order to make the [LMS22] extraction procedure easier to state. It is easy to
see that the state left over in all registers at the end of the process below is exactly equivalent to the state which is left
over at the end of Process 3:
Process 4.
(i) Send some message rt to the verifier. Let the state that P‚àóhas left over after sending rt be |ùúìP‚àó‚ü©(held in a private
register P).
(ii) Prepare a state ‚àëj |j‚ü©(we will ignore normalisation) that is a uniform superposition over challenges in a message
register M. Also create a new register Z initialised to the all zero state which will be used in step (iv).
(iii) Apply the prover‚Äôs unitary UP‚àójointly to P and M.
(iv) Coherently copy (in the standard basis) the part of the state that would have been measured in step (iv) of
Process 3 above to obtain a superposition over responses z into register Z. For short we will call the unitary that
does this copying CNOTz.
(v) Coherently compute the verifier‚Äôs predicate Vrt( j,z) into yet another new register A.
(vi) Measure registers M and Z; obtain outcomes j and z.
(vii) Measure register A; obtain Vrt(j,z), and accept iff it is 1.
As before, if Protocol 9 is a subprotocol in some longer protocol, then the verifier rejects immediately if Vrt( j,z)
measures to 0. In other words, conditioning on continuing in the protocol essentially projects into the subspace where
Vrt(j,z) = 1.
Note that steps (vi) and (vii) can be switched, because they act on different registers and therefore commute. As
such, we could also have stated Process 4 in the following way:
Process 5.
(i) Send some message rt to the verifier. Let the state that P‚àóhas left over after sending rt be |ùúìP‚àó‚ü©(held in a private
register P).
48


(ii) Prepare a state ‚àëj |j‚ü©(we will ignore normalisation) that is a uniform superposition over challenges in a message
register M. Also create a new register Z initialised to the all zero state which will be used in step (iii).
(iii) This step can be stated in words as a series of substeps:
(i) Apply the prover‚Äôs unitary UP‚àójointly to P and M.
(ii) Coherently copy (in the standard basis) the part of the state that would have been measured in step (iv) of
Process 3 above to obtain a superposition over responses z into register Z. For short we will call the unitary
that does this copying CNOTz.
(iii) Project the state in registers P, M and Z into the subspace whereVrt( j,z) = 1. If the projective measurement
results in Vrt( j,z) = 0, reject.
(iv) Undo CNOTz and UP‚àóin that order.
In other words, in this step, apply the projective measurement where one of the projectors in the measurement is
Œ†c := U‚Ä†
P‚àóCNOT‚Ä†
z

‚àë
Vrt(j,z)=1
1P ‚äó|j,z‚ü©MZ‚ü®j,z|MZ

CNOTzUP‚àó
and the other is I ‚àíŒ†c; reject if the outcome is I ‚àíŒ†c.
(iv) Redo CNOTz and UP‚àó(to counteract substep (iv) of the previous step, step (iii)). Measure registers M and Z;
obtain outcomes j and z.
The [LMS22] extractor will set up the state which exists after step (iii) in Process 5 (it can do this given an appropriate
notion of black-box access to P‚àó: see e.g. [Unr16]), and then it will insert an extra step (E) in between steps (iii) and
(iv) in Process 5, in which it extracts w in a way that is undetectable, in the sense that the state left over after the whole
of Process 5 with (E) inserted between (iii) and (iv) is computationally indistinguishable from the state left over after
the whole of Process 5 without (E). We will now describe in two stages how it accomplishes this.
[CMSZ22] extraction
In [CMSZ22], an algorithm was written down that, for any P‚àóin Protocol 9, takes in the
state in registers P, M and Z after step (ii) in Process 5 and alternates the following two projectors Œ†u and Œ†c (u for
‚Äòuniform‚Äô and c for ‚Äòcorrect‚Äô) in order to attempt to extract a witness w such that Merklehk(w) = rtw, where rtw is the
second part of the message rt = (rtm,rtw) that P‚àósent in step (i).
Œ†u = 1P ‚äó|+m‚ü©M‚ü®+m|M ‚äó|0‚ü©‚ü®0|Z,
where |+m‚ü©:= ‚àë
j
|j‚ü©with the appropriate normalisation
Œ†c = U‚Ä†
P‚àóCNOT‚Ä†
z

‚àë
Vrt( j,z)=1
1P ‚äó|j,z‚ü©MZ‚ü®j,z|MZ

CNOTzUP‚àó
Note that Œ†c coincides with the Œ†c we wrote down in Process 5. The analysis involves decomposing the joint space
of P, M and Z into the Jordan subspaces (for more information about the Jordan decomposition and how it is usually
used in quantum computing, see [Vid20, Section 1.2.3]) of Œ†u and Œ†c. We establish some notation in order to state
the extraction guarantee which [CMSZ22] prove.
Let the set of Jordan subspaces of Œ†u and Œ†c be {Si}i. Let |ui‚ü©be the rank-1 projector associated with Œ†u in
subspace i, and let |ci‚ü©be the rank-1 projector associated with Œ†c in subspace i: that is, for any |ùúô‚ü©‚ààSi, Œ†u|ùúô‚ü©=
|ui‚ü©‚ü®ui| ¬∑ |ùúô‚ü©, and similarly Œ†c|ùúô‚ü©= |ci‚ü©‚ü®ci| ¬∑ |ùúô‚ü©. Since the state in registers P, M and Z after step (ii) in Process 5,
which we will name |ùúôstart‚ü©for notational convenience, lies inside Œ†u, it can be decomposed as
|ùúôstart‚ü©= ‚àë
i
ùõºi|ui‚ü©.
The extraction guarantee which [CMSZ22] prove is the following.
49


Lemma 7.2 ([CMSZ22]; informal). For any state |ùúô‚ü©‚ààŒ†u with a decomposition |ùúô‚ü©= ‚àëi(ùõºi|ci‚ü©+ ùõΩi|ui‚ü©), and
given the ability to implement the two projectors Œ†u and Œ†c (note that Œ†c implicitly depends on rt through Vrt),
the [CMSZ22] rewinding algorithm takes as input |ùúô‚ü©and outputs w such that Merklehk(w) = rtw with probability
1‚àíùúñin time poly(1/ùúñ), if the following condition holds:
‚àë
i
(|ùõºi|2 +|ùõΩi|2)¬∑1

|‚ü®ci|ui‚ü©|2 is non-negligible

‚â•1‚àínegl(ùúÜ).
(7.1)
In other words, if the weight in the superposition ‚àëi(ùõºi|ci‚ü©+ ùõΩi|ui‚ü©) is overwhelmingly in Jordan subspaces where
|‚ü®ci|ui‚ü©|2 is non-negligible, then [CMSZ22] extraction will succeed with probability 1‚àí
1
poly(ùúÜ).
Coherent [CMSZ22] extraction.
In [LMS22], it is shown how to accomplish ‚Äòundetectable extraction‚Äô, i.e. how to
insert an extra step (E) in between steps (iii) and (iv) in Process 5, corresponding with the execution of the extractor,
such that the state left over after the whole of Process 5 with (E) inserted between (iii) and (iv) is computationally
indistinguishable from the state left over after the whole of Process 5 without (E).
Lombardi, Ma and Spooner begin by considering the entire [CMSZ22] process as a black-box unitaryUCMSZ which
takes as input a state |ùúô‚ü©‚ààŒ†u and outputs some state ‚àëw‚Ä≤ |w‚Ä≤‚ü©|auxw‚Ä≤‚ü©(ignoring normalisation) which is a superposition
over candidate witnesses w‚Ä≤ and associated auxiliary states. It can be shown that, if the superposition ‚àëw‚Ä≤ |w‚Ä≤‚ü©|auxw‚Ä≤‚ü©
has its weight only on terms with candidates w‚Ä≤ such that Merklehk(w‚Ä≤) = rtw, then measuring w‚Ä≤ at this point is
computationally undetectable: this is because Merklehk(¬∑) is a collapse-binding commitment, and the statement that
no efficient algorithm can tell the difference between ‚àëw‚Ä≤ |w‚Ä≤‚ü©W|auxw‚Ä≤‚ü©aux and MeasW
‚àëw‚Ä≤ |w‚Ä≤‚ü©W|auxw‚Ä≤‚ü©aux

, when the
superposition is only over w‚Ä≤ such that Merklehk(w‚Ä≤) = rtw, is precisely the definition of collapse-binding. (This is the
only step in the analysis where the ‚Äòextra‚Äô commitment to w which the prover sends in step (i) of Protocol 9 in addition
to the commitment to the PCPP is used.)
In other words, if the success condition for [CMSZ22] rewinding stated in Lemma 7.2 is true, namely, the starting
state |ùúô‚ü©‚ààŒ†u,|ùúô‚ü©= ‚àëi ùõºi|ui‚ü©on which UCMSZ is run is such that
‚àë
i
|ùõºi|2 ¬∑1

|‚ü®ci|ui‚ü©|2 is non-negligible

‚â•1‚àínegl(ùúÜ),
then (except with at most
1
poly(ùúÜ) probability for any poly of our choice) the extractor can run UCMSZ and then meas-
ure the W register in the resulting superposition, and this will output a successful witness candidate w‚Ä≤ such that
Merklehk(w‚Ä≤) = rtw and the measurement will be undetectable to the prover.
Our first hope might be that, if P‚àósucceeds in Protocol 9 with high probability, then the CMSZ success condition
Equation (7.1) is true for the total state lying in registers P, M and Z after step (ii) in Process 5. Unfortunately, this
turns out not to be (necessarily) true; we will not go into why here.
However, one can guarantee the condition for the success of the CMSZ procedure for the total state in registers P,
M and Z after step (iii) of Process 5. Note that the state after step (iii) is precisely the state after step (ii) after Œ†c has
been applied to it once. The effect of applying Œ†c to a superposition ‚àëi ùõºi|ui‚ü©is as follows:
Œ†c
‚àë
i
ùõºi|ui‚ü©

‚àù‚àë
i
ùõºi
|ci‚ü©‚ü®ci|¬∑|ui‚ü©

(7.2)
= ‚àë
i
ùõºi‚ü®ci|ui‚ü©

|ci‚ü©
(7.3)
Note that this (subnormalised) state now has a decomposition of the form ‚àëi ùõΩi|ci‚ü©; and, moreover, if |‚ü®ci|ui‚ü©|2 is
negligible, then the weight on |ci‚ü©(i.e. the squared norm of the coefficient of |ci‚ü©) in the superposition will be negligibly
small. For brevity‚Äôs sake we will ignore the issue of the normalisation, but the intuition that the coefficients where
|‚ü®ci|ui‚ü©|2 is small get suppressed holds even in the presence of the correct renormalisation.
Therefore, the entire ‚Äòundetectable extraction‚Äô procedure, given black-box access to a prover P‚àófor Protocol 9, is
as follows:
Process 6 (extraction).
50


(i) Run P‚àónormally in order to generate its first message rt to the verifier. Let the state that P‚àóhas left over after
sending rt be |ùúìP‚àó‚ü©(held in a private register P).
(ii) Prepare a state ‚àëj |j‚ü©(we will ignore normalisation) that is a uniform superposition over challenges in a message
register M. Also create a new register Z initialised to the all zero state which will be used in step (iii).
(iii) This step can be stated in words as a series of substeps:
(i) Apply the prover‚Äôs unitary UP‚àójointly to P and M.
(ii) Coherently copy (in the standard basis) the part of the state that would have been measured in step (iv) of
Process 3 above to obtain a superposition over responses z into register Z. For short we will call the unitary
that does this copying CNOTz.
(iii) Project the state in registers P, M and Z into the subspace whereVrt( j,z) = 1. If the projective measurement
results in Vrt( j,z) = 0, output fail.
(iv) Undo CNOTz and UP‚àóin that order.
In other words, in this step, apply the projective measurement where one of the projectors in the measurement is
Œ†c := U‚Ä†
P‚àóCNOT‚Ä†
z

‚àë
Vrt(j,z)=1
1P ‚äó|j,z‚ü©MZ‚ü®j,z|MZ

CNOTzUP‚àó
and the other is I ‚àíŒ†c; output fail if the outcome is I ‚àíŒ†c.
(E) Perform UCMSZ, the unitary that does the CMSZ rewinding procedure coherently, which results in a state
‚àëw‚Ä≤ |w‚Ä≤‚ü©W|auxw‚Ä≤‚ü©aux. Measure the W register and check if the outcome is a string w such that Merklehk(w) = rtw.
If no, output fail. If yes, apply U‚Ä†
CMSZ.
(iv) Redo CNOTz and UP‚àó(to counteract substep (iv) of step (iii)). Measure registers M and Z; obtain outcomes j
and z.
Conditioned on the extractor not outputting fail, the state that remains in registers P and M (note that Z is a work
register for the extractor) after Process 6 is computationally indistinguishable from the state which would remain
in those same registers after a real (successful) execution of Protocol 9. Note that the probability that the extractor
outputs fail in step (iii) is the same as the probability that the prover fails the real execution of Protocol 9, and that
the probability the extractor outputs fail in step (E) is at most ùúñif the extractor runs for time poly(1/ùúñ). As such,
if Protocol 9 is a sub-protocol in a longer protocol, then extraction can be performed while affecting the prover‚Äôs
probability of passing in the rest of the longer protocol by only ùúñ+negl(ùúÜ).
7.3
A fully succinct version of Protocol 2
The intuition for compiling Protocol 2 (which is already question-succinct) into a fully succinct protocol is as follows.
Every time the prover P is supposed to send a message to the verifier V in Protocol 2, we ask the prover Àú
P in the
succinct version of Protocol 2 to commit (using some succinct computationally binding commitment) to the answer
that P would have provided, and then execute Protocol 9 in order to prove succinctly that it ‚Äòknows‚Äô a valid opening to
that commitment. At the end of the protocol, V in Protocol 2 takes the answers that it receives and evaluates a decision
predicate. Since Àú
V, the succinct protocol‚Äôs verifier, does not have the prover‚Äôs answers (instead it only experienced a
short interactive proof that the prover ‚Äòknew‚Äô answers of some description), it cannot evaluate the decision predicate
for itself. Instead, the verifier Àú
V reveals all of its secret randomness at the end of the protocol, and asks Àú
P to execute
Protocol 9 one more time to prove that it knows full-length answers which are ‚Äòconsistent‚Äô with its ( Àú
P‚Äôs) earlier
commitments, and moreover that these full-length answers satisfy V‚Äôs decision predicate.
More specifically, the fully succinct version of Protocol 2 is as follows:
51


Protocol 10 (Fully succinct version of Protocol 2).
Inputs: an instance x, a description of the verification algorithm C of a promise problem A ‚ààQMA, a
security parameter ùúÜ, and (for the honest prover Àú
P) polynomially many copies of a witness that x ‚ààAyes.
(i) Phase 1: hash key, ‚ÄòAlice‚Äô question and answer
(i) The verifier Àú
V of Protocol 10 samples a hash key hk from some collapsing hash function family. It
also runs V, the verifier of Protocol 2, on the inputs x, C, ùúÜin order to generate the two questions
of Protocol 2, one of which is a ciphertext ÀÜ
q1 encrypting some ‚ÄòAlice‚Äô question q1, and the other of
which is a plaintext ‚ÄòBob‚Äô question q2. Àú
V sends hk and ÀÜ
q1 to the prover Àú
P.
(ii) Honest Àú
P responds with a succinct commitment7 to the answer that P would have given V. We will
call Àú
P‚Äôs response here com1.
(iii) Àú
P and Àú
V execute Protocol 9 so that Àú
P can prove that it knows a valid opening to its commitment
com1. The property of being a valid opening can be phrased as an NP relation R1(com1,w1) =
(Merklehk(w1) = com1).
(ii) Phase 2: ‚ÄòBob‚Äô question and answer
(i) Àú
V sends q2 (which it generated earlier along with ÀÜ
q1) to Àú
P.
(ii) Honest Àú
P responds with a succinct commitment to the answer that P would have given V. We will
call Àú
P‚Äôs response here com2.
(iii) Àú
P and Àú
V execute Protocol 9 so that Àú
P can prove that it knows a valid opening to its commitment
com2. As before, this can be phrased as an NP relation R2(com2,w2) = (Merklehk(w2) = com2).
(iii) Phase 3: Proof of knowledge that V would have accepted
(i) Àú
V now reveals the secret key sk of the quantum homomorphic encryption scheme under which ÀÜ
q1
was encrypted.
(ii) Àú
V and Àú
P execute Protocol 9 so that Àú
P can prove that it knows ÀÜ
a1 and a2 such that:
(i) ÀÜ
a1 is a valid opening of com1,
(ii) a2 is a valid opening of com2,
(iii) V(x,C,1ùúÜ,Decsk( ÀÜ
q1),Decsk( ÀÜ
a1),q2,a2) = 1.
Formally, this can be expressed as an NP relation R3((com1,com2,x,C,1ùúÜ, ÀÜ
q1,q2,sk)
|
{z
}
instance
,( ÀÜ
a1,a2)
| {z }
witness
), in
the standard way.
Theorem 7.3. There exists a negligible function negl(¬∑) such that, for any (x,C,ùúÜ), and any ùúñ=
1
poly(ùúÜ), if there exists
an efficient prover Àú
P which causes Àú
V (the verifier of Protocol 10) to accept on input (x,C,ùúÜ) with probability Àú
p, then
there exists an efficient prover P which causes V (the verifier of Protocol 2) to accept (x,C,ùúÜ) with probability p, such
that p ‚â•Àú
p‚àínegl(ùúÜ)‚àíO(ùúñ).
Proof sketch. The analysis proceeds via reduction to Protocol 2. In particular, we consider a reduction R that plays
the part of the verifier Àú
V with Àú
P in Protocol 10 and the part of the prover P with V in Protocol 2, and show that R
passes in Protocol 2 with about the same probability that Àú
P passes in Protocol 10. We assume that R gets the same
kind of black-box access to Àú
P that the extractor of Process 6 does.
R does the following:
7Succinct computationally binding commitments can be constructed from collapsing hash functions using Merkle trees.
52


(i) Phase 1: ‚ÄòAlice‚Äô question and answer
(i) Receives ÀÜ
q1 from V; samples hk for itself; inputs hk, ÀÜ
q1 into Àú
P.
(ii) Gets com1 from Àú
P.
(iii) Gets rt1, the first message of the first execution of Protocol 9 in Protocol 10, from Àú
P.
(iv) Runs Process 6 on Àú
P in order to extract a witness w1 such that w1 is a valid opening for com1. (Note that,
in the case of honest Àú
P, w1 is an encryption of an ‚ÄòAlice‚Äô answer a1.)
(v) Returns w1 to V as its ‚ÄòAlice‚Äô answer.
(ii) Phase 2: ‚ÄòBob‚Äô question and answer
(i) Receives q2 from V; inputs q2 into Àú
P.
(ii) Gets com2 from Àú
P.
(iii) Gets rt2, the first message of the second execution of Protocol 9 in Protocol 10, from Àú
P.
(iv) Runs Process 6 on Àú
P in order to extract a witness w2 such that w2 is a valid opening for com2. (Note that,
in the case of honest Àú
P, w2 is a ‚ÄòBob‚Äô answer a2.)
(v) Returns w2 to V as its ‚ÄòBob‚Äô answer.
(iii) R ignores Phase 3 of Protocol 10 and aborts after Phase 2.
Note that R does not use the third execution of Protocol 9 in Protocol 10; in fact, R cannot continue playing with
Àú
P after Phase 2 because it does not know the secret key for the homomorphic encryption which V generated. However,
the third execution of Protocol 9 in Protocol 10 will be used in the analysis. In particular, in order to prove that R
succeeds in Protocol 2 with about the same probability that Àú
P succeeds in Protocol 10, we will consider the following
mental experiment. Consider an R‚Ä≤ which behaves identically to R in Phase 1 and Phase 2 of Protocol 10, and in
Phase 3, instead of aborting, does an inefficient brute force search for the secret key of the encryption.
Process 7 (A mental experiment: R‚Ä≤‚Äôs execution).
(i) Phase 1: ‚ÄòAlice‚Äô question and answer
(i) Receives ÀÜ
q1 from V; samples hk for itself; inputs hk, ÀÜ
q1 into Àú
P.
(ii) Gets com1 from Àú
P.
(iii) Gets rt1, the first message of the first execution of Protocol 9 in Protocol 10, from Àú
P.
(iv) Runs Process 6 on Àú
P in order to extract a witness w1 such that w1 is a valid opening for com1. (Note that,
in the case of honest Àú
P, w1 is an encryption of an ‚ÄòAlice‚Äô answer a1.)
(v) Returns w1 to V as its ‚ÄòAlice‚Äô answer.
(ii) Phase 2: ‚ÄòBob‚Äô question and answer
(i) Receives q2 from V; inputs q2 into Àú
P.
(ii) Gets com2 from Àú
P.
(iii) Gets rt2, the first message of the second execution of Protocol 9 in Protocol 10, from Àú
P.
(iv) Runs Process 6 on Àú
P in order to extract a witness w2 such that w2 is a valid opening for com2. (Note that,
in the case of honest Àú
P, w2 is a ‚ÄòBob‚Äô answer a2.)
(v) Returns w2 to V as its ‚ÄòBob‚Äô answer.
(iii) Phase 3: proof of knowledge that V would have accepted
(i) Finds the secret key sk of the quantum homomorphic encryption scheme being used by V (by brute force,
let‚Äôs say) and inputs this key into Àú
P.
53


(ii) Gets rt3, the first message of the third and last execution of Protocol 9 in Protocol 10, from Àú
P.
(iii) Runs Process 6 on Àú
P in order to extract a witness w3 such that w3 = ( ÀÜ
a1,a2), where
(i) ÀÜ
a1 is a valid opening of com1,
(ii) a2 is a valid opening of com2,
(iii) V(Decsk( ÀÜ
q1),Decsk( ÀÜ
a1),q2,a2) = 1.
R‚Ä≤ is, of course, inefficient; however, it is efficient given the secret key of the homomorphic encryption. Moreover,
suppose we condition on all three extractions in Process 7 succeeding. Then, if w1 (the witness that R‚Ä≤ extracts from
Àú
P during Phase 1) is equal to ÀÜ
a1 (which is our name for the first part of the witness w3 extracted by R‚Ä≤ from Àú
P during
Phase 3) except with negligible probability in the mental experiment, and similarly w2 = a2 except with negligible
probability, then it is the case that R will be accepted by V with probability at least 1 ‚àínegl(ùúÜ). (This is because,
if extraction succeeds, then w3 consists of a pair of answers which, by definition, causes V to accept.) The event
that all three extractions succeed happens with probability at least Àú
p‚àí3ùúñ‚àínegl(ùúÜ) by a union bound, where Àú
p is the
probability that Àú
P passes overall. Therefore, it is sufficient to prove the following lemma:
Lemma 7.4. In Process 7, except with negligible probability, w1 = ÀÜ
a1 and w2 = a2.
Proof sketch. Consider an adversary A for the security for the collapsing hash function family from which hk was
drawn. A can generate its own homomorphic encryption keys and then simulate the entire interaction between V,
R‚Ä≤ and Àú
P efficiently. If w1 Ã∏= ÀÜ
a1 or w2 Ã∏= ÀÜ
a2, then A has generated two valid openings of a computationally binding8
commitment (either two valid openings to com1 or two valid openings to com2); this can only happen with negligible
probability by the definition of computational binding. The claim follows.
Therefore, w1 = ÀÜ
a1 and w2 = a2 except with negligible probability, and so R will be accepted by V with probability
at least Àú
p‚àínegl(ùúÜ)‚àíO(ùúñ).
Theorem 7.5. The protocol Protocol 10 is a succinct argument system for QMA assuming a QHE scheme satisfying
the definition given in Definition 2.13, and assuming the existence of collapsing hash functions (see [BKL+22, Section
3.6] for a definition of these objects).
More precisely, let V be the verifier, and P be the honest prover described in the protocol. Then for any promise
problem A = (Ayes,Ano) in QMA with verification algorithm C, the following hold:
‚Ä¢ Completeness: Let x ‚ààAyes , and let |ùúì‚ü©be an accepting QMA witness for x. Then the verifier V on input
(x,C,1ùúÜ), in interaction with the honest prover P on input (x,C,|ùúì‚ü©polyn,1ùúÜ), accepts with probability ‚â•1 ‚àí
negl(n).
‚Ä¢ Soundness: Let x ‚ààAno, and let |ùúô‚ü©be any state on poly(n+ùúÜ) qubits. Then the verifier V on input (x,C,1ùúÜ), in
interaction with any QPT prover P‚àóon input (x,C,|ùúô‚ü©,1ùúÜ), accepts with probability at most s‚Ä≤ for some universal
constant s‚Ä≤ < 1.
‚Ä¢ Succinctness: On any input x and for security parameter ùúÜ, the runtime of the verifier V is Àú
O(n)+O(polylogn¬∑
poly(ùúÜ)), and the total number of bits communicated between the prover and verifier is O(polylogn¬∑poly(ùúÜ)).
Proof. Completeness, soundness, and the communication bound in succinctness all follow from Theorem 6.23 and
Theorem 7.3. For the runtime part of succinctness, we must be slightly more careful. Recall that the verifier V of
Protocol 2 satisfies the obliviousness and efficiency properties that (1) the challenges it generates depend only on the
algorithm C and on the length of the instance x, not on the instance itself, and (2) all the challenges can be generated
in time polylogn¬∑polyùúÜ+ Àú
O(n). Specifically, the questions generated by V were of the following form:
‚Ä¢ Encryptions of uniform randomness of some predetermined length scaling as polylog(|x|), or
‚Ä¢ Non-encrypted uniform randomness of some predetermined length scaling as polylog(|x|),
8We note that, in this particular situation, classical binding actually suffices; collapse-binding is not necessary.
54


where the length depends on |x| and C. For our current purposes, we would like to claim that this means that V can
generate its challenges in time Àú
O(|x|) + polylog|x| ¬∑ poly(ùúÜ), and in particular does not need to run the potentially
costly reduction from x to a Hamiltonian problem (H,ùõº, ùõΩ). In order to ensure that this is the case, let us specify that
C is given as a description of the algorithm, together with an explicit polynomial upper-bounding the runtime of C.
Then, the length of the randomness to be generated in the challenges depends only on the number of qubits and terms
in the Hamiltonian H, which in turn can be efficiently computed given |x|, and the explicit polynomial. This means it
can be computed in Àú
O(|x|) time.
Now, let us calculate the runtime for the succinct verifier Àú
V in Phase 1. First, the runtime to generate the questions
ÀÜ
q1,q2 is Àú
O(n) +polylogn¬∑polyùúÜby the previous paragraph. Moreover, since these questions come from a question-
succinct protocol, their length is polylogn ¬∑ polyùúÜ‚Äîwe will need this later when we analyse Phase 3. Next, let us
compute the runtime for the succinct argument of knowledge at the end of Phase 1. The relation R1 has instance length
equal to ‚Ñì1 = |com1| = poly(logn)¬∑poly(ùúÜ), and R1 can be decided in time T1 = poly(n,ùúÜ). Thus, by Lemma 7.1, the
runtime of the succinct argument is Àú
O(‚Ñì1)+poly(log(T1))¬∑poly(ùúÜ) = poly(logn)¬∑poly(ùúÜ).
Now we move on to Phases 2 and 3. Here we can see that the runtime is dominated by the runtime of the succinct
arguments of knowledge. In Phase 2, the runtime is identical to that of Phase 1. For Phase 3, the relation R3 has
instance length
‚Ñì3 = |com1|+|com2|+|x|+|C|+ùúÜ+| ÀÜ
q1|+|q2|+|sk|
= n+poly(ùúÜ)¬∑polylogn.
It can be decided in time T3 = poly(n,ùúÜ). Thus, again applying Lemma 7.1, the runtime of the succinct argument is
Àú
O(‚Ñì3)+poly(logT3)¬∑polyùúÜ= Àú
O(n)+poly(logn)¬∑poly(ùúÜ).
All together, the total runtime of Àú
V is Àú
O(n)+polylog(n)¬∑poly(ùúÜ) as desired.
References
[Aar07]
Scott Aaronson. The Aaronson $25.00 prize, 2007. https://scottaaronson.blog/?p=284.
[Ara02]
PK Aravind. A simple demonstration of Bell‚Äôs theorem involving two observers and no probabilities or
inequalities. 2002, arXiv:quant-ph/0206070.
[BCM+21] Zvika Brakerski, Paul Christiano, Urmila Mahadev, Umesh Vazirani, and Thomas Vidick. A crypto-
graphic test of quantumness and certifiable randomness from a single quantum device. Journal of the
ACM (JACM), 68(5):1‚Äì47, 2021, arXiv:1804.00640.
[Bel64]
John S Bell. On the Einstein Podolsky Rosen paradox. Physics Physique Fizika, 1(3):195, 1964.
[BKL+22]
James Bartusek, Yael Tauman Kalai, Alex Lombardi, Fermi Ma, Giulio Malavolta, Vinod Vaikuntan-
athan, Thomas Vidick, and Lisa Yang.
Succinct classical verification of quantum computation.
In
Advances in Cryptology‚ÄìCRYPTO 2022: 42nd Annual International Cryptology Conference, CRYPTO
2022, Santa Barbara, CA, USA, August 15‚Äì18, 2022, Proceedings, Part II, pages 195‚Äì211. Springer,
2022. https://eprint.iacr.org/2022/857.
[BKVV20] Zvika Brakerski, Venkata Koppula, Umesh Vazirani, and Thomas Vidick. Simpler proofs of quantumness.
2020, arXiv:2005.04826.
[BL08]
Jacob D Biamonte and Peter J Love. Realizable hamiltonians for universal adiabatic quantum computers.
Physical Review A, 78(1):012352, 2008, arXiv:0704.1287.
[CMM+24] David Cui, Giulio Malavolta, Arthur Mehta, Anand Natarajan, Connor Paddock, Simon Schmidt, Michael
Walter, and Tina Zhang. A computational Tsirelson‚Äôs theorem for the value of compiled XOR games.
2024, arXiv:2402.17301.
55


[CMSZ22]
Alessandro Chiesa, Fermi Ma, Nicholas Spooner, and Mark Zhandry. Post-quantum succinct arguments:
breaking the quantum rewinding barrier.
In 2021 IEEE 62nd Annual Symposium on Foundations of
Computer Science (FOCS), pages 49‚Äì58. IEEE, 2022, arXiv:2103.08140.
[dlS22]
Mikael de la Salle. Spectral gap and stability for groups and non-local games. 2022, arXiv:2204.07084.
[GGM86]
Oded Goldreich, Shafi Goldwasser, and Silvio Micali. How to construct random functions. Journal of
the ACM (JACM), 33(4):792‚Äì807, 1986.
[GH15]
W. T. Gowers and O. Hatami. Inverse and stability theorems for approximate representations of finite
groups. Sbornik: Mathematics, 208(12):1784, 2015, arXiv:1510.04085.
[GKNV24] Sam Gunn, Yael Kalai, Anand Natarajan, and √Ågi Vill√°nyi. Classical commitments to quantum states.
2024. To appear.
[Gri17]
Alex B Grilo. A simple protocol for verifiable delegation of quantum computation in one round. 2017,
arXiv:1711.09585.
[GV19]
Alexandru Gheorghiu and Thomas Vidick. Computationally-secure and composable remote state pre-
paration. In 2019 IEEE 60th Annual Symposium on Foundations of Computer Science (FOCS), pages
1024‚Äì1033. IEEE, 2019, arXiv:1904.06320.
[GV24]
Aparna Gupte and Vinod Vaikuntanathan. How to construct QFHE, generically, 2024. To appear.
[JLS21]
Aayush Jain, Huijia Lin, and Amit Sahai. Indistinguishability obfuscation from well-founded assump-
tions. In Proceedings of the 53rd Annual ACM SIGACT Symposium on Theory of Computing, pages
60‚Äì73, 2021, arXiv:2008.09317.
[JNV+20]
Zhengfeng Ji, Anand Natarajan, Thomas Vidick, John Wright, and Henry Yuen. MIP* = RE. 2020,
arXiv:2001.04383.
[JNV+22]
Zhengfeng Ji, Anand Natarajan, Thomas Vidick, John Wright, and Henry Yuen. Quantum soundness
of testing tensor codes. In 2021 IEEE 62nd Annual Symposium on Foundations of Computer Science
(FOCS), pages 586‚Äì597. IEEE, 2022.
[Kil92]
Joe Kilian. A note on efficient zero-knowledge proofs and arguments. In Proceedings of the twenty-fourth
annual ACM symposium on Theory of computing, pages 723‚Äì732, 1992.
[KLVY21]
Yael Kalai, Alex Lombardi, Vinod Vaikuntanathan, and Lisa Yang. Quantum advantage from any non-
local game. 2021, arXiv:2203.15877.
[KSV02]
Alexei Yu Kitaev, Alexander Shen, and Mikhail N Vyalyi. Classical and quantum computation. Num-
ber 47. American Mathematical Soc., 2002.
[LMS22]
Alex Lombardi, Fermi Ma, and Nicholas Spooner. Post-quantum zero knowledge, revisited or: How to
do quantum rewinding undetectably. In 2022 IEEE 63rd Annual Symposium on Foundations of Computer
Science (FOCS), pages 851‚Äì859. IEEE, 2022, arXiv:2111.12257.
[Mah17]
Urmila Mahadev. Classical homomorphic encryption for quantum circuits. SIAM Journal on Computing,
(0):FOCS18‚Äì189, 2017, arXiv:1708.02130.
[Mah18]
Urmila Mahadev. Classical verification of quantum computations. In 2018 IEEE 59th Annual Symposium
on Foundations of Computer Science (FOCS), pages 259‚Äì267. IEEE, 2018, arXiv:1804.01082.
[Mer87]
Ralph C Merkle. A digital signature based on a conventional encryption function. In Conference on the
theory and application of cryptographic techniques, pages 369‚Äì378. Springer, 1987.
56


[Mer90]
David Mermin. Simple unified form for the major no-hidden-variables theorems. Physical Review Let-
ters, 65(27):3373, 1990.
[MF16]
Tomoyuki Morimae and Joseph F Fitzsimons.
Post hoc verification with a single prover.
2016,
arXiv:1603.06046.
[MV21]
Tony Metger and Thomas Vidick. Self-testing of a single quantum device under computational assump-
tions. Quantum, 5:544, 2021, arXiv:2001.09161.
[NN90]
Joseph Naor and Moni Naor. Small-bias probability spaces: Efficient constructions and applications.
In Proceedings of the twenty-second annual ACM symposium on Theory of computing, pages 213‚Äì223,
1990.
[NN24]
Anand Natarajan and Chinmay Nirkhe. The status of the quantum pcp conjecture (games version). 2024,
arXiv:2403.13084.
[NV17]
Anand Natarajan and Thomas Vidick. A quantum linearity test for robustly verifying entanglement. In
Proceedings of the 49th Annual ACM SIGACT Symposium on Theory of Computing, pages 1003‚Äì1015,
2017.
[NV18]
Anand Natarajan and Thomas Vidick. Low-degree testing for quantum states, and a quantum entangled
games PCP for QMA. In 2018 IEEE 59th Annual Symposium on Foundations of Computer Science
(FOCS), pages 731‚Äì742. IEEE, 2018, arXiv:1801.03821.
[NW19]
Anand Natarajan and John Wright. NEEXP ‚äÜMIP‚àó. 2019, arXiv:1904.05870v3.
[NZ23a]
Anand Natarajan and Tina Zhang. Bounding the quantum value of compiled nonlocal games: From
CHSH to BQP verification. In 2023 IEEE 64th Annual Symposium on Foundations of Computer Science
(FOCS), pages 1342‚Äì1348, 2023, arXiv:2303.01545.
[NZ23b]
Anand Natarajan and Tina Zhang. Quantum free games. In Proceedings of the 55th Annual ACM Sym-
posium on Theory of Computing, pages 1603‚Äì1616, 2023, arXiv:2302.04322.
[O‚ÄôD14]
Ryan
O‚ÄôDonnell.
Analysis
of
Boolean
Functions.
Cambridge
University
Press,
2014,
arXiv:2105.10386.
[Per90]
Asher Peres. Incompatible results of quantum measurements. Physics Letters A, 151(3-4):107‚Äì108,
1990.
[Sca13]
Valerio Scarani. The device-independent outlook on quantum physics (lecture notes on the power of
Bell‚Äôs theorem). Acta Physica Slovaca, 62(4):347‚Äì409, 2013, arXiv:1303.3081.
[Unr16]
Dominique Unruh.
Computationally binding quantum commitments.
In Advances in Cryptology‚Äì
EUROCRYPT 2016: 35th Annual International Conference on the Theory and Applications of Crypto-
graphic Techniques, Vienna, Austria, May 8-12, 2016, Proceedings, Part II 35, pages 497‚Äì527. Springer,
2016.
[Vid20]
Thomas Vidick. Interactions with quantum devices (course), 2020. http://users.cms.caltech.
edu/~vidick/teaching/fsmp/fsmp.pdf.
[Vid22]
Thomas Vidick. Almost synchronous quantum correlations. Journal of mathematical physics, 63(2),
2022, arXiv:2103.02468.
[Zha21]
Mark Zhandry. Quantum lightning never strikes the same state twice. or: quantum money from crypto-
graphic assumptions. Journal of Cryptology, 34:1‚Äì56, 2021, arXiv:1711.02276.
[Zha22]
Jiayu Zhang.
Classical verification of quantum computations in linear time.
In 2022 IEEE
63rd Annual Symposium on Foundations of Computer Science (FOCS), pages 46‚Äì57. IEEE, 2022,
arXiv:2202.13997.
57


Succinct Classical VeriÔ¨Åcation of Quantum Computation
James Bartusek‚àó
Yael Tauman Kalai‚Ä†
Alex Lombardi‚Ä°
Fermi Ma¬ß
Giulio Malavolta¬∂
Vinod Vaikuntanathan‚Äñ
Thomas Vidick‚àó‚àó
Lisa Yang‚Ä†‚Ä†
June 28, 2022
Abstract
We construct a classically veriÔ¨Åable succinct interactive argument for quantum computation
(BQP) with communication complexity and veriÔ¨Åer runtime that are poly-logarithmic in the
runtime of the BQP computation (and polynomial in the security parameter). Our protocol is
secure assuming the post-quantum security of indistinguishability obfuscation (iO) and Learning
with Errors (LWE). This is the Ô¨Årst succinct argument for quantum computation in the plain
model; prior work (Chia-Chung-Yamakawa, TCC ‚Äô20) requires both a long common reference
string and non-black-box use of a hash function modeled as a random oracle.
At a technical level, we revisit the framework for constructing classically veriÔ¨Åable quantum
computation (Mahadev, FOCS ‚Äô18). We give a self-contained, modular proof of security for
Mahadev‚Äôs protocol, which we believe is of independent interest. Our proof readily generalizes to
a setting in which the veriÔ¨Åer‚Äôs Ô¨Årst message (which consists of many public keys) is compressed.
Next, we formalize this notion of compressed public keys; we view the object as a generalization
of constrained/programmable PRFs and instantiate it based on indistinguishability obfuscation.
Finally, we compile the above protocol into a fully succinct argument using a (suÔ¨Éciently
composable) succinct argument of knowledge for NP. Using our framework, we achieve several
additional results, including
‚Ä¢ Succinct arguments for QMA (given multiple copies of the witness),
‚Ä¢ Succinct non-interactive arguments for BQP (or QMA) in the quantum random oracle
model, and
‚Ä¢ Succinct batch arguments for BQP (or QMA) assuming post-quantum LWE (without iO).
‚àóUC Berkeley. Email:
bartusek.james@gmail.com.
‚Ä†Microsoft Research and MIT. Email: yael@microsoft.com.
‚Ä°MIT. Email: alexjl@mit.edu.
¬ßSimons Institute and UC Berkeley. Email: fermima@alum.mit.edu.
¬∂Max Planck Institute for Security and Privacy. Email: giulio.malavolta@hotmail.it.
‚ÄñMIT. Email: vinodv@mit.edu.
‚àó‚àóCaltech. Email: vidick@caltech.edu.
‚Ä†‚Ä†MIT. Email; lisayang@mit.edu.


Contents
1
Introduction
1
2
Technical Overview
4
2.1
Recap: Mahadev‚Äôs Measurement Protocol . . . . . . . . . . . . . . . . . . . . . . . .
4
2.2
DeÔ¨Åning a (Succinct) Measurement Protocol . . . . . . . . . . . . . . . . . . . . . . .
6
2.3
Constructing a VeriÔ¨Åer-Succinct Measurement Protocol
. . . . . . . . . . . . . . . .
7
2.4
Proof of Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2.5
From a VeriÔ¨Åer-Succinct Measurement Protocol to Succinct Arguments for BQP
. .
13
3
Preliminaries
14
3.1
Quantum Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
14
3.2
Black-Box Access to Quantum Algorithms . . . . . . . . . . . . . . . . . . . . . . . .
15
3.3
Interactive Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
16
3.4
Computational Indistinguishability . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
3.5
Mahadev Randomized TCFs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
18
3.6
Collapsing Hash Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
20
3.7
Fully Homomorphic Encryption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
3.8
Indistinguishability Obfuscation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
3.9
Puncturable PRFs
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
4
Commit-and-Measure Protocols
23
4.1
DeÔ¨Åning Commit-and-Measure Protocols . . . . . . . . . . . . . . . . . . . . . . . . .
23
5
A Measurement Protocol Template
26
5.1
Measurement Protocol Description . . . . . . . . . . . . . . . . . . . . . . . . . . . .
27
6
Soundness of Mahadev‚Äôs Protocol
29
6.1
The VeriÔ¨Åer‚Äôs Output Distribution . . . . . . . . . . . . . . . . . . . . . . . . . . . .
29
6.2
The Protocol Observables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
6.3
The Extracted State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
33
6.4
Indistinguishability of Measurement Outcomes
. . . . . . . . . . . . . . . . . . . . .
36
7
Succinct Key Generation from iO
41
7.1
Batch Key Generation: DeÔ¨Ånition and Construction
. . . . . . . . . . . . . . . . . .
41
7.2
Combining Succinct Key Generation with Mahadev rTCFs
. . . . . . . . . . . . . .
45
8
A VeriÔ¨Åer-Succinct Protocol
47
8.1
Quantum commit-challenge-response protocols
. . . . . . . . . . . . . . . . . . . . .
47
8.2
Non-Interactive Post Hoc VeriÔ¨Åcation of QMA . . . . . . . . . . . . . . . . . . . . .
48
8.3
Semi-Succinct Delegation for QMA . . . . . . . . . . . . . . . . . . . . . . . . . . . .
48
i


9
The Fully Succinct Protocol
50
9.1
State-Preserving Succinct Arguments of Knowledge . . . . . . . . . . . . . . . . . . .
51
9.2
The QMA Protocol, Version 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
52
9.3
The QMA Protocol, Version 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
54
10 Additional Results
56
10.1 Succinct Non-interactive Arguments in the QROM . . . . . . . . . . . . . . . . . . .
56
10.2 Batch Arguments for QMA
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
58
10.3 Zero Knowledge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
59
A Proofs from Section 8
64
B Proof of Claim 6.4
67
C Proof of Claim 6.7
68
ii


1
Introduction
EÔ¨Écient veriÔ¨Åcation of computation is one of the most fundamental and intriguing concepts in
computer science, and lies at the heart of the P vs. NP question.
It has been studied in the
classical setting for over three decades, giving rise to beautiful notions such as interactive proofs
[GMR85], multi-prover interactive proofs [BGKW88], probabilistically checkable proofs [BFL90,
ALM+92, AS92], and culminating with the notion of a succinct (interactive and non-interactive)
argument [Kil92, Mic94]. Roughly speaking, a succinct argument for a T-time computation enables
a prover running in poly(T) time to convince a polylog(T)-time veriÔ¨Åer of the correctness of the
computation using only polylog(T) bits of communication, with soundness against all polynomial-
time cheating provers.
In a breakthrough result in 2018, Mahadev [Mah18] presented an interactive argument system
that enables a classical veriÔ¨Åer to check the correctness of an arbitrary quantum computation.
Mahadev‚Äôs protocol represents a diÔ¨Äerent kind of interactive argument ‚Äî unlike the traditional
setting in which the prover simply has more computational resources (i.e., running time) than
the veriÔ¨Åer, the prover in Mahadev‚Äôs protocol works in a qualitatively more powerful computa-
tional model. More precisely, for any T-time quantum computation, Mahadev‚Äôs protocol enables a
quantum prover running in time poly(T) to convince a classical poly(T)-time veriÔ¨Åer with poly(T)
bits of classical communication. Soundness holds against all quantum polynomial-time cheating
provers under the post-quantum hardness of the learning with errors (LWE) problem.
A fundamental question is whether we can get the best of both worlds: can the prover have both
a more powerful computational model and signiÔ¨Åcantly greater computational resources? Namely,
we want an interactive argument system for T-time quantum computation in which the quantum
prover runs in poly(T) time and convinces a polylog(T)-time classical veriÔ¨Åer with polylog(T) bits
of classical communication.
We answer this question aÔ¨Érmatively, both for poly(T)-time quantum computations, corre-
sponding to the complexity class BQP, and also for the non-deterministic analog QMA.
Theorem 1.1 (Succinct Arguments for BQP). Let Œª be a security parameter. Assuming the
existence of a post-quantum secure indistinguishability obfuscation scheme (iO) and the post-
quantum hardness of the learning with errors problem (LWE), there is an interactive argument
system for any T-time quantum computation on input x,1 where
‚Ä¢ the prover is quantum and runs in time poly(T, Œª),
‚Ä¢ the veriÔ¨Åer is classical and runs in time poly(log T, Œª) + Àú
O(|x|),2 and
‚Ä¢ the protocol uses poly(log T, Œª) bits of classical communication.
Theorem 1.2 (Succinct Arguments for QMA). Assuming the existence of a post-quantum
secure indistinguishability obfuscation scheme (iO) and the post-quantum hardness of the
1A T-time quantum computation is a language L decidable by a bounded-error T-time quantum Turing machine
[BV97]. We leave it to future work to address more complex tasks such as sampling problems (as in [CLLW20]).
2As in the classical setting, some dependence on |x| is necessary at least to read the input; as in [Kil92], we achieve
a fairly minimal |x|-dependence.
1


learning with errors problem (LWE), there is an interactive argument system for any T-time
quantum computation on input x and a poly(T)-qubit witness, where
‚Ä¢ the prover is quantum and runs in time poly(T, Œª), using polynomially many copies of
the witness,3
‚Ä¢ the veriÔ¨Åer is classical and runs in time poly(log T, Œª) + Àú
O(x), and
‚Ä¢ the protocol uses poly(log T, Œª) bits of classical communication.
A New Proof of Security for the [Mah18] Protocol.
One might hope to prove Theorems 1.1
and 1.2 by treating the Mahadev result as a ‚Äúblack box‚Äù and showing that any (classical) interac-
tive argument for quantum computations can be compressed into a succinct protocol via a suitable
cryptographic compiler. This is especially appealing given the extremely technical nature of Ma-
hadev‚Äôs security proof. Unfortunately, for reasons that will become clear in the technical overview,
this kind of generic compilation seems unlikely to be achievable in our setting. Even worse, there
does not appear to be any easily formalized property of the Mahadev protocol that would enable
such a compilation.
Instead, our solution consists of two steps.
(1) We build a modiÔ¨Åed variant of the [Mah18] protocol and give an entirely self-contained proof of
security. This modiÔ¨Åed protocol satisÔ¨Åes a few technical conditions that the original [Mah18]
does not; most prominently, the Ô¨Årst veriÔ¨Åer message of our modiÔ¨Åed protocol is already
succinct.
(2) We give a generic compiler that converts the protocol from Step (1) into a succinct argument
system.
Our Step (1) also results in a self-contained proof of security of the original [Mah18] protocol
that is more modular and amenable to further modiÔ¨Åcation and generalization, which we believe
will be useful for future work. Our analysis builds upon [Mah18] itself as well as an alternative
approach described in Vidick‚Äôs (unpublished) lecture notes [Vid20]. A concrete consequence of our
new proof is that one of the two ‚Äúhardcore bit‚Äù security requirements of the main building block
primitive (‚Äúextended noisy trapdoor claw-free functions‚Äù) in [Mah18] is not necessary.
Additional Results.
Beyond our main result of succinct arguments for BQP and QMA, we
explore a number of extensions and obtain various new protocols with additional properties.
‚Ä¢ Non-Interactive: Although our protocols are not public-coin, we show how to modify them in
order to apply the Fiat-Shamir transformation and round-collapse our protocols. As a result,
we obtain designated-veriÔ¨Åer non-interactive arguments for BQP (and the non-deterministic
analog QMA) with security in the quantum random oracle model (QROM).
3We inherit the need for polynomially-many copies of the witness from prior works. This is a feature common to
all previous classical veriÔ¨Åcation protocols, and even to the quantum veriÔ¨Åcation protocol of [FHM18].
2


‚Ä¢ Zero-Knowledge: We show how to lift both variants of our protocol (interactive and non-
interactive) to achieve zero-knowledge. We show a generic transformation based on classical
two-party computation for reactive functionalities that makes our protocols simulatable. This
transformation does not add any new computational assumption to the starting protocol.
‚Ä¢ Batch Arguments from LWE: For the case of batch arguments, i.e., where the parties engage
in the parallel veriÔ¨Åcation of n statements, we show a succinct protocol that only assumes
the post-quantum hardness of LWE (without iO). In this context, succinctness requires that
the veriÔ¨Åer‚Äôs complexity scales with the size of a single instance, but is independent of n.
Prior Work.
As discussed above, Mahadev [Mah18] constructs a non-succinct argument sys-
tem for BQP/QMA under LWE. The only prior work addressing succinct classical arguments for
quantum computation is the recent work of Chia, Chung and Yamakawa [CCY20]. [CCY20] con-
structs a classically veriÔ¨Åable argument system for quantum computation in the following setting:
‚Ä¢ The prover and veriÔ¨Åer share a poly(T)-bits long, structured reference string (which requires
a trusted setup to instantiate) along with a hash function h (e.g. SHA-3).
‚Ä¢ The ‚Äúonline communication‚Äù of the protocol is succinct (poly(log T)).
‚Ä¢ Security is heuristic: it can be proved when h is modeled as a random oracle, but the protocol
description itself explicitly requires the code of h (i.e. uses h in a non-black-box way).
We speciÔ¨Åcally note that when viewed in the plain model (i.e., without setup), the veriÔ¨Åer must
send the structured reference string to the prover, resulting in a protocol that is not succinct.
We note that [CCY20] was speciÔ¨Åcally optimizing for a two-message protocol, but their approach
seems incapable of achieving succinctness in the plain model even if further interaction is allowed.
By contrast, our succinct interactive arguments are in the plain model and are secure based on
well-formed cryptographic assumptions, and our succinct 2-message arguments are proved secure
in the QROM (and do not require a long common reference string).
Finally, we remark that our approach to achieving succinct arguments fundamentally (and
likely necessarily) diÔ¨Äers from [CCY20] because we manipulate the ‚Äúinner workings‚Äù of the [Mah18]
protocol; by contrast [CCY20] makes ‚Äúblack-box‚Äù use of a speciÔ¨Åc soundness property of the [Mah18]
protocol (referred to as ‚Äúcomputational orthogonality‚Äù by [ACGH20]) and is otherwise agnostic to
how the protocol is constructed.
Acknowledgments.
AL is supported in part by a Charles M. Vest fellowship. GM is partially
supported by the German Federal Ministry of Education and Research BMBF (grant 16K15K042,
project 6GEM). TV is supported by AFOSR YIP award number FA9550-16-1-0495, a grant from
the Simons Foundation (828076, TV), MURI Grant FA9550-18-1-0161, the NSF QLCI program
through grant number OMA-2016245 and the IQIM, an NSF Physics Frontiers Center (NSF Grant
PHY-1125565) with support of the Gordon and Betty Moore Foundation (GBMF-12500028). AL,
VV, and LY are supported in part by DARPA under Agreement No. HR00112020023, a grant from
MIT-IBM Watson AI, a grant from Analog Devices, a Microsoft Trustworthy AI grant and the
3


Thornton Family Faculty Research Innovation Fellowship. Any opinions, Ô¨Åndings and conclusions
or recommendations expressed in this material are those of the author(s) and do not necessarily
reÔ¨Çect the views of the United States Government or DARPA. LY was supported in part by an
NSF graduate research fellowship.
2
Technical Overview
Our starting point is Mahadev‚Äôs protocol for classical veriÔ¨Åcation of quantum computation [Mah18],
the core ingredient of which is a measurement protocol.
2.1
Recap: Mahadev‚Äôs Measurement Protocol
We begin by reviewing Mahadev‚Äôs N-qubit measurement protocol. In Mahadev‚Äôs protocol, a quan-
tum prover holding an N-qubit quantum state œÅ interacts with a classical veriÔ¨Åer, who wants to
obtain the result of measuring œÅ according to measurement bases h ‚àà{0, 1}N (hi speciÔ¨Åes a basis
choice for the ith qubit, with hi = 1 corresponding to the Hadamard basis and hi = 0 corresponding
to the standard basis).
Trapdoor Claw-Free Functions.
At the heart of the protocol is a cryptographic primitive
known as an injective/claw-free trapdoor function (a variant of lossy trapdoor functions [PW08,
PVW08, GVW15]), which consists of two trapdoor function families Inj (for injective) and Cf (for
claw-free), with the following syntactic requirements:4
‚Ä¢ Each function in Cf ‚à™Inj is indexed by a public-key pk, where functions fpk ‚ààInj are injective
and functions fpk ‚ààCf are two-to-one. Moreover, pk can be sampled along with a secret key
sk that enables computing f‚àí1
pk (i.e., f‚àí1
pk (y) consists of a single pre-image if fpk ‚ààInj, and two
pre-images if fpk ‚ààCf).
‚Ä¢ All functions in Inj and Cf have domain {0, 1}‚Ñì+1 (for some ‚Ñì) and the two pre-images of y
under fpk ‚ààCf are of the form (0, x0) and (1, x1) for some x0, x1 ‚àà{0, 1}‚Ñì.
An injective/claw-free trapdoor function must satisfy the following security properties:5
1. Claw-Free/Injective Indistinguishability. A random function in fpk ‚ÜêCf is computa-
tionally indistinguishable from a random function fpk ‚ÜêInj.
2. Adaptive Hardcore Bit. Given fpk ‚ÜêCf, it is computationally infeasible to output both
(1) a pair (x, y) satisfying fpk(x) = y and (2) a non-zero string d ‚àà{0, 1}‚Ñì+1 such that
d ¬∑ (1, x0 ‚äïx1) = 0, where (0, x0) and (1, x1) are the two preimages of y.6
4The actual syntactic requirements, described in Section 3.5, are somewhat more complex due to the fact that
the functions in question are probabilistic.
5In fact, Mahadev‚Äôs proof relies on two diÔ¨Äerent hardcore bit properties, but we show in this work that only the
adaptive hardcore bit property is needed.
6The full deÔ¨Ånition places a slightly stronger restriction on d than simply being non-zero. However, this simpliÔ¨Åed
version will suÔ¨Éce for this overview.
4


To build some intuition about the usefulness of such function families, notice that they can be
used to commit to a single classical bit quite easily. The commitment key is a function fpk ‚ààInj,
and commitment to a bit b is y = fpk(b, x) for a random x ‚àà{0, 1}n. It is not hard to verify that
this is a statistically binding and computationally hiding commitment of b. On the other hand, if
fpk ‚ààCf, it is a statistically hiding and computationally binding commitment of b.7
Protocol Description.
With this intuition in mind, we now describe a (slightly simpliÔ¨Åed version
of) the Mahadev measurement protocol. Mahadev‚Äôs protocol is a many-fold sequential repetition
of the following one-bit challenge protocol.
V ‚ÜíP: The veriÔ¨Åer samples N pairs of functions and their trapdoors: for every i ‚àà[‚Ñì], he samples
(pki, ski) ‚ÜêInj if hi = 0 and (pki, ski) ‚ÜêCf if hi = 1. He sends the N-tuple of public keys
(function descriptions) (pk1, . . . , pkN) to the prover.
P ‚ÜíV: The prover holds an N-qubit state œÅ on register B = B1 ‚äó¬∑ ¬∑ ¬∑ BN. She initializes registers
X = X1 ‚äó¬∑ ¬∑ ¬∑ XN so that each Xi is an ‚Ñì-qubit register in uniform superposition. Then she
evaluates each fpki on the ‚Ñì+ 1 qubit register Bi ‚äóXi and measures the output to obtain yi.
Finally, she sends (y1, . . . , yN) to the veriÔ¨Åer, keeping the registers B, X for herself.
V ‚ÜíP: The veriÔ¨Åer picks a random challenge bit c ‚Üê{0, 1} and sends it to the prover. c = 0
indicates a ‚Äútest round‚Äù and c = 1 indicates a ‚Äúmeasurement round‚Äù.
P ‚ÜíV: If c = 0 (‚Äútest‚Äù), the prover measures each Bi ‚äóXi in the standard basis, obtaining
(bi, xi) ‚àà{0, 1} √ó {0, 1}‚Ñì, and sends (bi, xi)N
i=1 to the veriÔ¨Åer.
If c = 1 (‚Äúmeasure‚Äù), she measures each Bi ‚äóXi in the Hadamard basis (i.e., she applies
the Hadamard gate H on each qubit and then measures in the standard basis), obtaining
di ‚àà{0, 1}‚Ñì+1, and sends (di)N
i=1 to the veriÔ¨Åer.
V (output): If c = 0 (‚Äútest‚Äù), V either accepts or rejects the interaction but outputs nothing. In
particular, V checks that fpki(bi, xi) = yi. If any of the checks fail, reject.
If c = 1 (‚Äúmeasure‚Äù), proceed as follows. Let R ‚äÜ[N] be the set of indices where hi = 1,
corresponding to Hadamard basis measurements, and let S = [N] \ R be the set of indices
corresponding to standard basis measurements.
For each i ‚ààR, V computes the two inverses (0, xi,0) and (1, xi,1) of yi (which are guaranteed
to exist since fpk,i ‚ààCf) using ski. V sets ui := d ¬∑ (1, xi,0 ‚äïxi,1) as the ith measurement
outcome. For every i ‚ààS, V ignores di, and sets vi to be the Ô¨Årst bit of f‚àí1
pki(yi), computed
using the trapdoor ski (this is well-deÔ¨Åned since fpk,i ‚ààInj). Finally V outputs the N-bit
string (u, v) ‚àà{0, 1}R √ó {0, 1}S.
Mahadev [Mah18] proves that if a malicious prover P‚àópasses the test round with probability 1,
then there exists an N-qubit quantum state œÅ‚àó‚Äî independent of the veriÔ¨Åer‚Äôs measurement basis
h ‚Äî such that the result of measuring œÅ‚àóaccording to h is computationally indistinguishable from
7In particular, fpk ‚ààCf satisÔ¨Åes Unruh‚Äôs deÔ¨Ånition of collapse-binding [Unr16b].
5


the veriÔ¨Åer‚Äôs N-bit output distribution in the measurement round.8 While her deÔ¨Ånition requires
that such a œÅ‚àóexists, Vidick and Zhang [VZ21] showed that Mahadev‚Äôs proof steps implicitly deÔ¨Åne
an extractor that eÔ¨Éciently produces œÅ‚àóusing black-box access to P‚àó.
2.2
DeÔ¨Åning a (Succinct) Measurement Protocol
Our Ô¨Årst (straightforward but helpful) step is to give an explicit deÔ¨Ånition of a commit-and-
measure protocol that abstracts the completeness and soundness properties of Mahadev‚Äôs mea-
surement protocol as established in [Mah18, VZ21].
Roughly speaking, a commit-and-measure
protocol is sound if, for any malicious prover P‚àóthat passes the test round with probability 1 and
any basis choice h, there exists an eÔ¨Écient extractor that (without knowledge of h) interacts with
prover and outputs an extracted state œÑ such that the following are indistinguishable:
‚Ä¢ the distribution of veriÔ¨Åer outputs obtained in the measurement round from interacting with
P‚àóusing basis choice h, and
‚Ä¢ the distribution of measurement outcomes obtained from measuring œÑ according to h.
This abstraction will be particularly helpful for reasoning about our eventual succinct measurement
protocols, which will necessitate modifying Mahadev‚Äôs original protocol.
Can a Measurement Protocol be Succinct?
Given the deÔ¨Ånition of a measurement protocol,
an immediate concern arises with respect to obtaining succinct arguments: the veriÔ¨Åer‚Äôs input to
the measurement protocol ‚Äì the basis vector h ‚Äì is inherently non-succinct. Since the number of
qubits N grows with the runtime of the BQP computation when used to obtain quantum veriÔ¨Åcation
[FHM18], this poses an immediate problem.
Our solution to this problem is to only consider basis vectors h that are succinct; our formal-
ization is that h must be the truth table of an eÔ¨Éciently computable function f : [log N] ‚Üí{0, 1}.
For any such h, we can represent the veriÔ¨Åer‚Äôs input as a circuit C that computes h, removing the
above obstacle.
However, in order for there to be any hope of this idea working, it must be the case that
measurement protocols for bases with succinct representations are still useful for constructing dele-
gation for BQP. Fortunately, it has been shown [ACGH20] that classically veriÔ¨Åable (non-succinct)
arguments for BQP can be constructed by invoking Mahadev‚Äôs measurement protocol (and, by in-
spection of the proof, any measurement protocol satisfying our deÔ¨Ånition) on a uniformly random
basis string h ‚Üê{0, 1}N. Then, by computational indistinguishability, it is also possible to use a
pseudorandom string h that has a succinct representation, i.e., h = (PRFs(1), . . . , PRFs(N)) for
some (post-quantum) pseudorandom function PRF.
Thus, we focus for the moment on constructing a succinct measurement protocol for h with
succinct representation, and return to the full delegation problem later.
8This can be extended to provers that pass the test round with probability 1 ‚àíŒµ by the gentle measurement
lemma. In particular, an eÔ¨Écient distinguisher can only distinguish the veriÔ¨Åer‚Äôs output distribution from the result
of measuring some œÅ‚àówith advantage poly(Œµ).
6


2.3
Constructing a VeriÔ¨Åer-Succinct Measurement Protocol
Inspecting the description of the [Mah18] protocol, there are three distinct reasons that the protocol
is not succinct:
1. The veriÔ¨Åer‚Äôs Ô¨Årst message, which consists of N TCF public keys, is non-succinct.
2. The prover‚Äôs two messages, consisting of the commitments yi and openings zi respectively,
are non-succinct.
3. The veriÔ¨Åer‚Äôs decision predicate, as it is a function of these commitments and openings,
requires poly(N) time to evaluate.
The latter two issues turn out to be not too diÔ¨Écult to resolve (although there is an important
subtlety that we discuss later); for now, we focus on resolving (1), which is our main technical
contribution. Concretely, we want to construct a measurement protocol for succinct bases h where
the veriÔ¨Åer‚Äôs Ô¨Årst message is succinct.
Idea: Compress the VeriÔ¨Åer‚Äôs message with iO.
Given the problem formulation, a natural
idea presents itself: instead of having V send over N i.i.d. public keys pki, perhaps V can send
a succinct program PK that contains the description of N public keys pki that are in some sense
‚Äúpseudoindependent!‚Äù Using the machinery of obfuscation and the ‚Äúpunctured programs‚Äù technique
[SW14], it is straightforward to write down a candidate program for this task: simply obfuscate
the following code.
Input: index i ‚â§N
Hardwired Values: Puncturable PRF seed s. Circuit C.
‚Ä¢ Compute mode = C(i) and r = PRFs(i).
‚Ä¢ Compute (pki, ski) ‚ÜêGen(1Œª, mode; r).
‚Ä¢ Output pki.
Here, C is an eÔ¨Écient circuit with truth table h, and Gen(1Œª, mode) indicates sampling either
from Inj or Cf depending on whether hi = C(i) = 0 or hi = C(i) = 1.
Letting PK denote an obfuscation of the above program, V could send PK to P and allow the
prover to compute each pki = PK(i) on its own, and the protocol could essentially proceed as
before, except that the veriÔ¨Åer will have to expand its PRF seed s into (sk1, . . . , skN) in order to
compute its Ô¨Ånal output.
7


Problem: Proving Soundness.
While it is not hard to describe this plausible modiÔ¨Åcation to
the [Mah18] protocol that compresses the veriÔ¨Åer‚Äôs message, it is very unclear how to argue that
the modiÔ¨Åed protocol is sound. The obfuscation literature has no shortage of proof techniques
developed over the last 10 years, but since we have made a ‚Äúnon-black-box‚Äù modiÔ¨Åcation of the
[Mah18] protocol, a deep understanding of the [Mah18] proof of soundness is required in order to
understand to what extent these techniques are compatible with the application at hand.
We believe it should be possible to incorporate punctured programming techniques into Ma-
hadev‚Äôs proof of soundness in [Mah18] and conclude the desired soundness property of the new
protocol. However, doing so would result in an extremely complex proof that would require the
reader to verify the entirety of the [Mah18] (already very complicated) original security proof with
our modiÔ¨Åcations in mind.
2.4
Proof of Soundness
Given the complicated nature of the [Mah18] proof of soundness, we instead give a simpler and
more modular proof of soundness for the [Mah18] measurement protocol. Moreover, we give this
proof for a generic variant of the [Mah18] protocol where the prover is given an arbitrary represen-
tation PK of N TCF public keys and show that precisely two properties of this representation PK
are required in order for the proof to go through:
‚Ä¢ An appropriate generalization of the ‚Äúdual-mode‚Äù property of individual TCFs must hold for
PK: for any two circuits C1, C2, it should be that PK1 generated from basis C1 is compu-
tationally indistinguishable from PK2 generated from basis C2. In fact, a stronger variant
of this indistinguishability must hold: it should be the case that PK1 ‚âàc PK2 even if the
distinguisher is given all secret keys skj such that C1(j) = C2(j).
‚Ä¢ For every i, the adaptive hardcore bit property of fpki should hold even given skj for all
j Ã∏= i.
Since these two properties are (essentially) all that is required for our proof to go through, in
order to obtain a veriÔ¨Åer-succinct protocol, it suÔ¨Éces to show that the obfuscated program PK
above satisÔ¨Åes these two properties, which follows from standard techniques.
Thus, we proceed by describing our new soundness proof for the [Mah18] measurement protocol,
which transparently generalizes to the veriÔ¨Åer-succinct setting.
The ‚ÄúOperational Qubits‚Äù Approach.
Let P ‚àódenote a prover that passes the test round (i.e.,
makes the veriÔ¨Åer accept on the 0 challenge) with probability 1. Our goal is to show that the prover
in some sense ‚Äúhas an N-qubit state‚Äù such that measuring this state in the h-bases produces the
same (or an indistinguishable) distribution as the veriÔ¨Åer‚Äôs protocol output, which we will denote
DP ‚àó,Out. This N-qubit state should be eÔ¨Éciently computable from the prover‚Äôs internal state |œà‚ü©;
speciÔ¨Åcally, we use |œà‚ü©to denote the prover‚Äôs state after its Ô¨Årst message y has been sent.
In order to show this, taking inspiration from [Vid20],9 we will proceed in two steps:
9[Vid20] gives a soundness proof for a variant of the [Mah18] protocol, but in a qualitatively weaker setting.
8


1. Identify N ‚Äúoperational qubits‚Äù within |œà‚ü©. That is, we will identify a set of 2N observables
Z1, . . . , ZN, X1, . . . , XN (analogous to the ‚ÄúPauli observables‚Äù œÉz,1, . . . , œÉz,N, œÉx,1, . . . œÉx,N)
such that measuring |œà‚ü©with these observables gives the outcome distribution DP ‚àó,Out.
Provided that these 2N observables roughly ‚Äúbehave like‚Äù Pauli observables with respect
to |œà‚ü©(e.g. satisfy the X/Z uncertainty principle), one could then hope to:
2. Extract a related state |œà‚Ä≤‚ü©such that measuring |œà‚Ä≤‚ü©in the actual standard/Hadamard bases
matches the ‚Äúpseudo-Pauli‚Äù {Zj}, {Xi}, measurements of |œà‚ü©(and therefore DP ‚àó,Out).
Relating the VeriÔ¨Åer‚Äôs Output to Measuring |œà‚ü©.
Our current goal is to achieve Step (1)
above. Let |œà‚ü©denote P ‚àó‚Äôs post-commitment state and let U denote the unitary such that P ‚àó‚Äôs
opening is a measurement of U |œà‚ü©in the Hadamard basis.
Now, let us consider the veriÔ¨Åer‚Äôs output distribution. The ith bit of the veriÔ¨Åer‚Äôs output when
hi = 1 is deÔ¨Åned to be d ¬∑ (x0,i ‚äïx1,i) (where d is the opening sent by the prover) of U |œà‚ü©in the
Hadamard basis. For each such i, we can deÔ¨Åne an observable Xi characterizing this measurement,
that roughly takes the form
Xi ‚âàU ‚Ä†(HZi ‚äóId)
 X
d
(‚àí1)d¬∑(1,x0,i‚äïx1,i) |d‚ü©
‚ü®d|Zi ‚äóIdI,{Zj}jÃ∏=i
!
(HZi ‚äóId)U.
Here we have slightly simpliÔ¨Åed the expression for Xi for the sake of presentation; the correct
deÔ¨Ånition of Xi (see Section 6.2) must account for the case where d is rejected by the veriÔ¨Åer. To
reiterate, the observable Xi is a syntactic interpretation of the veriÔ¨Åer‚Äôs output mi as a function of
|œà‚ü©.
On the other hand, when hi = 0, the veriÔ¨Åer‚Äôs output mi is not a priori a measurement of |œà‚ü©;
indeed, the veriÔ¨Åer ignores the prover‚Äôs second message and just inverts yi. However, under the
assumption that the prover P ‚àópasses the test round with probability 1 ‚àínegl(Œª), making use of
the fact that fpki is injective, this yi-inverse must be equal to what the prover would have sent in
the test round. This deÔ¨Ånes another observable on |œà‚ü©that we call Zi:
Zi =
X
b,x
(‚àí1)b |b, x‚ü©
‚ü®b, x|Zi ‚äóIdI,{Zj}jÃ∏=i.
Finally, note that the operator Zi syntactically makes sense even when hi = 1. However, Xi
cannot even be deÔ¨Åned when fpki is injective, corresponding to hi = 0, since Xi explicitly requires
two inverses of yi. Therefore, from now on, we sample all (pki, ski) ‚ÜêCf (forcing all TCFs to be
2-to-1).
This brings us to the punchline of this step: by invoking a computational assumption (the
indistinguishability of Cf and Inj), we can deÔ¨Åne observables (Xi, Zi) for all i ‚àà[N] such that for
every i and every basis choice h, the distribution resulting from measuring |œà‚ü©with Xi (resp. Zi)
matches the ith bit of the veriÔ¨Åer‚Äôs output distribution.
[Vid20] only proves indistinguishability of N-qubit measurements that are either all in the standard basis or all in
the Hadamard basis, and only proves indistinguishability with respect to linear tests of the distribution (that is,
[Vid20] proves small-bias rather than full indistinguishability). Both of these relaxations are unacceptable in our
setting, and achieving the latter speciÔ¨Åcally requires a diÔ¨Äerent proof strategy.
9


With a little more work, one can actually show that the veriÔ¨Åer‚Äôs entire output distribution in
the h-basis is computationally indistinguishable from the following distribution DP ‚àó,2-to-1:
‚Ä¢ Sample keys (pki, ski) ‚ÜêCf. Run P ‚àóto obtain y, |œà‚ü©.
‚Ä¢ For each i such that hi = 0, measure the Ô¨Årst bit of the prover‚Äôs ith response register in the
standard basis to obtain (and output) a bit bi.
‚Ä¢ Measure U |œà‚ü©in the Hadamard basis, obtaining strings (d1, . . . , dN).
‚Ä¢ For each i such that hi = 1, compute (and output) di ¬∑ (1, x0,i ‚äïx1,i).
Aside: Why are these Zj and Xi helpful?
As alluded to earlier, this approach is inspired
by operational deÔ¨Ånitions of ‚Äúhaving an N-qubit state,‚Äù which consists of a state |œà‚ü©and 2N
‚Äúpseudo-Pauli‚Äù observables Z1, . . . , ZN, X1, . . . XN that behave ‚Äúlike Pauli observables‚Äù on |œà‚ü©. For
example, it is possible to prove that many of the ‚ÄúPauli group relations‚Äù hold approximately on
these Xi, Zj with respect to |œà‚ü©, meaning that (for example)
‚ü®œà| ZiXiZi + Xi |œà‚ü©= negl(Œª)
and
‚ü®œà| ZjXiZj ‚àíXi |œà‚ü©= negl(Œª)
for i Ã∏= j. In fact, these relations turn out to encode the two basic properties of the TCF fpki:
the adaptive hardcore bit property (encoded in the Ô¨Årst relation) and that fpki is indistinguishable
from injective10 (encoded in the second relation)! We will not directly prove the relations here,
but they are implicit in our full security proof and are the motivation for this proof strategy.
The Extracted State.
Given these protocol observables Z1, . . . , ZN, X1, . . . , XN, it remains to
implement Step (2) of our overall proof strategy: extracting a state |œà‚Ä≤‚ü©whose standard/Hadamard
measurement outcomes match DP ‚àó,Out. At a high level, this is achieved by ‚Äúteleporting‚Äù the state
|œà‚ü©onto a fresh N-qubit register in a way that transforms the ‚Äúpseudo-Paulis" {Xi}, {Zj} into
real Pauli observables {œÉx,i}, {œÉz,j}.
Fix a choice of {Xi, Zi}, |œà‚ü©‚ÜêSamp. For ease of notation, write H = Z ‚äóI ‚äóU so that
|œà‚ü©‚ààH. We would like an eÔ¨Écient extraction procedure that takes as input |œà‚ü©‚ààH and generates
an N-qubit state œÑ such that, roughly speaking, measuring |œà‚ü©with X/Z and measuring œÑ with
œÉX/œÉZ produce indistinguishable outcomes.
Intuition for the Extractor.
Before we describe our extractor, we Ô¨Årst provide some underlying
intuition. For an arbitrary N-qubit Hilbert space, let œÉx,i/œÉz,i denote the Pauli œÉx/œÉz observable
acting on the ith qubit. For each r, s ‚àà{0, 1}N, deÔ¨Åne the N-qubit Pauli ‚Äúparity‚Äù observables
œÉx(r) :=
Y
i:ri=1
œÉx,i , œÉz(s) :=
Y
i:ri=1
œÉz,i.
10Technically, the property encoded is the collapsing of fpki, which is implied by (but not equivalent to) being
indistinguishable from injective.
10


Suppose for a moment that |œà‚ü©‚ààH is already an N-qubit state (i.e., H is an N-qubit Hilbert
space) and moreover, that each Xi/Zi observable is simply the corresponding Pauli observable
œÉx,i/œÉz,i. While these assumptions technically trivialize the task (the state already has the form
we want from the extracted state), it will be instructive to write down an extractor that
‚Äúteleports‚Äù this state into another N-qubit external register.
We can do this by initializing two N-qubit registers A1 ‚äóA2 to |œÜ+‚ü©‚äóN where |œÜ+‚ü©is the EPR
state (|00‚ü©+ |11‚ü©)/
‚àö
2 (the ith EPR pair lives on the ith qubit of A1 and A2). Now consider the
following steps, which are inspired by the (N-qubit) quantum teleportation protocol
1. Initialize a 2N-qubit ancilla W to

02N
, and apply H‚äó2N to obtain the uniform superposition.
2. Apply a ‚Äúcontrolled-Pauli‚Äù unitary, which does the following for all r, s ‚àà{0, 1}N and all
|œÜ‚ü©‚ààH ‚äóA1:
|r, s‚ü©W |œÜ‚ü©H,A1 ‚Üí|r, s‚ü©W (œÉx(r)œÉz(s)H ‚äóœÉx(r)œÉz(s)A1) |œÜ‚ü©H,A1
3. Apply the unitary that XORs onto W the outcome of performing N Bell-basis measurements11
on A1 ‚äóA2 onto W, i.e., for all u, v, r, s ‚àà{0, 1}N:
|u, v‚ü©W (œÉx(r)œÉz(s) ‚äóId)A1,A2

œÜ+‚äóN
A1,A2 ‚Üí|u ‚äïr, v ‚äïs‚ü©W (œÉx(r)œÉz(s) ‚äóId)A1,A2

œÜ+‚äóN
A1,A2 .
Finally, discard W.
One can show that the resulting state is
1
2N
X
r,s‚àà{0,1}N
(œÉx(r)œÉz(s) ‚äóœÉx(r)œÉz(s) ‚äóId) |œà‚ü©H

œÜ+
A1,A2 =

œÜ+
H,A1 |œà‚ü©A2 ,
(1)
where |œà‚ü©is now ‚Äúteleported‚Äù into the A2 register.
The Full Extractor.
To generalize this idea to the setting where |œà‚ü©‚ààH is an arbitrary quantum
state and {Xi, Zi}i are an arbitrary collection of 2N observables, we simply replace each œÉx(r)
and œÉz(s) acting on H above with the corresponding parity observables X(r), Z(s), deÔ¨Åned
analogously (for r, s ‚àà{0, 1}N as
Z(s) =
N
Y
i=1
Zsi
i
and X(r) =
N
Y
i=1
Xri
i .
The rough intuition is that as long as the {Xi} and {Zi} observables ‚Äúbehave like‚Äù Pauli observables
with respect to |œà‚ü©, the resulting procedure will ‚Äúteleport‚Äù |œà‚ü©into the N-qubit register A2.
11The Bell basis consists of the 4 states (œÉa
xœÉb
z ‚äóId)

œÜ+
for a, b ‚àà{0, 1} on 2 qubits.
11


Relating Extracted State Measurements to VeriÔ¨Åer Outputs.
With the extracted state
deÔ¨Åned to be the state on A2 after performing the ‚Äúgeneralized teleportation‚Äù described above, it
remains to prove that the distribution DP ‚àó,Ext resulting from measuring the extracted state on A2
in the h-bases is indistinguishable from DP ‚àó,2-to-1.
One can show (by a calculation) that DP ‚àó,Ext is the following distribution (diÔ¨Äerences from
DP ‚àó,2-to-1 in red)
1. Sample keys (pki, ski) ‚ÜêCf. Run P ‚àóto obtain y, |œà‚ü©.
2. For each i such that hi = 0, measure the Ô¨Årst bit of the prover‚Äôs ith response register in the
standard basis to obtain (and output) a bit bi.
3. For each i such that hi = 1, Ô¨Çip a random bit wi and apply the unitary Zwi
i .
4. Measure U |œà‚ü©in the Hadamard basis, obtaining strings (d1, . . . , dN).
5. For each i such that hi = 1, compute (and output) di ¬∑ (1, x0,i ‚äïx1,i) ‚äïwi.
We prove indistinguishability between the N-bit distributions DP ‚àó,Ext and DP ‚àó,2-to-1 by con-
sidering N hybrid distributions, where the diÔ¨Äerence between Hybrid j ‚àí1 and Hybrid j is:
‚Ä¢ an additional application of the unitary Zj in Item 3, and
‚Ä¢ an additional XOR of ej (the jth standard basis vector) in Item 5.
To conclude the soundness proof, we show that Hybrid j ‚àí1 and Hybrid j in the following
three steps.
‚Ä¢ First, we prove that the marginal distributions of Hybrid (j ‚àí1) and Hybrid j on N \{j} are
indistinguishable due to the collapsing property of fpkj. Intuitively this holds because the
marginal distributions on N \ {j} only diÔ¨Äer by the application of Zj, which is undetectable
by collapsing.
‚Ä¢ By invoking an elementary lemma about N-bit indistinguishability, the task reduces to prov-
ing a 1-bit indistinguishability of the jth bit of Hybrid (j ‚àí1) and Hybrid j, conditioned on
an eÔ¨Éciently computable property of the marginal distributions on N \ {j}.
‚Ä¢ Finally, we show that the indistinguishability of the jth bit holds due to the adaptive hardcore
bit property of fpkj. At a very high level, the above jth bit property involves a measurement
of Xj, and the two hybrids diÔ¨Äer in whether a random Zb
j is applied before Xj is measured;
in words, this exactly captures the adaptive hardcore bit security game.
We refer the reader to Section 6.4 for a full proof of indistinguishability.
12


2.5
From a VeriÔ¨Åer-Succinct Measurement Protocol to Succinct Arguments for
BQP
Using Sections 2.3 and 2.4, we have constructed a veriÔ¨Åer-succinct measurement protocol, for
succinctly represented basis strings, with a single bit veriÔ¨Åer challenge. What remains is to convert
this into a (fully) succinct argument system for BQP (or QMA). This is accomplished via the
following transformations:
‚Ä¢ Converting a measurement protocol into a quantum veriÔ¨Åcation protocol. As described ear-
lier, this is achieved by combining the [FHM18] protocol for BQP veriÔ¨Åcation with a lim-
ited quantum veriÔ¨Åer (as modiÔ¨Åed by [ACGH20]) with our measurement protocol, using a
PRF to generate a pseudorandom basis choice instead of a uniformly random basis choice
for the [FHM18, ACGH20] veriÔ¨Åer. This results in a veriÔ¨Åer-succinct argument system for
BQP/QMA with constant soundness error.
‚Ä¢ Parallel repetition to reduce the soundness error.
This follows from the ‚Äúcomputational
orthogonal projectors‚Äù property of the 1-bit challenge protocol and follows from [ACGH20]
(we give a somewhat more abstract formulation of their idea in Appendix A). This results in
a veriÔ¨Åer-succinct argument system for BQP/QMA with negligible soundness error.
‚Ä¢ Converting a veriÔ¨Åer-succinct argument system into a fully succinct argument system. We
elaborate on this last transformation below, as a few diÔ¨Éculties come up in this step.
Assume that we are given a (for simplicity, 4-message) veriÔ¨Åer-succinct argument system for
BQP/QMA. Let m1, m2, m3, m4 denote the four messages in such an argument system. In order to
obtain a fully succinct argument system, we must reduce (1) the prover communication complexity
|m2| + |m4|, and (2) the runtime of the veriÔ¨Åer‚Äôs decision predicate.
The Ô¨Årst idea that comes to mind is to ask the prover to send short (e.g. Merkle tree) com-
mitments œÉ2 and œÉ4 of m2 and m4, respectively, instead of sending m2 and m4 directly. At the
end of the interaction, the prover and veriÔ¨Åer could then engage in a succinct interactive argument
(of knowledge) for a (classical) NP statement that ‚Äúthe veriÔ¨Åer would have accepted the commit-
ted messages underlying œÉ2 and œÉ4‚Äù. One could potentially employ Kilian‚Äôs succinct interactive
argument of knowledge for NP which was recently shown to be post-quantum secure under the
post-quantum LWE assumption [CMSZ21].
There are a few issues with this naive idea. First of all, the veriÔ¨Åer‚Äôs decision predicate is private
(it depends on the secret key SK in the measurement protocol and the PRF seed for its basis),
so the NP statement above is not well-formed. One reasonable solution to this issue is to simply
have the veriÔ¨Åer send this secret information st after the veriÔ¨Åer-succinct protocol emulation has
occurred and before the NP-succinct argument has started. For certain applications (e.g. obtaining
a non-interactive protocol in the QROM) we would like to have a public-coin protocol; this can
be achieved by using fully homomorphic encryption to encrypt this secret information in the Ô¨Årst
round rather than sending it in the clear in a later round. For this overview, we focus on the
private-coin variant of the protocol.
13


Now, we can indeed write down the appropriate NP relation12
RV ={((h, m1, œÉ2, m3, œÉ4, st), (m2, m4)) : œÉ2 = h(m2) and
œÉ4 = h(m4) and V (st, m1, m2, c, m4) = accept}
and execute the aforementioned strategy. However, this construction turns out not to work. Specif-
ically, it does not seem possible to convert a cheating prover P ‚àóin the above fully succinct protocol
into a cheating prover P ‚àó‚àófor the veriÔ¨Åer-succinct protocol; for example, P ‚àó‚àóneeds to be able to
produce a message m2 given only m1 from the veriÔ¨Åer; meanwhile, the message m1 can only be ex-
tracted from P ‚àóby repeatedly rewinding P ‚àó‚Äôs last message algorithm, which requires the veriÔ¨Åer‚Äôs
secret information st as input! This does not correspond to a valid P ‚àó‚àó, who does not have access
to st when computing m2.
Our reÔ¨Åned compiler is to execute several arguments of knowledge: one right after the prover
sends œÉ2, proving knowledge of m2; another one right after she sends œÉ4, proving knowledge of m4
(both before receiving the secret state st from the veriÔ¨Åer); and a third one for the relation RV
described above. The Ô¨Årst two arguments of knowledge are for the relation
RH = {(h, œÉ), m) : h(m) = œÉ}
This allows for immediate extraction of m2 and m3 and appears to clear the way for a reduction
between the veriÔ¨Åer-succinct and fully succinct protocol soundness properties.
However, there is one remaining problem: the argument-of-knowledge property of Kilian‚Äôs pro-
tocol proved by [CMSZ21] is insuÔ¨Éciently composable to be used in our compiler. They demon-
strate an extractor for Kilian‚Äôs protocol that takes any quantum cheating prover that convinces
the veriÔ¨Åer and extracts a witness from them. However, their post-quantum extractor might sig-
niÔ¨Åcantly disturb the prover‚Äôs state, meaning that once we extract m2 above, we may not be able
to continue the prover execution in our reduction.
Fortunately, a recent work [LMS21] shows that a slight variant of Kilian‚Äôs protocol is a suc-
cinct argument of knowledge for NP satisfying a composable extraction property called ‚Äústate-
preservation.‚Äù This security property is exactly what is required for our compiler to extract a valid
cheating prover strategy P ‚àó‚àófor the veriÔ¨Åer-succinct argument given a cheating prover P ‚àófor the
compiled protocol. A full discussion of this is given in Section 9.
This completes our construction of a succinct argument system for BQP (and QMA). We discuss
additional results (2-message protocols, zero knowledge, batch arguments) in Section 10.
3
Preliminaries
3.1
Quantum Information
Let H be a Ô¨Ånite-dimensional Hilbert space. A pure state is a unit vector |œà‚ü©‚ààH. Let D(H)
denote the set of all positive semideÔ¨Ånite operators on H with trace 1.
A mixed state is an
operator œÅ ‚ààD(H), and is often called a density matrix. We sometimes divide H into named
registers written in uppercase calligraphic font, e.g., H = A ‚äóB ‚äóC.
12Note that the veriÔ¨Åer also takes as input the QMA instance, but we suppress it here for clarity.
14


For a density matrix œÅ ‚ààD(H), where H ‚âÉ(C2)‚äó‚Ñì, we sometimes use the shortcut M(h, œÅ) to
denote the distribution resulting from measuring each qubit of œÅ (where the qubits are speciÔ¨Åed
by the isomorphism H ‚âÉ(C2)‚äó‚Ñì) in the basis determined by h ‚àà{0, 1}‚Ñì. By convention, hi = 0
corresponds to measuring the i-th register in the standard basis {|0‚ü©, |1‚ü©} and hi = 1 corresponds
to measuring the i-th register in the Hadamard basis {|+‚ü©, |‚àí‚ü©}.
An observable is represented by a Hermitian operator O on H. In particular, any observable O
can be written in the form P
i ŒªiŒ†i where {Œªi} are real numbers and P
i Œ†i = Id. The measurement
corresponding to an observable O is the projective measurement {Œ†i} with corresponding outcomes
{Œªi}. A binary observable satisÔ¨Åes the additional requirement that O2 = Id. Notice that for any
binary observable, O is a unitary matrix with eigenvalues in {1, ‚àí1}. In this case we sometimes
treat the outcomes as bits through the usual correspondence 1 ‚Üí0, ‚àí1 ‚Üí1.
Given a binary observable O, we deÔ¨Åne its corresponding projection operators O+ = 1
2(Id+O)
and O‚àí= 1
2(Id ‚àíO). O+ and O‚àícorrespond to projecting onto the +1 and ‚àí1 eigenspaces of O,
respectively, and thus form a binary projective measurement.
The Class QMA.
A language L = (Lyes, Lno) is in QMA if and only if there is a uniformly
generated family of polynomial-size quantum circuits V = {VŒª}Œª‚ààN such that for every Œª, VŒª takes
as input a string x ‚àà{0, 1}Œª and a quantum state |œÜ‚ü©on p(Œª) qubits and returns a single bit and
moreover the following conditions hold.
‚Ä¢ For all x ‚ààLyes of length Œª, there exists a quantum state |œà‚ü©on at most p(Œª) qubits such
that the probability that VŒª accepts (x, |œÜ‚ü©) is at least 2/3. We denote the (possibly inÔ¨Ånite)
set of quantum states (which we will also refer to as quantum witnesses) that make VŒª accept
x by R(x).
‚Ä¢ For all x ‚ààLno of length Œª, and all quantum states |œà‚ü©on at most p(Œª) qubits, it holds that
VŒª accepts on input (x, |œà‚ü©) with probability at most 1/3.
3.2
Black-Box Access to Quantum Algorithms
Let A be a polynomial-time quantum algorithm with internal state œÅ ‚ààD(I) that takes a classical
input r and produces a classical output z. Without loss of generality, the behavior of A can be
described as follows:
1. Apply an eÔ¨Écient classical algorithm to r to generate the description of a unitary U(r).
2. Initialize registers Z ‚äóI to |0‚ü©
‚ü®0|Z ‚äóœÅI.
3. Apply U(r) to Z ‚äóI, measure Z in the computational basis, and return the outcome z.
A quantum oracle algorithm SA with black-box access to (A, œÅ) does not have direct access to
the adversary‚Äôs internal registers I, and can only operate on the state œÅ ‚ààD(I) by applying U(r)
or U(r)‚Ä† for any r. In more detail, black-box access to (A, œÅ) means the following:
‚Ä¢ The registers Z ‚äóI are initialized to |0‚ü©
‚ü®0|Z ‚äóœÅI.
15


‚Ä¢ Once the Z ‚äóI registers are initialized, the algorithm is permitted to perform arbitrary
operations on the Z register, but can only act on the I registers by applying U(r) or U(r)‚Ä†
for any r. We explicitly permit the U(r) and U(r)‚Ä† gates to be controlled on any external
registers (i.e., any registers other than the registers Z ‚äóI to which U(r) is applied).
We note that this deÔ¨Ånition is consistent with the notions of interactive quantum machines
and oracle access to an interactive quantum machine used in e.g. [Unr12] and other works on
post-quantum zero-knowledge.
The Binary Input Case.
Following [Mah18], in the special case where r ‚àà{0, 1}, it will be
convenient to re-deÔ¨Åne the internal state to be œÅ := U(0)(|0‚ü©
‚ü®0|Z ‚äóœÅ‚Ä≤
I)U(0)‚Ä† (where œÅ‚Ä≤
I ‚ààD(I)
denotes the ‚Äúoriginal‚Äù internal state), so that the behavior of A on r = 0 is to simply measure Z
in the computational basis, and on r = 1 it applies the unitary U := U(1)U(0)‚Ä† to its state and
then measures the Z register. Notice that in this case, the internal state is technically on Z ‚äóI
instead of just I. Thus, black-box access to a quantum algorithm with binary input is formalized
as follows:
‚Ä¢ The registers Z ‚äóI are initialized to œÅ := U(0)(|0‚ü©
‚ü®0|Z ‚äóœÅ‚Ä≤
I)U(0)‚Ä†.
‚Ä¢ Once the Z ‚äóI registers are initialized, the algorithm is permitted to perform arbitrary
operations on the Z register, but can only act on the I registers by applying (possibly
controlled) U or U ‚Ä† gates.
In this special case, an algorithm with black-box access to A is denoted SU,œÅ.
We remark that these deÔ¨Ånitions are tailored to the two-message challenge-response setting,
whereas the protocols we consider in this paper have more rounds of interaction. However, our
analysis will typically focus on a single back-and-forth round of interaction (e.g., the last two mes-
sages of the [Mah18] protocol), so œÅ will be the intermediate state of the interactive algorithm right
before the next challenge is sent.13 Moreover, the unitaries {U(r)}r can be treated as independent
of the (classical) protocol transcript before challenge r is sent, since we can assume this transcript
is saved in œÅ.
3.3
Interactive Arguments
In what follows we deÔ¨Åne the notion of an interactive argument for QMA languages. We denote
such arguments by (P, V ), and denote the output bit of the veriÔ¨Åer by Out(P, V ).
DeÔ¨Ånition 3.1. An interactive argument (P, V ) for a language L = (Lyes, Lno) ‚ààQMA with
relation R(x) is a (classical) 2-party interactive protocol between a QPT prover P and a
p.p.t. veriÔ¨Åer V , with the following completeness and soundness guarantees:
13In the multi-round setting, ‚Äúre-deÔ¨Åning‚Äù the intermediate state to be œÅ = U(0)(|0‚ü©
‚ü®0|Z ‚äóœÅ‚Ä≤
I)U(0)‚Ä† can be imple-
mented by replacing any unitary W applied in the previous round with U(0)W; this follows the conventions used
in [Mah18].
16


Completeness.
For all Œª ‚ààN, there exists a polynomial k = k(Œª)
such that for all x ‚ààLyes,
and all |œÜ‚ü©‚ààR(x), it holds that
Pr
h
Out

P(|œÜ‚ü©‚äók(Œª) , x), V (x)

= 1
i
‚â•1 ‚àínegl(Œª).
Computational Soundness.
For all Œª ‚ààN, all x ‚ààLno, and all non-uniform QPT provers
P ‚àó, it holds that
Pr [Out(P ‚àó(x), V (x)) = 1] ‚â§negl(Œª).
Batch Arguments.
We also consider a sub-class of interactive arguments where the prover
simultaneously engages the veriÔ¨Åer on n sub-instances (x1, . . . , xn), where each xi is supposed to
be a Yes-instance of a Ô¨Åxed language Li.
We require the following notion of (computational)
soundness.
DeÔ¨Ånition 3.2 (Soundness). An interactive argument (P, V ) for a batch language L = L1 √ó
. . . √ó Ln ‚ààQMA with relation R(x) is sound if for all Œª ‚ààN, all polynomials n = n(Œª), all
indices i ‚àà[n], all statements (x1, . . . , xn), where xi ‚ààLno, and all non-uniform QPT provers
P ‚àó, it holds that
Pr [Out(P ‚àó(x1, . . . , xn), V ((x1, . . . , xn))) = 1] ‚â§negl(Œª).
3.4
Computational Indistinguishability
Two classical distribution ensembles {(X(Œª), Y (Œª))}Œª are said to be post-quantum computationally
indistinguishable if for every non-uniform QPT algorithm A = {(A(Œª), œÅ(Œª))}Œª (that outputs a bit
b), we have that


E
h
A(Œª)(X(Œª), œÅ(Œª))
i
‚àíE
h
A(Œª)(Y (Œª), œÅ(Œª))
i

 = negl(Œª).
Two quantum state ensembles {œÅ(Œª)
0 , œÅ(Œª)
1 }Œª are said to be computationally indistinguishable
if for every non-uniform QPT algorithm A = {A(Œª), œÅ(Œª)} (that outputs a bit b), we have that


E
h
A(Œª)(œÅ(Œª), œÅ(Œª)
0 )
i
‚àíE
h
A(Œª)(œÅ(Œª), œÅ(Œª)
1 )
i 

 = negl(Œª).
Equivalently, {œÅ(Œª)
0 , œÅ(Œª)
1 }Œª are computationally indistinguishable if for every eÔ¨Éciently com-
putable non-uniform binary observable (R, œÉ), we have that


 Tr(R(œÅ0 ‚äóœÉ)) ‚àíTr(R(œÅ1 ‚äóœÉ))


 = negl(Œª).
We will occasionally use the notation œÅ0 ‚âàc œÅ1 to denote computational indistinguishability of
{œÅ(Œª)
0 , œÅ(Œª)
1 }Œª.
More generally, we use (T(Œª), Œµ(Œª))-indistinguishability to denote computational indistiguisha-
bility as above where the distinguisher is allowed to run in time T and the advantage is required
to be at most Œµ.
17


3.5
Mahadev Randomized TCFs
In this section, we deÔ¨Åne the cryptographic primitive used by Mahadev [Mah18] to obtain a (non-
succinct) delegation scheme for QMA with classical veriÔ¨Åcation. The primitive is closely related
to Regev encryption [Reg05] and LWE-based ‚Äúlossy‚Äù trapdoor functions [PW08, PVW08, GVW15],
but makes use of special-purpose structure relevant for quantum functionality. Most of this special-
purpose structure, in particular, the ‚Äúadaptive hardcore bit‚Äù, was introduced in the work of Braker-
ski, Christiano, Mahadev, Vazirani and Vidick [BCM+18], but [Mah18] further requires ‚Äúdual-mode
key generation‚Äù in addition to the [BCM+18] properties.
Given the numerous special-purpose
requirements, we refer to the primitive as ‚ÄúMahadev randomized trapdoor claw-free functions
(rTCFs).‚Äù14
DeÔ¨Ånition 3.3. A Mahadev randomized trapdoor claw-free function family (Mahadev rTCF)
ClawFree is described by a tuple of eÔ¨Écient classical algorithms (Gen, Eval, Invert, Check, Good)
with the following syntax:
‚Ä¢ Gen(1Œª, mode) is a dual-mode PPT key generation algorithm that takes as input a secu-
rity parameter Œª in unary, and a bit mode ‚àà{0, 1}, and it outputs a public key pk and
a private key sk. The description of the public key implicitly deÔ¨Ånes a domain of the
form {0, 1}√óDpk for the randomized function fpk. We view Dpk as an explicit (eÔ¨Éciently
veriÔ¨Åable and samplable) subset of {0, 1}‚Ñì(Œª), so that applying bit operations to elements
of Dpk is well-deÔ¨Åned.
In our context, mode = 0 samples keys for an injective function and mode = 1 samples
keys for a two-to-one function. For the sake of readability, we use a descriptive notation
by which mode ‚àà{injective, 2-to-1}, where mode = injective corresponds to mode = 0 and
mode = 2-to-1 corresponds to mode = 1.
‚Ä¢ Eval(pk, b, x) is a (possibly probabilistic) algorithm that takes as input a public key pk, a
bit b ‚àà{0, 1} and an element x ‚ààDpk, and outputs a string y with distribution œá.
‚Ä¢ Invert(mode, sk, y) is a deterministic algorithm that takes as input mode ‚àà{injective, 2-to-1},
a secret key sk, and an element y in the range. If mode = injective then it outputs a pair
(b, x) ‚àà{0, 1} √ó Dpk or ‚ä•. If mode = 2-to-1 then it outputs two pairs (0, x0) and (1, x1)
with x0, x1 ‚ààDpk, or ‚ä•.
‚Ä¢ Check(pk, b, x, y) is a deterministic algorithm takes as input a public key pk, a bit b ‚àà
{0, 1}, an element x ‚ààDpk, and an element y in the range, and it outputs a bit.
‚Ä¢ Good(x0, x1, d) is a deterministic poly-time algorithm that takes as input two domain
elements x0, x1 ‚ààDpk and a string d ‚àà{0, 1}‚Ñì+1.
It outputs a bit that characterizes
membership in a set that we call
Goodx0,x1 := {d : Good(x0, x1, d) = 1}.
14Actually, [Mah18] requires an extra (second) hardcore bit property (Property 2 of DeÔ¨Ånition 4.4 in [Mah18]) that
we drop from our deÔ¨Ånition, as our proof does not require it.
18


Moreover, we stipulate that Good(x0, x1, d) ignores the Ô¨Årst bit of d.15
We require that the following properties are satisÔ¨Åed.
1. Correctness:
(a) For all (pk, sk) in the support of Gen(injective, 1Œª): For every b ‚àà{0, 1}, every x ‚àà
Dpk, and every y ‚ààSupp(Eval(pk, (b, x))),
Invert(injective, sk, y) = (b, x).16
(b) For all (pk, sk) in the support of Gen(2-to-1, 1Œª): For every b ‚àà{0, 1}, every x ‚ààDpk,
and every y ‚ààSupp(Eval(pk, (b, x))),
Invert(2-to-1, sk, y) = ((0, x0), (1, x1))
such that xb = x and y ‚ààSupp(Eval(pk, (Œ≤, xŒ≤))) for every Œ≤ ‚àà{0, 1}.
(c) For every (pk, sk) ‚ààSupp(Gen(2-to-1, 1Œª)) ‚à™Supp(Gen(injective, 1Œª)), every b ‚àà{0, 1}
and every x ‚ààD,
Pr[Check(pk, (b, x), y) = 1] = 1
if and only if y ‚ààSupp(Eval(pk, (b, x))).
(d) For every (pk, sk) in the support of Gen(2-to-1, 1Œª) and every pair of domain elements
x0, x1, the density of Goodx0,x1 is 1 ‚àínegl(Œª).
2. Key Indistinguishability:
{pk : (pk, sk) ‚ÜêGen(2-to-1, 1Œª)} ‚âàc {pk : (pk, sk) ‚ÜêGen(injective, 1Œª)}
3. Adaptive Hardcore Bit: For every BQP adversary A = (A‚Ä≤, A‚àû) there exists a negli-
gible function ¬µ such that for every Œª ‚ààN, the following diÔ¨Äerence of probabilities is
equal to ¬µ(Œª):


 Pr[A1(pk, y) = (d, (b, x)) : Check(pk, b, x, y) = 1
‚àß
d ¬∑ (1, x0 ‚äïx1) = 0
‚àß
d ‚ààGoodx0,x1]
‚àíPr[A1(pk, y) = (d, (b, x)) : Check(pk, b, x, y) = 1
‚àß
d ¬∑ (1, x0 ‚äïx1) = 1
‚àß
d ‚ààGoodx0,x1]



where the probabilities are over the experiment that generates (pk, sk) ‚ÜêGen(2-to-1, 1Œª),
y ‚ÜêA0(pk), and where ((0, x0), (1, x1)) = Invert(2-to-1, sk, y).
Lemma 3.4 ([BCM+18, Mah18]). Assuming LWE, there is a collection of Mahadev randomized
TCFs.
15We depart slightly from notation in prior work, which deÔ¨Ånes d to be an element of {0, 1}‚Ñì(corresponding to
the last ‚Ñìbits of our d).
16Note that this implies that Supp(Eval(pk, (b1, x1))) ‚à©Supp(Eval(pk, (b2, x2))) = ‚àÖfor every (b1, x1) Ã∏= (b2, x2).
This can be enforced in the LWE-based instantiation by using truncated discrete Gaussian errors
19


Remark 3.5. For some of our applications (and for simplicity of proofs), we will actually
require an rTCF that is perfectly correct, which means that the correctness properties (a)
and (b) hold with probability 1.
That is, they hold for all (pk, sk) ‚ààGen(injective, 1Œª) and
(pk, sk) ‚ààGen(2-to-1, 1Œª) respectively. We brieÔ¨Çy argue that this is possible. In the injective
mode case, this is possible because the sampling procedure for injective keys given in [Mah18,
Section 9.2] can determine whether the key it sampled is indeed injective and if not, output
a Ô¨Åxed hard-coded injective key. In the 2-to-1 mode case, the sampling procedure given in
[BCM+18, Section 4.1] is perfect except for when s = 0n. Thus, we can again hard-code a
Ô¨Åxed 2-to-1 key to output instead whenever s = 0n.
3.6
Collapsing Hash Functions
Collapsing Hash Functions.
Let H = {HŒª}Œª‚ààN be a hash function family where each HŒª is a
distribution over functions h : {0, 1}n(Œª) ‚Üí{0, 1}‚Ñì(Œª).
DeÔ¨Åne the collapsing experiment CollapseExptH,Œª,b(D) on quantum distinguisher D as follows.
CollapseExptH,Œª,b(D):
1. The challenger samples h ‚ÜêHŒª and sends h to the distinguisher D.
2. The distinguisher replies with a classical binary string y ‚àà{0, 1}‚Ñì(Œª) and an n(Œª)-qubit quan-
tum state on the register X. Note that the requirement that y be classical can be enforced
by having the challenger immediately measure these registers upon receiving them.
3. The challenger computes h in superposition on the n(Œª)-qubit quantum state, and measures
the bit indicating whether the output of h equals y. If the output does not equal y, the
challenger aborts and outputs ‚ä•.
4. If b = 0, the challenger does nothing. If b = 1, the challenger measures the n(Œª)-qubit state
in the standard basis.
5. The challenger returns the contents of the X register to the distinguisher.
6. The distinguisher outputs a bit b‚Ä≤.
DeÔ¨Ånition 3.6 ([Unr16b]). H = {HŒª}Œª is collapsing if for every security parameter Œª ‚ààN and
any polynomial-size quantum distinguisher D = {DŒª}Œª, there exists a negligible function ¬µ
such that

Pr

CollapseExptH,Œª,0(DŒª) = 1

‚àíPr

CollapseExptH,Œª,1(DŒª) = 1

 ‚â§¬µ(Œª).
Unruh [Unr16a] constructs collapsing hash functions from lossy functions, which can be based
on LWE [PW08].
Lemma 3.7 ([PW08, Unr16a]). Assuming LWE, a family of collapsing hash functions {HŒª :
{0, 1}‚àó‚Üí{0, 1}Œª}Œª exists.
20


3.7
Fully Homomorphic Encryption
We deÔ¨Åne fully homomorphic encryption (FHE), which is used in Section 9. A fully homomorphic
encryption scheme FHE = (FHE.Gen, FHE.Enc, FHE.Dec, FHE.Eval) for (classical) polynomial-time
computation is a tuple of four PPT algorithms.
‚Ä¢ Gen(1Œª) takes as input the security parameter and outputs a key pair (pk, sk).
‚Ä¢ Enc(pk, m) takes as input a message m and outputs a ciphertext ct.
‚Ä¢ Eval(f, ct) takes as input a ciphertext ct corresponding to an n-bit plaintext as well as a
function f : {0, 1}n ‚Üí{0, 1}. It outputs a ciphertext ctf.
‚Ä¢ Dec(sk, ct) takes as input the secret key and a ciphertext. It outputs a message.
We require the following properties.
‚Ä¢ Evaluation/Decryption Correctness: for any (polynomial-size circuit) function f : {0, 1}n ‚Üí
{0, 1} and any message m ‚àà{0, 1}n, we have that
Dec(sk, Eval(f, Enc(pk, m))) = f(m)
with probability 1 ‚àínegl(Œª) over the parameter sampling.
‚Ä¢ Compactness: we require that FHE.Eval(f, Enc(pk, m)) has a Ô¨Åxed size poly(Œª) independent
of |f|, |m|.
‚Ä¢ Semantic Security: For any pair of messages (m0, m1), we have that (pk, FHE.Enc(pk, m0)) ‚âàc
(pk, FHE.Enc(pk, m1)).
Theorem 3.8 ([Gen09, BV11, BGV12, BV14]). Under circular-secure variants of the Learn-
ing with Errors assumption, there exists a fully homomorphic encryption scheme for all
polynomial-time computable functions. If the circular LWE variant is post-quantum, then so
is the FHE scheme.
Under the standard LWE assumption, there exists a FHE scheme for all polynomial-size
circuits of depth d(Œª), where the scheme has compactness poly(Œª, d).
3.8
Indistinguishability Obfuscation
An indistinguishability obfuscator (iO) is an algorithm iO that takes as input a circuit C and
satisÔ¨Åes the following properties.
‚Ä¢ Functional Equivalence: for any (polynomial-size) circuit circuit C : {0, 1}n ‚Üí{0, 1}m
and any input x ‚àà{0, 1}n, we have that
iO(C)(x) = C(x).
21


‚Ä¢ Security: For any pair of functionally equivalent circuits (C0, C1), we have that
iO(C0) ‚âàc iO(C1).
We mention that, while some recent candidates for iO (such as [JLS21]) can be broken using
quantum algorithms, others, such as [BGMZ18, CVW18, BDGM20, WW21, GP21, DQV+21],
are plausibly post-quantum secure. Furthermore, it will be convenient for us to assume iO with
perfect correctness to simplify our analysis (in particular the argument in Section 10.3). We point
out that this property is already satisÔ¨Åed by most candidates and can also be attained via generic
transformations [BV17].
3.9
Puncturable PRFs
DeÔ¨Ånition 3.9 (Puncturable PRF [BW13, BGI14, KPTZ13, SW14]). A puncturable PRF family
is a family of functions
F =
n
FŒª,s : {0, 1}ŒΩ(Œª) ‚Üí{0, 1}¬µ(Œª)o
Œª‚ààN,s‚àà{0,1}‚Ñì(Œª)
with associated (deterministic) polynomial-time algorithms (F.Eval, F.Puncture, F.PuncEval)
satisfying
‚Ä¢ For all x ‚àà{0, 1}ŒΩ(Œª) and all s ‚àà{0, 1}‚Ñì(Œª), F.Eval(s, x) = FŒª,s(x).
‚Ä¢ For all distinct x, x‚Ä≤ ‚àà{0, 1}ŒΩ(Œª) and all s ‚àà{0, 1}‚Ñì(Œª),
F.PuncEval(F.Puncture(s, x), x‚Ä≤) = F.Eval(s, x‚Ä≤)
For ease of notation, we write Fs(x) and F.Eval(s, x) interchangeably, and we write s{x} to
denote F.Puncture(s, x).
F is said to be (s, Œ¥)-secure if for every {x(Œª) ‚àà{0, 1}ŒΩ(Œª)}Œª‚ààN, the following two distribution
ensembles (indexed by Œª) are Œ¥(Œª)-indistinguishable to circuits of size s(Œª):
(S{x(Œª)}, FS(x(Œª))) where S ‚Üê{0, 1}‚Ñì(Œª)
and
(S{x(Œª)}, U) where S ‚Üê{0, 1}‚Ñì(Œª), U ‚Üê{0, 1}¬µ(Œª).
Theorem 3.10 ([GGM84, KPTZ13, BW13, BGI14, SW14]). If {polynomially secure, subex-
ponentially secure} one-way functions exist, then for all functions ¬µ : N ‚ÜíN (with 1¬µ(ŒΩ)
polynomial-time computable from 1ŒΩ), and all Œ¥ : N ‚Üí[0, 1] with Œ¥(ŒΩ) ‚â•2‚àípoly(ŒΩ), there are
polynomials ‚Ñì(Œª), ŒΩ(Œª) and a {polynomially secure, (
1
Œ¥(ŒΩ(Œª)), Œ¥(ŒΩ(Œª)))-secure} puncturable PRF
family
F¬µ =
n
FŒª,s : {0, 1}ŒΩ(Œª) ‚Üí{0, 1}¬µ(ŒΩ(Œª))}Œª‚ààN,s‚àà{0,1}‚Ñì(Œª)
o
.
22


4
Commit-and-Measure Protocols
4.1
DeÔ¨Åning Commit-and-Measure Protocols
In this section, we formalize the notion of a commit-and-measure protocol, which was informally
described in [Mah18]. A commit-and-measure protocol enables a classical veriÔ¨Åer to obtain the
results of measuring, in the standard or Hadamard basis, each qubit of an N-qubit quantum state
œÉ held by the prover. More precisely, the veriÔ¨Åer encodes its choice of basis with a classical circuit
C : [N] = {0, 1}log N ‚Üí{0, 1}, where C(i) = b speciÔ¨Åes the basis for the measurement of the ith
qubit. We adopt the convention that b = 0 corresponds to the standard basis and b = 1 corresponds
to the Hadamard basis. Note that in Mahadev‚Äôs original protocol, C is given as an explicit string
(C(0), C(1), . . . , C(N ‚àí1)), but our eventual succinct protocols will require circuits C with size
much smaller than N.
DeÔ¨Ånition 4.1 (Commit-and-Measure Protocol Syntax). An N-qubit commit-and-measure pro-
tocol between a quantum polynomial-time prover P = (Commit, Open) and a classical proba-
bilistic polynomial-time veriÔ¨Åer V = (Gen, Test, Out) has the following syntax.
1. The veriÔ¨Åer samples (pk, sk) ‚ÜêGen(1Œª, C), where C : [N] = {0, 1}log N ‚Üí{0, 1} represents
a basis vector h ‚àà{0, 1}N, obtaining public parameters pk and secret parameters sk. It
sends the public parameters pk to the prover.
2. The prover computes (y, œÅ) ‚ÜêCommit(pk, œÉ), obtaining a classical ‚Äúcommitment‚Äù string
y and a private quantum state œÅ. It sends y to the veriÔ¨Åer.
3. The veriÔ¨Åer samples a random challenge bit c ‚Üê{0, 1} and sends c to the prover; c = 0
corresponds to a ‚Äútest round‚Äù and c = 1 corresponds to a ‚Äúmeasurement round‚Äù.
4. The prover computes z ‚ÜêOpen(œÅ, c), obtaining a classical string z that it sends to the
veriÔ¨Åer.
5. If c = 0, the veriÔ¨Åer computes {acc, rej} ‚ÜêTest(pk, (y, z)).
If c = 1, the veriÔ¨Åer computes m ‚ÜêOut(sk, (y, z)) to obtain a classical string m ‚àà{0, 1}N
of measurement outcomes.
The protocol is required to satisfy the following completeness (DeÔ¨Ånition 4.2) and soundness
(DeÔ¨Ånition 4.5) properties. For the deÔ¨Ånitions below, we write M(h, œÉ) to denote the distribution
of outcomes from measuring œÉ in the basis h.
DeÔ¨Ånition 4.2 (Completeness). A commit-and-measure protocol is required to satisfy two
completeness properties.
1. (Test Round Completeness) For all C : [N] ‚Üí{0, 1} and N-qubit states œÉ:
Pr
Ô£Æ
Ô£∞acc ‚ÜêTest(pk, (y, z)) :
(pk, sk) ‚ÜêGen(1Œª, C)
(y, œÅ) ‚ÜêCommit(pk, œÉ)
z ‚ÜêOpen(œÅ, 0)
Ô£π
Ô£ª= 1 ‚àínegl(Œª).
23


2. (Measurement Round Completeness) For all C : [N] ‚Üí{0, 1} and N-qubit states œÉ:
Ô£±
Ô£≤
Ô£≥m ‚ÜêOut(sk, (y, z)) :
(pk, sk) ‚ÜêGen(1Œª, C)
(y, œÅ) ‚ÜêCommit(pk, œÉ)
z ‚ÜêOpen(œÅ, 1)
Ô£º
Ô£Ω
Ô£æ‚âàc M(h, œÉ),
where h ‚àà{0, 1}N is such that hi = C(i) for all i ‚àà[N] = {0, 1}log N.
Remark 4.3. The [Mah18] protocol satisÔ¨Åes statistical measurement round completeness, but
our veriÔ¨Åer-succinct commit-and-measure protocol will not.
Remark 4.4. One of our applications will require a measurement protocol with perfect com-
pleteness, which stipulates that the above completeness guarantees hold over all (pk, sk) ‚àà
Gen(1Œª, C) (and where the measurement round completeness is statistical rather than compu-
tational). This can be achieved by using an rTCF with perfect correctness, which we discuss
in Section 3.5, and, in the succinct case, an indistinguishability obfuscation scheme with
perfect correctness (Section 3.8).
To state our soundness deÔ¨Ånition (DeÔ¨Ånition 4.5), we Ô¨Årst specify the registers that any non-
uniform cheating prover acts on:
‚Ä¢ P contains the public parameters pk,
‚Ä¢ Y contains the classical commitment string y,
‚Ä¢ Z contains the classical opening string z,
‚Ä¢ I contains the prover‚Äôs initial state and its internal work registers.
In a protocol execution, P is initialized with |pk‚ü©
‚ü®pk|. A non-uniform cheating prover
P ‚àó= (œÅ0, UCommit‚àó, UOpen‚àó,0, UOpen‚àó,1)
is parameterized by:
‚Ä¢ An arbitrary quantum state œÅ0 ‚ààD(Y ‚äóZ ‚äóI). In a protocol execution with e
P, Y ‚äóZ ‚äóI
is initialized with œÅ0.
‚Ä¢ An adversarial commitment unitary UCommit‚àóon P ‚äóY ‚äóZ ‚äóI of the form
X
pk
|pk‚ü©
‚ü®pk|P ‚äó(UCommit‚àó,pk)Y,Z,I.
That is, UCommit‚àóis classically controlled on P. In particular, the adversarial prover‚Äôs com-
mitment on veriÔ¨Åer message pk is obtained by measuring register Y of
UCommit‚àó(|pk‚ü©
‚ü®pk|P ‚äó(œÅ0)Y,Z,I)
in the computational basis to obtain y.
24


‚Ä¢ An adversarial opening unitary UOpen‚àó,0 on P ‚äóY ‚äóZ ‚äóI corresponding to the prover‚Äôs
behavior in the test round (b = 0) of the form:
X
pk,y
|pk, y‚ü©
‚ü®pk, y|P,Y ‚äó(UOpen‚àó,0,pk,y)Z,I.
That is, UOpen‚àó,0 is classically controlled on P and Y. In particular, given a commitment
string y and residual prover state œÅ ‚ààD(Z ‚äóI), the prover‚Äôs response on challenge c = 0 is
obtained by measuring register Z of
UOpen‚àó,0(|pk, y‚ü©
‚ü®pk, y|P,Y ‚äóœÅZ,I)
in the computational basis to obtain z.
‚Ä¢ An adversarial opening unitary UOpen‚àó,1 on P ‚äóY ‚äóZ ‚äóI corresponding to the prover‚Äôs
behavior in the measurement round (b = 1) of the form:
X
pk,y
|pk, y‚ü©
‚ü®pk, y|P,Y ‚äó(UOpen‚àó,1,pk,y)Z,I.
In particular, given a commitment string y and residual prover state œÅ ‚ààD(Z ‚äóI), the
prover‚Äôs response on challenge c = 1 is obtained by measuring register Z of
UOpen‚àó,1(|pk, y‚ü©
‚ü®pk, y|P,Y ‚äóœÅZ,I)
in the Hadamard basis to obtain z.
Following [Mah18], we can assume without loss of generality that UOpen‚àó,0 is the identity (refer
to Section 3.2 for additional details). We will therefore write U to describe the prover‚Äôs ‚Äúattack
unitary‚Äù for the measurement round (c = 1).
For deÔ¨Åning soundness, we informally require that a prover P ‚àóthat passes the test round with
probability 1 ‚àínegl(Œª) (this could alternatively be enforced by applying a measurement in the
security game) implicitly deÔ¨Ånes17 an N-qubit state œÑ whose measurement outcome distribution
matches the output distribution of Out(¬∑) (up to computational indistinguishability).
DeÔ¨Ånition 4.5 (Soundness). There exists an eÔ¨Écient classical algorithm SimGen(1Œª) and an
eÔ¨Écient quantum algorithm ExtU,œÅ(pk, sk, y) with black-box access to an attacker parameterized
by a state œÅ and a unitary U (see Section 3.2 for more details on how we formalize quantum
black-box access), that takes as input classical strings (pk, sk, y), and satisÔ¨Åes the following
properties:
‚Ä¢ Consider any non-uniform QPT cheating prover P ‚àó= (œÅ0, UCommit‚àó, U) that passes the
test round with probability 1 ‚àínegl(Œª) for all h ‚àà{0, 1}N.
Then, for all h ‚àà{0, 1}N with circuit representation C, the following two distributions
are computationally indistinguishable:
Real:
17In fact, we require that œÑ can be extracted eÔ¨Éciently from P ‚àó.
25


1. Sample parameters (pk, sk) ‚ÜêGen(1Œª, C).
2. Run the attacker P ‚àóon pk to obtain a classical commitment string y (i.e., apply
UCommit‚àóand then measure the register containing y). Denote the post-measurement
state as œÅ ‚ààD(Z ‚äóI), where Z corresponds to the registers that will eventually
be measured to obtain the prover‚Äôs Ô¨Ånal message, and I contains all of the other
internal registers of the prover.18
3. Apply the prover‚Äôs attack unitary U. This yields the state œÅ‚Ä≤ := UœÅZ,IU ‚Ä†. Measure
the Z register of œÅ‚Ä≤ in the Hadamard basis to obtain the prover‚Äôs opening string z.
4. Compute m ‚ÜêOut(sk, (y, z)) and output m.
Sim:
1. Sample parameters (pk, sk) ‚ÜêSimGen(1Œª).
2. Run the attacker P ‚àóon pk to obtain a classical commitment string y (i.e., apply
UCommit‚àóand then measure the register containing y). Denote the post-measurement
state as œÅ ‚ààD(Z ‚äóI).
3. Run ExtU,œÅ(pk, sk, y) ‚ÜíœÑ to obtain an N-qubit state œÑ.
4. Measure each qubit of œÑ according to the bases speciÔ¨Åed by h ‚àà{0, 1}N (i.e., qubit
i is measured in the Hadamard basis if hi = 1 and the standard basis if hi = 0) and
output the result.
5
A Measurement Protocol Template
In this section, we describe a generic construction of a N-qubit commit-and-measure protocol
(Section 4) using two building blocks: (1) a family of Mahadev rTCFs (DeÔ¨Ånition 3.3), and (2) a
‚Äúbatch key generation‚Äù scheme (fully deÔ¨Åned in Section 7) whose syntax we describe below. We
consider two diÔ¨Äerent instantiations of this template:
‚Ä¢ Using a ‚Äútrivial‚Äù batch key generation scheme in which the N rTCF keys are sampled i.i.d.,
we recover Mahadev‚Äôs original protocol [Mah18].
‚Ä¢ Using a succinct key generation scheme (constructed in Sections 7 and 7.2, we obtain a
measurement protocol in which the veriÔ¨Åer‚Äôs messages are succinct. We refer to this as a
veriÔ¨Åer-succinct measurement protocol.
Batch Key Generation.
For our construction, we make use of what we call a ‚Äúbatch key genera-
tion scheme‚Äù for the Mahadev rTCF. Let TCF.Gen(1Œª, mode) denote the ‚Äústandard‚Äù key generation
algorithm for a Mahadev rTCF. Informally, a batch key generation scheme for TCF.Gen(1Œª, mode)
is a mechanism that produces a joint representation of N TCF pairs (pki, ski), from which any
18We will also assume, without loss of generality, that the prover always copies pk and y into its internal state
registers I.
26


individual pki, ski can be computed, such that the pairs (pki, ski) are suÔ¨Éciently ‚Äúindependent‚Äù of
each other.
A full deÔ¨Ånition of a batch key generation scheme is given in DeÔ¨Ånition 7.2, but we formally
state here the relevant syntax and security properties. Syntactically, a batch key generation scheme
includes three algorithms (Gen, ExtPk, ExtSk), where:
‚Ä¢ Gen(1Œª, C) takes as input a security parameter Œª and a circuit C : [N] ‚Üí{0, 1} representing
(through its truth table) an N-bit string. It outputs a master public key PK and master
secret key SK.
‚Ä¢ ExtPk(PK, i) is a deterministic algorithm that takes as input PK and an index i ‚ààN, and
outputs a public key pki.
‚Ä¢ ExtSk(SK, i) is a deterministic algorithm that takes as input SK and an index i ‚ààN, and
outputs a secret key ski.
When instantiated for a Mahadev rTCF family, we require the following properties to hold for
such a procedure:
‚Ä¢ Correctness: for (PK, SK) ‚ÜêGen(1Œª, N, C) and (pki, ski) = (ExtPk(PK, i), ExtSk(SK, i)), we
have that (pki, ski) is in the range of TCF.Gen(1Œª, C(i)) (i.e. they are a valid key pair in mode
C(i)).
‚Ä¢ Key Indistinguishability: if C1 and C2 represent functions that agree on a set T of in-
puts, then PK output by Gen(1Œª, C1) is computationally indistinguishable from PK output
by Gen(1Œª, C2), even in the presence of all {ski, i ‚ààT}.
‚Ä¢ Collapsing at a single index: For any index j, the function fpkj is collapsing even given
all secret keys ski for i Ã∏= j.
‚Ä¢ Adaptive hardcore bit at a single index: For any index j, the function fpkj satisÔ¨Åes the
rTCF adaptive hardcore bit property even given all secret keys ski for i Ã∏= j.
Our protocol is a variant of the Mahadev protocol [Mah18] in which the veriÔ¨Åer‚Äôs Ô¨Årst message
(pk1, . . . , pkN) is replaced by the output PK of a batch key generation procedure.
5.1
Measurement Protocol Description
Let ClawFree = (TCF.Gen, Eval, Invert, Check, Good) denote a family of [Mah18] randomized TCFs
(DeÔ¨Ånition 3.3). For simplicity of the analysis, we assume that on a Ô¨Åxed security parameter 1Œª,
Gen outputs keys deÔ¨Åning functions from {0, 1}√óD to R, where D is a Ô¨Åxed-size subset of {0, 1}‚Ñì(Œª)
independent of pk.19 We denote the size of D by L(Œª). Let (Gen, ExtPk, ExtSk) denote a batch key
generation algorithm for TCF.Gen satisfying the requirements described above.
19The LWE-based instantiation from [BCM+18] satisÔ¨Åes this property. However, with more complicated expres-
sions, our proof should go through without this simplifying assumption.
27


For simplicity, we assume the honest prover P has an N-qubit pure state of the form
|œà‚ü©W =
X
w1,...,wN
Œ±w1,...,wN |w1 . . . wN‚ü©
on its internal N-qubit register W; the protocol completeness immediately extends to mixed states
by linearity.
The veriÔ¨Åer has a basis string h ‚àà{0, 1}N, represented by a circuit C : [N] ‚Üí
{0, 1}, and wants to obtain a measurement of |œà‚ü©in this basis (where hi = 0 denotes a standard
basis measurement and hi = 1 denotes a Hadamard basis measurement). The protocol MP (for
measurement protocol), with prover algorithm P = (MP.Commit, MP.Open) and veriÔ¨Åer algorithm
V = (MP.Gen, MP.Test, MP.Out), is executed as follows.
‚Ä¢ MP.Gen: On input 1Œª, N and C, the veriÔ¨Åer samples a representation of N TCF key pairs by
computing (PK, SK) ‚ÜêGen(1Œª, N, C), where C is circuit computing C(i) = hi. The veriÔ¨Åer
sends PK to the prover.
‚Ä¢ MP.Commit: Given PK and its input state |œà‚ü©W, the prover computes public keys pki ‚Üê
ExtPk(PK, i) for 1 ‚â§i ‚â§N. From now on, P operates directly on (pki) and ignores PK.
The prover coherently (with respect to |œà‚ü©) computes a ‚Äúrange superposition‚Äù
1
‚àö
LN
X
x1,...,xN‚ààD
y1,...,yN‚ààR
w‚àà{0,1}N
 
Œ±w
Y
i
q
ppki(wi, xi, yi) |w‚ü©W |x1‚ü©X1 . . . |xN‚ü©XN |y1‚ü©Y1 . . . |yN‚ü©YN
!
where each Xi is an ‚Ñì(Œª)-qubit register (where D ‚äÇ{0, 1}‚Ñì), and each Yi has basis {|y‚ü©}y‚ààR.
Here, ppk(b, x, y) denotes the probability density of y in the distribution fpk(b, x), where
ppk(b, x, y) := 0 for x ‚àà{0, 1}‚Ñì\ D.
Following [BCM+18, Section 4.3] the honest prover
algorithm can eÔ¨Éciently prepare this state up to exponentially small trace distance.
After preparing this state, the prover measures Y1, . . . , YN in the standard (R-)basis and
sends the outcome (y1, . . . , yN) to the veriÔ¨Åer.
‚Ä¢ The veriÔ¨Åer sends a uniformly random challenge bit c. After receiving the prover response,
the veriÔ¨Åer computes each public key pki ‚ÜêExtPk(PK, i) and secret key ski ‚ÜêExtSk(SK, i)
in order to evaluate either MP.Test or MP.Out.
‚Ä¢ MP.Open: On challenge bit c, the prover operates as follows.
‚Äì If c = 0, the prover measures W ‚äóX1 ‚äó. . . ‚äóXN in the standard basis and sends the
outcome (b1, . . . , bN, x1, . . . , xN) to the veriÔ¨Åer.
‚Äì If c = 1, the prover instead measures W ‚äóX1‚äó. . .‚äóXN in the Hadamard basis, returning
strings d1, . . . dN.
‚Ä¢ MP.Test: Given (b1, . . . , bN, x1, . . . , xN), the veriÔ¨Åer computes (for every i) Check(pki, bi, xi, yi)
and rejects if any of these checks do not pass.
‚Ä¢ MP.Out: Given d1, . . . dN, the veriÔ¨Åer outputs N bits as follows. For each i ‚àà[N]:
28


‚Äì If hi = 0, the veriÔ¨Åer ignores di, computes (bi, xi) = Invert(injective, ski, yi), and outputs
bi.
‚Äì If hi = 1, the veriÔ¨Åer computes the two inverses {(0, x0,i), (1, x1,i)} ‚ÜêInvert(2-to-1, ski, yi).
For each i, the veriÔ¨Åer checks whether di ‚ààGoodx0,i,x1,i (corresponding to a valid equa-
tion in the ith slot), and if so, the veriÔ¨Åer outputs di ¬∑ (1, x0,i ‚äïx1,i). If di Ã∏‚ààGoodx0,i,x1,i,
the veriÔ¨Åer samples a uniformly random bit and outputs it.
Completeness of this protocol follows immediately from [Mah18] and the correctness property
of Gen. SpeciÔ¨Åcally, the correctness property of Gen implies that each (pki, ski) in our protocol
is in the range of TCF.Gen(1Œª, C(i)), in which case (as shown in [Mah18]) the veriÔ¨Åer‚Äôs output
distribution is statistically close to h = (C(0), . . . , C(N))-measurement outcome on |œà‚ü©.
6
Soundness of Mahadev‚Äôs Protocol
In this section, we prove that the measurement protocol from Section 5 a computationally sound
(DeÔ¨Ånition 4.5) commit-and-measure protocol. As a consequence, we obtain a new, self-contained
proof of soundness of the [Mah18] protocol. Later (Section 7.1), we will instead instantiate our
protocol with a succinct key generation algorithm to obtain a veriÔ¨Åer-succinct measurement pro-
tocol.
Our soundness proof is based in part on both [Mah18] itself as well as a proof strategy suggested
in [Vid20].
Notation.
Throughout this section, we will Ô¨Åx the veriÔ¨Åer‚Äôs choice of basis h ‚àà{0, 1}N. We
write R := {i ‚àà[N] : hi = 1} and S := {i ‚àà[N] : hi = 0}, where R ‚äÇ[N] denotes the set of indices
that the veriÔ¨Åer wants to measure in the Hadamard basis, and S ‚äÇ[N] denotes the set of indices
the veriÔ¨Åer wants to measure in the standard basis.
Finally, we will decompose the state space of the prover as Z ‚äóI, where:
‚Ä¢ Z = Z1 ‚äó¬∑ ¬∑ ¬∑ ‚äóZN. 1 ‚â§i ‚â§N, Zi is an (‚Ñì(Œª) + 1)-qubit register that contains the classical
opening string zi. We will sometimes write Z as shorthand for Z1 ‚äó. . . ‚äóZN.
‚Ä¢ Each Zi can be written as Zi = Bi ‚äóXi, where Bi is a one-bit register and Xi is an ‚Ñì(Œª)-bit
register.
‚Ä¢ I denotes any additional registers the prover uses.
6.1
The VeriÔ¨Åer‚Äôs Output Distribution
Our goal is to characterize the N-bit distribution DP ‚àó,Out corresponding to the veriÔ¨Åer‚Äôs output
in the measurement protocol when interacting with a malicious prover P ‚àóusing h ‚àà{0, 1}N as
its choice of bases. In particular, we want to prove that if P ‚àósucceeds in passing the test round
with probability 1 ‚àínegl(Œª), then DP ‚àó,Out is computationally indistinguishable from DP ‚àó,Ext, a
distribution obtained from (1) running an eÔ¨Écient extractor ExtP ‚àóto obtain an N-qubit quantum
state œÑ, and (2) measuring œÑ in the veriÔ¨Åer‚Äôs speciÔ¨Åed bases.
The distribution DP ‚àó,Out produces a sample according to the following steps:
29


1. Sample keys (PK, SK) ‚ÜêMP.Gen(1Œª, N, C) (where C speciÔ¨Åes the choice of bases R, S).
2. Run the malicious prover on PK to obtain a classical commitment string y. Let |œà‚ü©‚ààZ ‚äóI
denote the prover‚Äôs residual state.
3. For each i ‚ààS, compute (bi, xi) ‚ÜêInvert(injective, ski, yi). Let v ‚àà{0, 1}S be the vector
whose ith entry is bi.
4. Next, apply the prover‚Äôs attack unitary U on Z ‚äóI, and then measure Z in the Hadamard
basis to obtain a response z = (d1, . . . , dN).
5. For each i ‚ààR, compute (0, x0,i), (1, x1,i) ‚ÜêInvert(2-to-1, ski, yi). If di ‚ààGoodx0,i,x1,i, set
ui = di ¬∑ (1, x0,i ‚äïx1,i). Otherwise, set ui to be a uniformly random bit. This results in a
string u ‚àà{0, 1}R
6. Output (u, v) ‚àà{0, 1}R √ó {0, 1}S.
Our Ô¨Årst step is to show that DP ‚àó,Out is computationally indistinguishable from a distribution
DP ‚àó,2-to-1 that does not require running the Invert algorithm for any key pair (pki, ski) in injective
mode. Instead, this second distribution can be produced by directly measuring the register Bi
(i.e., the Ô¨Årst bit of Zi) of the prover‚Äôs state |œà‚ü©). Since {ski}i‚ààS will no longer be required at this
point, we are also able to switch all key pairs (pki, ski) to be in two-to-one mode by invoking key
indistinguishability.
Formally, DP ‚àó,2-to-1 produces outcomes as follows (diÔ¨Äerences from DP ‚àó,Out highlighted in red):
1. Sample keys (PK, SK) ‚ÜêMP.Gen(1Œª, N, 1) (where 1 denotes the constant 1 function, corre-
sponding to two-to-one mode)
2. Run the malicious prover on PK to obtain a classical commitment string y. Let |œà‚ü©‚ààZ ‚äóI
denote the prover‚Äôs residual state.
3. For each i ‚ààS, measure Bi to obtain a bit vi; the result of this step is a string v ‚àà{0, 1}S.
4. Next, apply the prover‚Äôs attack unitary U on Z ‚äóI, and then measure Z in the Hadamard
basis to obtain a response z = (d1, . . . , dN).
5. For each i ‚ààR, compute (0, x0,i), (1, x1,i) ‚ÜêInvert(2-to-1, ski, yi). If di ‚ààGoodx0,i,x1,i, set
ui = di ¬∑ (1, x0,i ‚äïx1,i). Otherwise, set ui to be a uniformly random bit. This results in a
string u ‚àà{0, 1}R
6. Output (u, v) ‚àà{0, 1}R √ó {0, 1}S.
Lemma 6.1. DP ‚àó,2-to-1 is computationally indistinguishable from DP ‚àó,Out.
We prove Lemma 6.1 by Ô¨Årst switching the keys sampled in DP ‚àó,2-to-1 to match the veriÔ¨Åer‚Äôs
basis choice h. That is, we deÔ¨Åne the distribution DP ‚àó,h to be the same distribution as DP ‚àó,2-to-1,
except that the keys (pki, ski) are sampled in mode hi, i.e., Step 1 is replaced with:
1. Sample keys (PK, SK) ‚ÜêMP.Gen(1Œª, N, C) (where C(i) = hi for all i).
30


This is well-deÔ¨Åned because the ith bit of the output is still obtained by measuring Bi, which can
be done regardless of how (pki, ski) is sampled.
Claim 6.2. For every basis choice h, DP ‚àó,h is computationally indistinguishable from DP ‚àó,2-to-1.
Proof. This follows by invoking the following key indistinguishability property of Gen:
n
(PK, SK) ‚ÜêGen(1Œª, 1) : (PK, {ski}iÃ∏‚ààS)
o
‚âàc
n
(PK, SK) ‚ÜêGen(1Œª, C) : (PK, {ski}iÃ∏‚ààS)
o
.
Since the distributions are sampled without use of ski for all i ‚ààS, Claim 6.2 follows from this
indistinguishability.
To conclude that DP ‚àó,2-to-1 ‚âàc DP ‚àó,Out, we note:
Claim 6.3. If DP ‚àó,Out is instantiated with basis choice h, then DP ‚àó,Out is statistically indis-
tinguishable from DP ‚àó,h.
Proof. Claim 6.3 follows from the injectivity of fpki for each i ‚ààS; by the correctness of Gen,
we have that each pki (for i ‚ààS) is in the support of TCF.Gen(1Œª, injective). Therefore, since |œà‚ü©
is guaranteed to pass the test round with probability 1 ‚àínegl(Œª), we have that with probability
1 ‚àínegl(Œª), measuring Bi gives the same result as computing the Ô¨Årst bit of Invert(skj, yj) (which
is the veriÔ¨Åer‚Äôs output).
6.2
The Protocol Observables
DeÔ¨Åning the Protocol Observables.
In DP ‚àó,2-to-1, the entire N-bit output (u, v) is the result
of performing measurements on |œà‚ü©, the prover‚Äôs residual state after it sends its commitment y.
We now deÔ¨Åne a collection of binary observables {Xi, Zi}i‚àà[N], parameterized by (PK, SK, y) and
the malicious prover‚Äôs attack unitary U, such that the following process is equivalent to sampling
from DP ‚àó,2-to-1:
1. Sample keys (PK, SK) ‚ÜêMP.Gen(1Œª, N, 1).
2. Run the malicious prover on PK to obtain a classical commitment string y. Let |œà‚ü©denote
the prover‚Äôs residual state.
3. For each i ‚ààS, measure |œà‚ü©with the observable Zi to obtain a bit vi.
4. Next, for each i ‚ààR, measure the observable Xi to obtain a bit ui.
5. Output (u, v) ‚àà{0, 1}R √ó {0, 1}S.
The deÔ¨Ånition of the Zi observable is straightforward: since each vi is obtained by measuring
Bi in the standard basis, Zi is simply the Pauli-Z observable Zi := (œÉZ)Bi.
DeÔ¨Åning the Xi observable requires more care. In DP ‚àó,2-to-1, the string u ‚àà{0, 1}R is obtained
by applying the following steps (after v ‚àà{0, 1}S is measured)
1. Apply the prover‚Äôs attack unitary U on Z ‚äóI.
31


2. For each i ‚ààR:
(a) Apply H‚äó‚Ñì+1 to the register Zi containing the prover‚Äôs response in the ith slot.
(b) Measure Zi to obtain di. If di ‚ààGood(x0,i, x1,i), set ui = di ¬∑ (1, x0,i ‚äïx1,i). If di Ã∏‚àà
Good(x0,i, x1,i), set ui to be a uniformly random bit.
In order to output a uniformly random bit, we will prepare fresh one-qubit ancilla registers
U1, . . . , UN, so that in the event that the prover returns an invalid di in slot i, the veriÔ¨Åer can
generate a random bit by measuring Ui (initialized to |0‚ü©) in the Hadamard basis. Note that the
U = U1, . . . , UN register is not part of the malicious prover‚Äôs state.
We therefore redeÔ¨Åne |œà‚ü©:= |œà‚ü©Z,I |0‚ü©U to denote the global state on Z ‚äóI ‚äóU including the
ancilla U registers initialized to |0‚ü©U.
Finally, the Xi observable is deÔ¨Åned as
Xi = (U ‚äóIdU)‚Ä†(H‚äó‚Ñì+1
Zi
‚äóId ‚äóHUi)X‚Ä≤
i(H‚äó‚Ñì+1
Zi
‚äóId ‚äóHUi)(U ‚äóIdU).
where
X‚Ä≤
i =
X
d‚ààGood(x0,i,x1,i)
(‚àí1)d¬∑(1,x0,i‚äïx1,i) |d‚ü©
‚ü®d|Zi ‚äóIdI,{Zj}jÃ∏=i,U
+
X
dÃ∏‚ààGood(x0,i,x1,i),u‚àà{0,1}
(‚àí1)u |d, u‚ü©
‚ü®d, u|Zi,Ui ‚äóIdI,{Zj}jÃ∏=i,{Uj}jÃ∏=i.
Note that the Xi observables are deÔ¨Åned so that each pair of Xi, Xj commute. Moreover, one
can verify that measuring Xi for each i ‚ààR exactly corresponds to measuring u ‚àà{0, 1}R as
described above.
The description of Xi depends on (yi, ski) because of the appearance of xi,0, xi,1 in X‚Ä≤
i. Moreover,
note that each Xi is eÔ¨Éciently computable given ski.
For convenience, we deÔ¨Åne a procedure {Xi, Zi}i, |œà‚ü©Z,I,U ‚ÜêSamp that works as follows:
‚Ä¢ Sample keys (PK, SK) ‚ÜêMP.Gen(1Œª, N, 1).
‚Ä¢ Run the malicious prover on PK to obtain a classical commitment string y. Let |œà‚Ä≤‚ü©denote
the prover‚Äôs residual state on Z ‚äóI.
‚Ä¢ Output the observables {Xi, Zi} parameterized by (PK, SK, y) and malicious prover‚Äôs unitary
U, along with the state |œà‚ü©:= |œà‚Ä≤‚ü©‚äó|0‚ü©U.
For the remainder of this section, we will write DP ‚àó,2-to-1 as a two-step sampling process:
1. Run {Xi, Zi}i, |œà‚ü©Z,I,U ‚ÜêSamp.
2. Starting with |œà‚ü©, measure each Zi for i ‚ààS to obtain v ‚àà{0, 1}S. Then measure each Xi
for i ‚ààR to obtain u ‚àà{0, 1}R. Output (u, v) ‚àà{0, 1}R √ó {0, 1}S.
32


6.3
The Extracted State
Recall that our deÔ¨Ånition of measurement protocol soundness (DeÔ¨Ånition 4.5) requires us to give
an extractor that:
1. Generates keys (PK, SK) according to an algorithm SimGen(1Œª) (independently of the veriÔ¨Åer‚Äôs
basis choice h).
2. Runs the malicious prover P ‚àóon PK to obtain y; as usual, |œà‚ü©‚ààZ ‚äóI ‚äóU denotes the
residual prover state with U initialized to |0‚ü©U.20
3. Generates an extracted state œÑ ‚ÜêExtU,|œà‚ü©(PK, SK, y) (the superscript denotes black-box
access to a unitary U and state |œà‚ü©, see Section 3.2).
We deÔ¨Åne SimGen(1Œª) to be MP.Gen(1Œª, N, 1), which exactly corresponds to how keys are
sampled in DP ‚àó,2-to-1.
To establish soundness, it remains to (1) describe how to generate the extracted state œÑ given
(PK, SK, y), U, and (2) prove that the distribution that arises from measuring œÑ with the Pauli-X
and Pauli-Z observables in the veriÔ¨Åer‚Äôs chosen bases h is computationally indistinguishable from
DP ‚àó,2-to-1.
We handle (1) in Section 6.3.1. We then describe the distribution DP ‚àó,Ext that arises from
measuring our extracted state in Section 6.3.2 and prove that indistinguishability from DP ‚àó,2-to-1
in Section 6.4.
6.3.1
A Teleportation-Inspired Extraction Procedure
Fix a choice of {Xi, Zi}, |œà‚ü©‚ÜêSamp. For ease of notation, write H = Z ‚äóI ‚äóU so that |œà‚ü©‚ààH.
We would like an eÔ¨Écient extraction procedure that takes as input |œà‚ü©‚ààH and generates an N-
qubit state œÑ such that, roughly speaking, measuring |œà‚ü©with X/Z and measuring œÑ with œÉX/œÉZ
produce indistinguishable outcomes.
Intuition for the Extractor.
Before we describe our extractor, we Ô¨Årst provide some underlying
intuition. For an arbitrary N-qubit Hilbert space, let œÉx,i/œÉz,i denote the Pauli œÉx/œÉz observable
acting on the ith qubit. For each r, s ‚àà{0, 1}N, deÔ¨Åne the N-qubit Pauli ‚Äúparity‚Äù observables
œÉx(r) :=
Y
i:ri=1
œÉx,i , œÉz(s) :=
Y
i:si=1
œÉz,i.
Suppose for a moment that |œà‚ü©‚ààH is already an N-qubit state (i.e., H is an N-qubit Hilbert
space) and moreover, that each Xi/Zi observable is simply the corresponding Pauli observable
œÉx,i/œÉz,i. While these assumptions technically trivialize the task (the state already has the form
we want from the extracted state), it will be instructive to write down an extractor that
‚Äúteleports‚Äù this state into another N-qubit external register.
20To match the syntax of our deÔ¨Ånition in DeÔ¨Ånition 4.5, the register U should be viewed as an internal register
initialized by the extractor.
33


We can do this by initializing two N-qubit registers A1 ‚äóA2 to |œÜ+‚ü©‚äóN where |œÜ+‚ü©is the EPR
state (|00‚ü©+ |11‚ü©)/
‚àö
2 (the ith EPR pair lives on the ith qubit of A1 and A2). Now consider the
following steps, which are inspired by the (N-qubit) quantum teleportation protocol
1. Initialize a 2N-qubit ancilla W to

02N
, and apply H‚äó2N to obtain the uniform superposition.
2. Apply a ‚Äúcontrolled-Pauli‚Äù unitary, which does the following for all r, s ‚àà{0, 1}N and all
|œÜ‚ü©‚ààH ‚äóA1:
|r, s‚ü©W |œÜ‚ü©H,A1 ‚Üí|r, s‚ü©W (œÉx(r)œÉz(s)H ‚äóœÉx(r)œÉz(s)A1) |œÜ‚ü©H,A1
3. Apply the unitary that XORs onto W the outcome of performing N Bell-basis measurements21
on A1 ‚äóA2 onto W, i.e., for all u, v, r, s ‚àà{0, 1}N:
|u, v‚ü©W (œÉx(r)œÉz(s) ‚äóId)A1,A2

œÜ+‚äóN
A1,A2 ‚Üí|u ‚äïr, v ‚äïs‚ü©W (œÉx(r)œÉz(s) ‚äóId)A1,A2

œÜ+‚äóN
A1,A2 .
Finally, discard W.
One can show that the resulting state is
1
2N
X
r,s‚àà{0,1}N
(œÉx(r)œÉz(s) ‚äóœÉx(r)œÉz(s) ‚äóId) |œà‚ü©H

œÜ+
A1,A2 =

œÜ+
H,A1 |œà‚ü©A2 ,
(2)
where |œà‚ü©is now ‚Äúteleported‚Äù into the A2 register.
To generalize this idea to the setting where |œà‚ü©‚ààH is an arbitrary quantum state and {Xi, Zi}i
are an arbitrary collection of 2N observables, we simply replace each œÉx(r) and œÉz(s) acting on
H above with the corresponding parity observables for {Xi, Zi}. That is for each r, s ‚àà{0, 1}N,
deÔ¨Åne
Z(s) =
N
Y
i=1
Zsi
i
and X(r) =
N
Y
i=1
Xri
i .
The rough intuition is that as long as the {Xi} and {Zi} observables ‚Äúbehave like‚Äù Pauli observables
with respect to |œà‚ü©, the resulting procedure will ‚Äúteleport‚Äù |œà‚ü©into the N-qubit register A2.
The Full Extractor.
In more detail, we have the state |œà‚ü©H = |œà‚ü©Z,I,U, and we initialize two
N-qubit registers A1 ‚äóA2 to |œÜ‚ü©‚äóN. We run the following steps (the changes from the above
procedure are highlighted in red):
1. Initialize a 2N-qubit ancilla W to

02N
, and apply H‚äó2N.
2. Apply a unitary that does the following for all r, s ‚àà{0, 1}N:
|r, s‚ü©W |œÜ‚ü©H,A1 ‚Üí|r, s‚ü©W (X(r)Z(s)H ‚äóœÉx(r)œÉz(s)A1) |œÜ‚ü©H,A1
21The Bell basis consists of the 4 states (œÉa
xœÉb
z ‚äóId)

œÜ+
for a, b ‚àà{0, 1} on 2 qubits.
34


3. Apply the unitary that XORs onto W the outcome of performing N Bell-basis measurements
on A1 ‚äóA2 onto W, i.e., for all u, v, r, s ‚àà{0, 1}N:
|u, v‚ü©W (œÉx(r)œÉz(s) ‚äóId)

œÜ+‚äóN
A1,A2 ‚Üí|u ‚äïr, v ‚äïs‚ü©W (œÉx(r)œÉz(s) ‚äóId)

œÜ+‚äóN
A1,A2 .
Finally, discard W.
All of these steps can be eÔ¨Éciently implemented given black-box access to {Xi, Zi}i.
The
resulting state is
1
2N
X
r,s‚àà{0,1}N
X(r)Z(s) |œà‚ü©H ‚äóœÉx(r)œÉz(s)

œÜ+‚äóN
A1,A2 ,
and we deÔ¨Åne the extracted state œÑ := Ext{Xi},{Zi}(|œà‚ü©) to be the residual state on A2 after tracing
out H and A1.22
6.3.2
Measuring the Extracted State
We now consider the N-bit distribution of measurement outcomes that arise from measuring the
extracted state œÑ using the Pauli observables œÉx, œÉz. In particular, we consider performing the
measurements according to the veriÔ¨Åer‚Äôs basis choice, so that we measure œÉz,i for each i ‚ààS and
œÉx,i for each i ‚ààR.
Formally, we deÔ¨Åne the distribution DP ‚àó,Ext on {0, 1}N obtained by the following process:
‚Ä¢ Run {Xi, Zi}, |œà‚ü©‚ÜêSamp.
‚Ä¢ Let œÑ = Ext{Xi},{Zi}(|œà‚ü©) be the N-qubit extracted state.
‚Ä¢ Measure the Pauli-Z observable œÉz,i for all i ‚ààS, obtaining v ‚àà{0, 1}S.
‚Ä¢ Measure the Pauli-X observable œÉx,i for all i ‚ààR, obtaining u ‚àà{0, 1}R.
‚Ä¢ Output (u, v) ‚àà{0, 1}R √ó {0, 1}S.
It will be convenient to deÔ¨Åne the following projection operators. For each u ‚àà{0, 1}R and
v ‚àà{0, 1}S let
Œ†œÉx
u =
E
u‚Ä≤‚àà{0,1}R(‚àí1)u¬∑u‚Ä≤œÉx(u‚Ä≤)
and
Œ†œÉz
v =
E
v‚Ä≤‚àà{0,1}S(‚àí1)v¬∑v‚Ä≤œÉz(v‚Ä≤)
(3)
In words, Œ†œÉx
u
is the projection that corresponds to measuring œÉx,i for each i ‚ààR and obtaining
the string of outcomes u ‚àà{0, 1}R, and Œ†œÉz
v
is the projection that corresponds to measuring œÉz,i
for each i ‚ààS and obtaining the string of outcomes v ‚àà{0, 1}S.
Then the probability DP ‚àó,Ext outputs any (u, v) ‚àà{0, 1}R √ó {0, 1}S can be written as
DP ‚àó,Ext(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp[Tr
Œ†œÉx
u Œ†œÉz
v œÑ

: œÑ = Ext{Xi},{Zi}(|œà‚ü©)].
22The same extracted state is deÔ¨Åned in Vidick‚Äôs lecture notes [Vid20], although the notes do not give an explicit
procedure for generating it.
35


We deÔ¨Åne a set of analogous projection operators for the {Xi} and {Zi} observables. For each
u ‚àà{0, 1}R and v ‚àà{0, 1}S, let
Œ†X
u =
E
u‚Ä≤‚àà{0,1}R(‚àí1)u¬∑u‚Ä≤X(u‚Ä≤)
and
Œ†Z
v =
E
v‚Ä≤‚àà{0,1}S(‚àí1)v¬∑v‚Ä≤Z(v‚Ä≤)
(4)
In words, Œ†X
u is the projection that corresponds to measuring Xi for each i ‚ààR and obtaining the
string of outcomes u ‚àà{0, 1}R, and Œ†Z
v is the projection that corresponds to measuring Zi for each
i ‚ààS and obtaining the string of outcomes v ‚àà{0, 1}S.
With these deÔ¨Ånitions in mind, we state a claim that allows us to characterize the result of
measuring the extracted state œÑ with the Pauli observables.
Claim 6.4. Fix any choice of {Xi, Zi}i‚àà[N] and state |œà‚ü©, and let œÑ = Ext{Xi},{Zi}(|œà‚ü©). For all
(u, v) ‚àà{0, 1}R √ó {0, 1}S it holds that
Tr
Œ†œÉx
u Œ†œÉz
v œÑ

=
E
u‚Ä≤‚àà{0,1}R ‚ü®œà| Œ†Z
v Z(u‚Ä≤)Œ†X
u‚Ä≤‚äïuZ(u‚Ä≤)Œ†Z
v |œà‚ü©.
(5)
The proof of Claim 6.4 is a straightforward (but slightly tedious) computation and is deferred
to Appendix B.
Importantly, Claim 6.4 gives a clear understanding of how DP ‚àó,2-to-1 and DP ‚àó,Ext relate to each
other, since it allows us to view the distribution DP ‚àó,Ext (which arises from Pauli measurements
on the extracted state œÑ) as the result of performing certain protocol observable measurements
{Xi, Zi} on |œà‚ü©.
Recall that the distribution DP ‚àó,2-to-1 is the following distribution:
1. Run {Xi, Zi}i, |œà‚ü©Z,I,U ‚ÜêSamp.
2. Starting with |œà‚ü©, measure each Zi for i ‚ààS to obtain v ‚àà{0, 1}S. Then measure each Xi
for i ‚ààR to obtain u ‚àà{0, 1}R. Output (u, v) ‚àà{0, 1}R √ó {0, 1}S.
By Claim 6.4, we can write DP ‚àó,Ext as follows (diÔ¨Äerences from DP ‚àó,2-to-1 are in red):
1. Run {Xi, Zi}, |œà‚ü©‚ÜêSamp.
2. Starting with |œà‚ü©measure each Zi for i ‚ààS to obtain v ‚àà{0, 1}S. Then sample a uniformly
random string u‚Ä≤ ‚Üê{0, 1}R and apply the unitary Z(u‚Ä≤). Finally, measure each Xi for i ‚ààR
and XOR the output with u‚Ä≤ to obtain u ‚àà{0, 1}R. Output (u, v) ‚àà{0, 1}R √ó {0, 1}S.
With this key diÔ¨Äerence in mind, it remains to prove indistinguishability of these two distribu-
tions.
6.4
Indistinguishability of Measurement Outcomes
In this subsection, we complete the proof that DP ‚àó,2-to-1 and DP ‚àó,Ext are computationally indistin-
guishable. We Ô¨Årst write out their probability mass functions:
‚Ä¢ DP ‚àó,2-to-1 outputs (u, v) ‚àà{0, 1}R √ó {0, 1}S with probability
DP ‚àó,2-to-1(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp

‚ü®œà| Œ†Z
v Œ†X
u Œ†Z
v |œà‚ü©

.
36


‚Ä¢ DP ‚àó,Ext outputs (u, v) ‚àà{0, 1}R √ó {0, 1}S with probability
DP ‚àó,Ext(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp
u‚Ä≤‚àà{0,1}R

‚ü®œà| Œ†Z
v Z(u‚Ä≤)Œ†X
u‚Ä≤‚äïuZ(u‚Ä≤)Œ†Z
v |œà‚ü©

.
At this point, the reader may Ô¨Ånd it helpful to convince themselves that probability mass
functions above exactly correspond to the descriptions of these distributions given at the end
of Section 6.3. The equivalence between these two representations will be a key component of the
upcoming proofs.
For convenience, we will reorder the indices so that the indices in R are labeled 1, 2, . . . , |R|.
Let u‚â§j ‚àà{0, 1}R be the vector equal to u on the Ô¨Årst j indices, and is 0 on the remaining
indices. For each j ‚àà{0, 1, . . . , |R|}, deÔ¨Åne hybrid Hybj to be the distribution that outputs (u, v) ‚àà
{0, 1}R √ó {0, 1}S with probability
Hybj(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp
u‚Ä≤‚àà{0,1}R
h
‚ü®œà| Œ†Z
v Z(u‚Ä≤
‚â§j)Œ†X
u‚äïu‚Ä≤
‚â§jZ(u‚Ä≤
‚â§j)Œ†Z
v |œà‚ü©
i
.
Additionally, for each j ‚àà{1, . . . , |R|}, and b ‚àà{0, 1} deÔ¨Åne hybrid Hybj,b to be the distribution
that outputs (u, v) ‚àà{0, 1}R √ó {0, 1}S with probability
Hybj,b(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp
u‚Ä≤‚àà{0,1}R
h
‚ü®œà| Œ†Z
v Z(u‚Ä≤
‚â§j‚àí1)Zb
jŒ†X
u‚äïu‚Ä≤
‚â§j‚àí1‚äïb¬∑ejZb
jZ(u‚Ä≤
‚â§j‚àí1)Œ†Z
v |œà‚ü©
i
,
where ej ‚àà{0, 1}R denotes the jth standard basis vector.
Claim 6.5. For all j ‚àà{1, . . . , |R|}, the distributions Hybj,0 and Hybj,1 are computationally
indistinguishable.
Observe that for j ‚àà{1, 2, . . . , |R|}, Hybj,0 = Hybj‚àí1, and that Hybj,0 is the uniform mixture of
Hybj,0 and Hybj,1. Since Hyb0 = DP ‚àó,2-to-1 and Hyb|R| = DP ‚àó,Ext, Claim 6.5 implies that DP ‚àó,2-to-1
and DP ‚àó,Ext are computationally indistinguishable.
We now prove Claim 6.5, which will complete the proof of measurement protocol soundness.
Our proof involves the following steps:
‚Ä¢ First, we prove Claim 6.6, which states that the marginal distributions of Hybj,0 and Hybj,1
on N \ {j} are indistinguishable due to the collapsing property of fpkj.
‚Ä¢ We then state Claim 6.7, which (together with Claim 6.6) shows that if Hybj,0 and Hybj,1 are
eÔ¨Éciently distinguishable, then they can be distinguished as follows:
1. Given a sample x (from either Hybj,0 or Hybj,1) run an eÔ¨Écient algorithm A on x\{j} (x
without the jth bit).
2. If A outputs 0, guess a random bit b. If A outputs 1, guess b = xj.
Roughly speaking, this reduces the task to arguing about the indistinguishability of the single
bit xj (conditioned on A outputting 1).
37


‚Ä¢ Finally, we show that the 1-bit conditional distributions must be indistinguishable by ap-
pealing to the adaptive hardcore bit property of fpkj.
Claim 6.6. Let R‚Ä≤ = R \ {j} and let (Hybj,0)[N]\{j} and (Hybj,1)[N]\{j} be the marginal distri-
butions of Hybj,0 and Hybj,1 on [N]\{j} = R‚Ä≤ ‚à™S. Then (Hybj,0)[N]\{j} and (Hybj,1)[N]\{j} are
computationally indistinguishable.
Proof. Any quantum algorithm for distinguishing (Hybj,0)[N]\{j} and (Hybj,1)[N]\{j} can be rep-
resented as an N ‚àí1 qubit binary POVM (A, Id ‚àíA), where the distinguisher outputs 1 on x
with probability ‚ü®x| A |x‚ü©. We show that this contradicts the collapsing property of fpkj (given
PK, {ski}iÃ∏=j).
Consider the following adversary for the fpkj collapsing security game:
‚Ä¢ Given PK, {ski}iÃ∏=j, the adversary runs the prover P ‚àóon PK to obtain (y, |œà‚ü©). Recall that
|œà‚ü©is guaranteed to contain a valid pre-image in register Zj. The adversary submits y to the
collapsing game challenger.
‚Ä¢ The challenger Ô¨Çips a random bit and either applies Zj or does nothing.23
‚Ä¢ Then the adversary performs the following steps:
1. Measure Zi for every i ‚ààS obtaining outcomes v ‚àà{0, 1}S.
2. Sample a random string u‚Ä≤ ‚Üê{0, 1}R and apply the unitary Z(u‚Ä≤
‚â§j‚àí1).
3. Measure Xi for every i ‚ààR‚Ä≤, and XOR the outcomes with u‚Ä≤
‚â§j‚àí1 to obtain an output
string u ‚àà{0, 1}R‚Ä≤.
4. Finally, measure |u, v‚ü©with the POVM {A, Id ‚àíA}, and output 1 if and only if the
measurement outcome is A.
All of the adversary‚Äôs steps can be eÔ¨Éciently performed given (PK, {ski}iÃ∏=j). Moreover, the above
adversary‚Äôs advantage in the collapsing game is polynomially related to the advantage the POVM
(A, Id ‚àíA) attains in distinguishing (Hybj,0)[N]\{j} and (Hybj,1)[N]\{j}.
Given that the marginal distributions of Hybj,0 and Hybj,1 on [N]\{j} are computationally
indistinguishable (Claim 6.6), we next invoke a general property of N-bit distributions implying
that a distinguisher between Hybj,0 and Hybj,1 must be distinguishing some (eÔ¨Éciently computable)
property of the jth bit of Hybj,0 and Hybj,1 conditioned on an eÔ¨Éciently computable property of
the [N]\{j}-marginal distributions.
Claim 6.7. Let k = k(Œª) be a positive integer-valued function of a security parameter Œª.
Let {D0,Œª}Œª‚â•1 and {D1,Œª}Œª‚â•1 be families of distributions on {0, 1}k+1 such that the marginal
23This version of the collapsing game is equivalent to the standard formulation in which the challenger either
does/does not perform a measurement. This follows from the fact that measuring a qubit in the computational basis
(and discarding the outcome) is equivalent to applying Zb for a random b ‚Üê{0, 1}. Thus, the challenger‚Äôs measure-
ment (in the b = 1 experiment) is equivalent to applying Z with probability 1/2; for simplicity, our formulation has
the challenger (in the b = 1 experiment) apply Z with probability 1, which increases the adversary‚Äôs distinguishing
advantage by a factor of 2.
38


distributions D‚Ä≤
0,Œª and D‚Ä≤
1,Œª of D0,Œª and D1,Œª respectively on the Ô¨Årst k bits are computationally
indistinguishable. Suppose that D0,Œª and D1,Œª are computationally distinguishable. Then there
is an eÔ¨Éciently computable binary-outcome POVM {M, Id ‚àíM} acting on k qubits such that



E
x‚àºD0,Œª(‚àí1)xk+1 ‚ü®x‚â§k| M |x‚â§k‚ü©‚àí
E
x‚àºD1,Œª(‚àí1)xk+1 ‚ü®x‚â§k| M |x‚â§k‚ü©


 >
1
poly(Œª).
We defer the proof to Appendix C.
Finally, we show that the jth bit distinguisher of Hybj,0 and Hybj,1 discussed by Claim 6.7
cannot exist by the adaptive hardcore bit property of fpkj (given PK, {ski}iÃ∏=j}).
Claim 6.8. For any eÔ¨Éciently computable binary outcome POVM {M, Id ‚àíM},



E
(u,v)‚àºHybj,0
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v

‚àí
E
(u,v)‚àºHybj,1
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v
 

 = negl(Œª). (6)
Proof. For the reader‚Äôs convenience, we write out the probability mass functions of Hybj,0 and
Hybj,1 explicitly, with the diÔ¨Äerences highlighted in red
Hybj,0(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp
u‚Ä≤‚àà{0,1}R
h
‚ü®œà| Œ†Z
v Z(u‚Ä≤
‚â§j‚àí1)Œ†X
u‚äïu‚Ä≤
‚â§j‚àí1Z(u‚Ä≤
‚â§j‚àí1)Œ†Z
v |œà‚ü©
i
Hybj,1(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp
u‚Ä≤‚àà{0,1}R
h
‚ü®œà| Œ†Z
v Z(u‚Ä≤
‚â§j‚àí1)ZjŒ†X
u‚äïu‚Ä≤
‚â§j‚àí1‚äïejZjZ(u‚Ä≤
‚â§j‚àí1)Œ†Z
v |œà‚ü©
i
.
We deÔ¨Åne one more distribution (with the diÔ¨Äerence relative to Hybj,0 highlighted in red)
Hybj,1(u, v) =
E
{Xi,Zi},|œà‚ü©‚ÜêSamp
u‚Ä≤‚àà{0,1}R
h
‚ü®œà| Œ†Z
v Z(u‚Ä≤
‚â§j‚àí1)ZjŒ†X
u‚äïu‚Ä≤
‚â§j‚àí1ZjZ(u‚Ä≤
‚â§j‚àí1)Œ†Z
v |œà‚ü©
i
.
We now rewrite the left-hand-side of Eq. (6), where in the second expectation we sample from
Hybj,1 instead of Hybj,1. Note that these distributions are identical except that uj is Ô¨Çipped, so we
have



E
(u,v)‚àºHybj,0
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v

‚àí
E
(u,v)‚àºHybj,1
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v
 


=



E
(u,v)‚àºHybj,0
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v

+
E
(u,v)‚àºHybj,1
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v
 

.
Dividing the right-hand-side by 2 gives an expression equal to the (absolute value of) the expecta-
tion of the output in the following process:
‚Ä¢ Prepare {Xi, Zi}, |œà‚ü©‚ÜêSamp.
‚Ä¢ Sample b ‚Üê{0, 1} and prepare Zb
j |œà‚ü©(the b = 0 case corresponds to Hybj,0 and the b = 1
case corresponds to Hybj,1).
‚Ä¢ Then measure Zi for all i ‚ààS to obtain v ‚àà{0, 1}S. Sample a random u‚Ä≤ ‚Üê{0, 1}R and
apply Z(u‚Ä≤
‚â§j‚àí1), and Ô¨Ånally measure Xi for all i ‚ààR and XOR the result with u‚Ä≤
‚â§j‚àí1 to
obtain u ‚àà{0, 1}R.
39


‚Ä¢ Prepare the state

u\{j}, v

and measure it with the POVM {M, Id ‚àíM}. If the output is
Id ‚àíM, stop at this point and output 0.
‚Ä¢ Otherwise, if the output is M, output (‚àí1)uj.
Notice that the second step is equivalent to measuring |œà‚ü©with Zj, since (writing Zj = Z+
j ‚àíZ‚àí
j ,
where Z+
j is the projection onto the 1 eigenstate of Zj and Z‚àí
j = Id ‚àíZ+
j is the projection onto
the ‚àí1 eigenstate of Zj):
1
2(Zj |œà‚ü©
‚ü®œà| Zj + |œà‚ü©
‚ü®œà|) = Z+
j |œà‚ü©
‚ü®œà| Z+
j + Z‚àí
j |œà‚ü©
‚ü®œà| Z‚àí
j .
It follows that



E
(u,v)‚àºHybj,0
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v

+
E
(u,v)‚àºHybj,1
(‚àí1)uj 
u\{j}, v

 M

u\{j}, v
 

/2
is polynomially-related to the advantage of the following adversary for the adaptive hardcore bit
game:
‚Ä¢ Given PK, {ski}iÃ∏=j, the adversary runs the prover P ‚àóon PK to obtain (y, |œà‚ü©). Recall that
|œà‚ü©is guaranteed to contain a valid pre-image in register Zj with probability 1 ‚àínegl(Œª).
‚Ä¢ The adversary measures the register Zj of |œà‚ü©in the standard basis, obtaining a string (bj, xj).
By the assumption that |œà‚ü©contains valid pre-images and the fact that pkj is in the range of
TCF.Gen(1Œª, 2-to-1), this is equivalent to measuring the observable Zj (which just measures
bj).
‚Ä¢ Next, the adversary measures Zi for all i ‚ààS, obtaining a string of outcomes v ‚àà{0, 1}S.
‚Ä¢ Then the adversary samples random u‚Ä≤ ‚Üê{0, 1}R and applies the unitary Z(u‚Ä≤
‚â§j‚àí1) to its
state.
‚Ä¢ The adversary measures Xi for all i ‚ààR‚Ä≤ and XORs the outcome with u‚Ä≤
‚â§j‚àí1, obtaining a
string u ‚àà{0, 1}R‚Ä≤.
‚Ä¢ The adversary prepares the state |u, v‚ü©and measures it with {M, Id ‚àíM}. Depending on the
outcome, it does the following:
‚Äì If the measurement outcome is Id ‚àíM, it samples a uniformly random string dj ‚Üê
{0, 1}‚Ñì+1 and sends (bj, xj, dj) to the challenger (in this case obtaining negl(Œª) advan-
tage).
‚Äì If the measurement outcome is M, it applies U to its state, followed by H‚äó‚Ñì+1 to Zj. It
then measures Zj to obtain a string dj ‚àà{0, 1}‚Ñì+1 and sends (bj, xj, dj) to the challenger.
Note that the challenger‚Äôs output bit (i.e., whether the adversary wins or loses) exactly
corresponds to the bit uj.
By assumption, this adversary outputs a valid pre-image (bj, xj) with probability 1‚àínegl(Œª). Since
all of the adversary‚Äôs steps are eÔ¨Écient given (PK, {ski}iÃ∏=j), the claim follows from the adaptive
hardcore bit property of fpkj.
40


This completes the proof of Claim 6.5, which in turn implies the soundness of the measurement
protocol.
7
Succinct Key Generation from iO
In this section, we construct a cryptographic primitive that provides a succinct representation
of N key pairs. We call this primitive a ‚Äúsuccinct batch key generation algorithm,‚Äù and provide
deÔ¨Ånitions and a construction based on iO in Section 7.1. In Section 7.2, we compose our succinct
key generation primitive with Mahadev randomized TCFs [Mah18] and prove that the composition
satisÔ¨Åes the hypotheses stated in Section 5, while also having succinct keys (PK, SK).
7.1
Batch Key Generation: DeÔ¨Ånition and Construction
A batch key generation algorithm is an algorithm that outputs a description of many (pk, sk)-pairs;
a succinct batch key generation algorithm produces a short such description. Formally, we will
deÔ¨Åne this primitive relative to any dual-mode key generation algorithm.
DeÔ¨Ånition 7.1. An algorithm Gen is said to be a dual-mode key generation algorithm if it
takes as input a security parameter 1Œª and a bit mode ‚àà{0, 1}, and it outputs a pair of keys
(pk, sk). Moreover, we require key indistinguishability: public keys sampled using Gen(1Œª, 0)
are computationally indistinguishable from public keys sampled using Gen(1Œª, 1).
DeÔ¨Ånition 7.2. Let (pk, sk) ‚ÜêGen(1Œª, mode) denote a dual-mode key generation algorithm.
A (succinct) batch key generation algorithm BatchGen for Gen is a tuple of p.p.t. algorithms
(Setup, ExtPk, ExtSk, Program) with the following syntax.
‚Ä¢ Setup(1Œª, N, f) takes as input a security parameter Œª in unary; the number of indices N
in binary; and the description of a circuit f : [N] ‚Üí{0, 1}. It outputs a master public
key PK and a master secret key SK.
‚Ä¢ ExtPk(PK, i) is a deterministic algorithm that takes as input a master public key PK and
an index i ‚àà[N]. It outputs a public key pki.
‚Ä¢ ExtSk(SK, i) is a deterministic algorithm takes as input a master secret key SK and an
index i ‚àà[N]. It outputs a secret key ski.
‚Ä¢ Program(1Œª, N, f, i, pk) takes as input (1Œª, N, f) just as Setup does, along with two addi-
tional inputs: an index i ‚àà[N] and a public key pk. It outputs a master public key PK
and (an implicitly restricted) master secret key SK.
We require that the following three properties are satisÔ¨Åed. Informally, we require that (0)
Setup(1Œª, N, f) always outputs a representation of valid key pairs, (1) Program(1Œª, N, f, i, pk)
successfully programs pk into the ith ‚Äúslot‚Äù of PK, (2) if (pk, sk) ‚ÜêGen(1Œª, mode = f(i)) this
programming is undetectable (even given all secret keys), and (3) mode indistinguishability
continues to hold for batched keys, even in the presence of ‚Äúirrelevant secret keys.‚Äù
41


1. Setup Correctness. For any Œª, N ‚ààN, any circuit f : [N] ‚Üí{0, 1}, any index i ‚àà[N],
we have that for (PK, SK) ‚ÜêSetup(1Œª, N, f) and (pki, ski) = (ExtPk(PK, i), ExtSk(SK, i)),
(pki, ski) is in the range of Gen(1Œª, mode = f(i)).
2. Programming Correctness. For any Œª, N ‚ààN, any circuit f : [N] ‚Üí{0, 1}, any index
i ‚àà[N], and any bit mode, we have the following guarantee: for (pk, sk) ‚ÜêGen(1Œª, mode)
and (PK, SK) ‚ÜêProgram(1Œª, N, f, i, pk),
ExtPk(PK, i) = pk.
with probability 1.
3. Programming Indistinguishability. For any N = N(Œª), any circuit f : [N] ‚Üí{0, 1}
and any index i ‚àà[N], the following distributions are (poly(Œª, N), negl(Œª, N))-indistinguishable:
n
(PK, SK) ‚ÜêSetup(1Œª, N, f), skj ‚ÜêExtSk(SK, j) : (PK, sk1, . . . , skN)
o
Œª‚ààN
‚âàc
n
(pk, sk) ‚ÜêGen(1Œª, mode = f(i)), (PK, SK) ‚ÜêProgram(1Œª, N, f, pk, i),
ski = sk and ‚àÄj Ã∏= i, skj ‚ÜêExtSk(SK, j) : (PK, sk1, . . . , skN)
o
Œª‚ààN
While we let the circuit be arbitrary in this deÔ¨Ånition, we note that it will be instantiated
with an eÔ¨Écient circuit of size poly(log N, Œª) in our eventual constructions.
4. Key Indistinguishability: For any N = N(Œª), for any subset S ‚äÇ[N], and for any
two circuits f0, f1 : [N] ‚Üí{0, 1} such that f0(i) = f1(i) for all i ‚ààS, for (PKb, SKb) ‚Üê
Setup(1Œª, N, fb), the distributions of keys
n
PKb,

ski ‚ÜêExtSk(SKb, i)

i‚ààS
o
Œª‚ààN
are computationally (poly(Œª, N), negl(Œª, N))-indistinguishable.
We now construct succinct key generation from iO and puncturable PRFs using standard punc-
turing techniques.
Theorem 7.3. For any N(Œª), assuming a (poly(Œª, N), negl(Œª, N))-secure iO scheme and a
(poly(Œª, N), negl(Œª, N))-secure puncturable PRF, there exists a succinct batch key generation
algorithm
(Setup, ExtPk, ExtSk, Program)
where Setup supports batch sizes up to N(Œª) and runs in time poly(Œª, log N).
In particular, when N(Œª) = 2Œª we rely on the sub-exponential hardness of iO and punc-
turable PRFs, while for any N(Œª) = poly(Œª) we rely on polynomial hardness.
Proof. Given a dual-mode key generation algorithm Gen, an iO scheme iO, and a puncturable PRF
family PRF, we deÔ¨Åne our batch key generation procedure SuccGen = (Setup, ExtPk, ExtSk, Program)
as follows.
42


‚Ä¢ Setup(1Œª, N, f) samples a PRF seed s and outputs (as the public key) an obfuscated program
e
P = iO(Ps,f), where P is deÔ¨Åned in Fig. 1, and (as the secret key) the PRF seed s and the
function f.
‚Ä¢ ExtPk(PK, i) computes and outputs pki = e
P(i) (for e
P = PK).
‚Ä¢ ExtSk(SK, i) computes r = PRFs(i) and mode = f(i). It then computes (pki, ski) ‚ÜêGen(1Œª, mode; r)
and outputs ski.
‚Ä¢ Program(1Œª, N, f, pk, i‚àó) samples a PRF seed s and outputs (as the public key) an obfuscated
program iO(Ppk,i‚àó,s,f), where Ppk,i‚àó,s,f is deÔ¨Åned in Fig. 2, and (as the secret key) the PRF
seed s and the function f.
Input: index i ‚â§N
Hardwired Values: Puncturable PRF seed s. Circuit f.
‚Ä¢ Compute mode = f(i) and r = PRFs(i).
‚Ä¢ Compute (pki, ski) ‚ÜêGen(1Œª, mode; r).
‚Ä¢ Output pki.
Figure 1: The program P.
Input: index i ‚â§N
Hardwired Values: Puncturable PRF seed s. Public key pk. Index i‚àó. Circuit f.
‚Ä¢ If i = i‚àó, output pk and terminate.
‚Ä¢ Compute mode = f(i) and r = PRFs(i).
‚Ä¢ Compute (pki, ski) ‚ÜêGen(1Œª, mode; r).
‚Ä¢ Output pki.
Figure 2: The program Ppk,i‚àó,s,f.
Succinctness, setup correctness and programming correctness are immediate from the deÔ¨Åni-
tions. We now prove programming indistinguishability.
43


Claim 7.4. For any circuit f and any index i ‚àà[N], the following distributions are (poly(Œª, N),
negl(Œª, N))- computationally indistinguishable:
n
(PK, SK) ‚ÜêSetup(1Œª, N, f), skj ‚ÜêExtSk(SK, j) : (PK, sk1, . . . , skN)
o
‚âàc
n
(pk, sk) ‚ÜêGen(1Œª, mode = f(i)), (PK, SK) ‚ÜêProgram(1Œª, N, f, pk, i),
skj ‚ÜêExtSk(SK, j)(j Ã∏= i), ski = sk : (PK, sk1, . . . , skN)
o
Proof. We know that (iO(Ps,f), s) ‚âàc (iO(Ppk,i‚àó,s,f), s) for (pk, sk) ‚ÜêGen(1Œª, mode = f(i‚àó); PRFs(i‚àó))
by iO security because these two circuits Ps,f, Ppk,i‚àó,s,f are functionally equivalent.
Moreover, (iO(Ppk,i‚àó,s,f), {ski}1‚â§i‚â§N) for pseudorandom (pk, ski‚àó) is computationally indistin-
guishable from (iO(Ppk,i‚àó,s,f), {ski}1‚â§i‚â§N) for truly random (pk, ski‚àó) by puncturing s at i‚àó(invoking
iO security to do so) and then invoking PRF security.
Finally, we prove key indistinguishability.
Claim 7.5. For any N = N(Œª), for any subset S ‚äÇ[N(Œª)], and for any two circuits f0, f1 :
[N] ‚Üí{0, 1} such that f0(i) = f1(i) for all i ‚ààS, for (PKb, SKb) ‚ÜêSetup(1Œª, N, fb), the
distributions of keys
n
PKb,

ski ‚ÜêExtSk(SKb, i)

i‚ààS
o
Œª‚ààN
are computationally (poly(Œª, N), negl(Œª, N))- indistinguishable.
Proof. Consider the following hybrid circuits f‚Ä≤
j for 0 ‚â§j ‚â§N:
f‚Ä≤
j(i) = f0(i) if i ‚â•j and f‚Ä≤
j(i) = f1(i) if i > j.
Note that f‚Ä≤
0 = f0 and f‚Ä≤
N = f1. Now, we consider the N + 1 distributions
Hybj =
n
PK,

ski ‚ÜêExtSk(SK, i)

i‚ààS
o
Œª‚ààN
for (PK, SK) ‚ÜêSetup(1Œª, N, f‚Ä≤
j). The claim holds as long as Hybj‚àí1 ‚âàc Hybj for all j ‚â•1. To see
that this indistinguishability holds, it suÔ¨Éces to consider two further hybrid distributions:
Hybj,1 =
n
PK,

ski ‚ÜêExtSk(SK, i)

iÃ∏=j‚ààS, skj (included if j ‚ààS)
o
Œª‚ààN
for (pkj, skj) ‚ÜêGen(1Œª, mode = f0(j)) and (PK, SK) ‚ÜêProgram(1Œª, N, f‚Ä≤
j‚àí1, j, pkj), and
Hybj,2 =
n
PK,

ski ‚ÜêExtSk(SK, i)

iÃ∏=j‚ààS, skj (included if j ‚ààS)
o
Œª‚ààN
for (pkj, skj) ‚ÜêGen(1Œª, mode = f1(j)) and (PK, SK) ‚ÜêProgram(1Œª, N, f‚Ä≤
j, j, pkj).
We have that Hybj‚àí1 ‚âàc Hybj,1 by programming indistinguishability (Claim 7.4). We have that
Hybj,1 ‚âàc Hybj,2 by considering two cases: if f0(j) = f1(j) then (pkj, skj) are sampled from identical
distributions in the hybrid and f‚Ä≤
j‚àí1 = f‚Ä≤
j, so indistinguishability follows from a single invocation
of iO security. If f0(j) Ã∏= f1(j), then skj is not included in the hybrid distributions; moreover, pkj
44


in Hybj,1 is computationally indistinguishable from pkj in Hybj,2 by the key indistinguishability
of Gen. Finally, note that for a Ô¨Åxed pkj, the programs Ppkj,j,s,f‚Ä≤
j‚àí1 and Ppkj,j,s,f‚Ä≤
j are functionally
equivalent (as index j is being programmed to pkj in both cases), so the claimed indistinguishability
now follows from iO security.
Finally, we have Hybj,2 ‚âàc Hybj by programming indistinguishability. This completes the proof
of the claim.
This completes the proof that (Setup, ExtPk, ExtSk, Program) is a succinct batch key generation
algorithm for Gen.
7.2
Combining Succinct Key Generation with Mahadev rTCFs
In our protocols, we compose a batch key generation algorithm (DeÔ¨Ånition 7.2) with a family of
Mahadev randomized TCFs (DeÔ¨Ånition 3.3). The composition is simple: use a batch key generation
procedure BatchGen = (Setup, ExtPk, ExtSk, Program) to batch the procedure TCF.Gen(1Œª, mode)
for many Mahadev rTCFs fpk1, . . . , fpkN . The composition has the following syntax:
‚Ä¢ Setup(1Œª, N, C) takes as input the security parameter Œª, the batch size N (in binary), and a
circuit C computing a function mapping [N] ‚Üí{0, 1}. It outputs a public key PK and secret
key SK.
‚Ä¢ ExtPk(PK, i) then outputs a public key pki that can be used to evaluate a randomized TCF
fpki.
‚Ä¢ ExtSk(SK, i) outputs a secret key ski that can be used to invert a TCF evaluation yi.
‚Ä¢ Program, as deÔ¨Åned above, can be used to program a fresh (pki, ski) ‚ÜêGen(1Œª, mode = C(i))
into a succinct program generated using circuit C. Program is an auxiliary algorithm used
only for analysis.
We now establish that all of the necessary properties listed in Section 5 are satisÔ¨Åed by this
composition.
Correctness of the composition (i.e., that key pairs (pki, ski) are in the range of TCF.Gen(1Œª, mode =
f(i))) follows immediately from the correctness of Setup. Key indistinguishability of the composi-
tion is also inherited directly from the key indistinguishability of BatchGen.
We next prove that collapsing of fpkj holds in the presence of PK and all {ski}iÃ∏=j.
Lemma 7.6. [Collapsing] For any circuit C, any index j, and (PK, SK) ‚ÜêSetup(1Œª, N, C),
the TCF fpkj is collapsing, even to an adversary given PK along with all secret keys {ski}iÃ∏=j
besides skj.
Formally, a computationally bounded adversary cannot win the following distinguishing
game with non-negligible advantage:
1. The adversary chooses an index j ‚àà[N] and a circuit C : [N] ‚Üí{0, 1}.
2. The challenger samples (PK, SK) ‚ÜêSetup(1Œª, N, C).
45


3. The challenger sends (PK, {ski}iÃ∏=j) to the adversary.
4. The adversary prepares a quantum state |œà‚ü©on registers B, X along with a string y and
sends both to the challenger.
5. The challenger computes, in superposition, whether Check(pkj, b, x, y) = 1.
‚Ä¢ If Check fails, the challenger samples a random bit c and stops.
‚Ä¢ If Check passes, the challenger samples a random bit c; if c = 1, the challenger
measures B.
6. The adversary, given access to the modiÔ¨Åed (B, X), outputs a bit c‚Ä≤ and wins if c‚Ä≤ = c.
Proof. We consider the following hybrid experiments.
‚Ä¢ Hyb0: this is the actual security game.
‚Ä¢ Hyb1: In step (2), challenger samples (pk, sk) ‚ÜêGen(1Œª, C(j)) and samples (PK, SK) ‚Üê
Program(1Œª, N, C, pk, j).
Hyb0 and Hyb1 are computationally indistinguishable by the programming indistinguishabil-
ity of SuccGen.
‚Ä¢ Hyb2: In step (2), the challenger instead samples (pk, sk) ‚ÜêGen(1Œª, injective).
Hyb1 and Hyb2 are computationally indistinguishable by the key indistinguishability of the
injective/claw-free trapdoor functions.
Finally, in Hyb3, even a computationally unbounded adversary cannot guess the challenge bit
c, as with all but negligible probability, pkj = ExtPk(PK, j) deÔ¨Ånes an injective function (by
DeÔ¨Ånition 3.3), so after verifying that Check(pkj, b, x, y) = 1, the register B is already a standard
basis state. This completes the proof of Lemma 7.6.
Finally, we prove that the adaptive hardcore bit property of fpkj holds given PK and all {ski}iÃ∏=j
Lemma 7.7. [Adaptive Hardcore Bit] For any j and any circuit C such that C(j) = 1 =
2-to-1, for (PK, SK) ‚ÜêSetup(1Œª, N, C), the adaptive hardcore bit property (see DeÔ¨Ånition 3.3)
holds for the function fpkj (with associated secret key skj), even if the adversary is given
(PK, {ski}iÃ∏=j).
Proof. We consider the following hybrid experiments.
‚Ä¢ Hyb0: this is the adaptive hardcore bit security game for (pkj, skj) as sampled above.
‚Ä¢ Hyb1: this is the adaptive hardcore bit security game for (pk, sk) ‚ÜêGen(1Œª, 2-to-1), (PK, SK) ‚Üê
Program(1Œª, N, C, pk, j). The adversary is additionally given PK and ski = ExtSk(SK, i) for
all i Ã∏= j.
Hyb0 and Hyb1 are computationally indistinguishable by the programming indistinguishability
property. Moreover, the adversary‚Äôs advantage in Hyb1 is negligible by the adaptive hardcore bit
property of the freshly generated key pair (pk, sk) ‚ÜêGen(1Œª, 2-to-1), as a reduction given pk can
simulate Hyb1 by sampling all other parameters given to the Hyb1 adversary itself.
This completes the proof of Lemma 7.7.
46


8
A VeriÔ¨Åer-Succinct Protocol
In this section, we present a delegation protocol for QMA with succinct veriÔ¨Åer messages. First, in
Section 8.1, we describe results due to [ACGH20] about the parallel repetition of certain commit-
challenge-response protocols with a quantum prover. Our treatment is somewhat more abstract
than [ACGH20], so for completeness we provide proofs of all claims (based on proofs appearing
in [ACGH20]).
Next, in Section 8.2, we describe the syntax of a non-interactive, information-
theoretic QMA veriÔ¨Åcation protocol (with quantum veriÔ¨Åer) that we will use, due to [FHM18].
In Section 8.3, we describe a veriÔ¨Åer-succinct protocol for QMA delegation, where the veriÔ¨Åer
messages (but not the prover messages) are succinct.
8.1
Quantum commit-challenge-response protocols
Consider any commit-challenge-response protocol between a quantum prover P and a classical
veriÔ¨Åer V , with the following three phases.
‚Ä¢ Commit: P(1Œª) and V (1Œª; r) engage in a (potentially interactive) commitment protocol,
where r are the random coins used by V .
‚Ä¢ Challenge: V samples a random bit b ‚Üê{0, 1} and sends it to P.
‚Ä¢ Response: P computes a (classical) response z and sends it to V .
After receiving the response, V decides to accept or reject the execution.
Consider any non-uniform QPT prover P ‚àó, and let


œàP ‚àó
Œª,r
E
A,C be the (puriÔ¨Åed) state of the prover
after interacting with V (1Œª; r) in the commit phase, where C holds the (classical) prover messages
output during this phase, and A holds the remaining state.
The remaining strategy of the prover can be described by family of unitaries
n
U P ‚àó
Œª,0, UP ‚àó
Œª,1
o
Œª‚ààN+,
where U P ‚àó
Œª,0 is applied to


œàP ‚àó
Œª,r
E
on challenge 0 (followed by a measurement of z), and U P ‚àó
Œª,1 is applied
to


œàP ‚àó
Œª,r
E
on challenge 1 (followed by a measurement of z).
Let VŒª,r,0 denote the accept/reject predicate applied by the veriÔ¨Åer to the prover messages when
b = 0, written as a projection to be applied to the registers holding the prover messages, and deÔ¨Åne
VŒª,r,1 analogously. Then deÔ¨Åne the following projectors on A ‚äóC :
Œ†P ‚àó
Œª,r,0 := U P ‚àó
Œª,0
‚Ä†VŒª,r,0U P ‚àó
Œª,0,
Œ†P ‚àó
Œª,r,1 := U P ‚àó
Œª,1
‚Ä†VŒª,r,1U P ‚àó
Œª,1.
DeÔ¨Ånition 8.1. A commit-challenge-response protocol has computationally orthogonal projectors
if for any QPT prover P ‚àó,
E
r
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0Œ†P ‚àó
Œª,r,1Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
Ei
= negl(Œª).
Proofs of the following are given in Appendix A.
Lemma 8.2 ([ACGH20]). Consider a commit-challenge-response protocol with the following
properties.
47


1. VŒª,r,0 does not depend on r (that is, it is publicly computable given the transcript).
2. For any P ‚àó, if Er
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
Ei
= 1‚àínegl(Œª), then Er
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,1


œàP ‚àó
Œª,r
Ei
= negl(Œª).
Then, the protocol has computationally orthogonal projectors.
Theorem 8.3 ([ACGH20]). Consider the Œª-fold parallel repetition of any commit-challenge-
response protocol with computationally orthogonal projectors. The probability that the veriÔ¨Åer
accepts all Œª parallel repetitions of the protocol is negl(Œª).
8.2
Non-Interactive Post Hoc VeriÔ¨Åcation of QMA
We recall a useful information-theoretic QMA veriÔ¨Åcation protocol of Fitzsimons, Hajdu≈°ek, and
Morimae [FHM18]. In fact, we will use an ‚Äúinstance-independent‚Äù version due to [ACGH20].
Lemma 8.4 ([FHM18, ACGH20]). For all languages L = (Lyes, Lno) ‚ààQMA there exists
a polynomial k(Œª), a function ‚Ñì(Œª) that is polynomial in the time T(Œª) required to verify
instances of size Œª, a QPT algorithm PFHM, and a PPT algorithm VFHM such that the following
holds.
‚Ä¢ PFHM(x, |œà‚ü©) ‚Üí|œÄ‚ü©: on input an instance x ‚àà{0, 1}Œª and a quantum state |œà‚ü©, PFHM
outputs an ‚Ñì(Œª)-qubit state |œÄ‚ü©.
‚Ä¢ Completeness. For all x ‚ààLyes and |œÜ‚ü©‚ààRL(x) it holds that
Pr
h
VFHM(x, M(h, |œÄ‚ü©)) = acc : |œÄ‚ü©‚ÜêPFHM

x, |œÜ‚ü©‚äók(Œª)i
‚â•1 ‚àínegl(Œª)
where h ‚Üê{0, 1}‚Ñì(Œª).
‚Ä¢ Soundness. For all x ‚ààLno and all ‚Ñì-qubit states |œÄ‚àó‚ü©it holds that
Pr[VFHM(x, M(h, |œÄ‚àó‚ü©)) = acc] ‚â§negl(Œª)
where h ‚Üê{0, 1}‚Ñì(Œª).
Moreover, when L ‚ààBQP, the honest prover algorithm PFHM is also a BQP algorithm.
While the result was originally stated in [FHM18, ACGH20] to have an inverse polynomial
soundness gap, we have driven the soundness gap to negligible by standard QMA ampliÔ¨Åcation.
Finally, we remark that although the algorithm VFHM is completely classical, the entire veriÔ¨Åcation
procedure is quantum since it involves measuring the quantum state sent by the prover.
8.3
Semi-Succinct Delegation for QMA
We describe a protocol for verifying any QMA language L.
48


Ingredients:
‚Ä¢ Let (PFHM, VFHM) be the non-interactive protocol described in Lemma 8.4 for language L
with associated polynomials k(Œª), ‚Ñì(Œª).
‚Ä¢ Let PRF : {0, 1}Œª √ó {0, 1}log ‚Ñì(Œª) ‚Üí{0, 1} be a pseudo-random function.
‚Ä¢ Let PMeas = (Commit, Open) and VMeas = (Gen, Test, Out) be the prover and veriÔ¨Åer algorithms
for an ‚Ñì(Œª)-qubit (veriÔ¨Åer succinct) commit-and-measure protocol, deÔ¨Åned in Section 4 and
constructed in Section 5.1.
The Protocol:
‚Ä¢ The veriÔ¨Åer is initialized with an instance x ‚àà{0, 1}Œª and the prover is initialized with x and
k(Œª) copies of a witness |œÜ‚ü©‚ààRL(x).
‚Ä¢ The veriÔ¨Åer samples s ‚Üê{0, 1}Œª, deÔ¨Ånes C so that C(i) = PRFs(i), and computes (pk, sk) ‚Üê
Gen(1Œª, C). It sends pk to the prover.
‚Ä¢ The prover Ô¨Årst computes |œà‚ü©‚ÜêPFHM

x, |œÜ‚ü©‚äók(Œª)
, and then computes (y, |st‚ü©) ‚ÜêCommit(pk, |œà‚ü©).
It sends y to the veriÔ¨Åer.
‚Ä¢ The veriÔ¨Åer samples a random challenge c ‚Üê{0, 1} and sends c to the prover.
‚Ä¢ The prover computes z ‚ÜêOpen(|st‚ü©, c) and sends z to the veriÔ¨Åer.
‚Ä¢ If c = 0, the veriÔ¨Åer checks whether Test(pk, (y, z)) = acc and rejects if the test fails. If c = 1,
the veriÔ¨Åer computes m ‚ÜêOut(sk, (y, z)) and checks whether VFHM(x, m) = acc. The veriÔ¨Åer
accepts if and only the veriÔ¨Åcation is successful.
Theorem 8.5. Let (PSS, VSS) be the Œª-fold parallel repetition of the above protocol.
Then,
(PSS, VSS) satisÔ¨Åes completeness and soundness as deÔ¨Åned in DeÔ¨Ånition 3.1. Moreover, for an
instance x with QMA veriÔ¨Åcation time T, the total size of veriÔ¨Åer messages is poly(Œª, log T).
Proof. First, the veriÔ¨Åer message size guarantee follows from the fact that the veriÔ¨Åer initializes
the commit-and-measure protocol with a circuit C that succinctly encodes ‚Ñì(Œª) bits using a PRF
with input size log(‚Ñì(Œª)), where ‚Ñì(Œª) is polynomially related to the QMA veriÔ¨Åcation time T.
Next, we argue completeness. For any x ‚ààL, we show that a single repetition of the protocol
accepts with 1‚àínegl(Œª) probability, and so completeness of the Œª-fold parallel repetition then follows
by a union bound. In the case of a test round, this follows from the test round completeness of the
commit-and-measure protocol (DeÔ¨Ånition 4.2). In the case of a measurement round, we Ô¨Årst see that
measurement round completeness of the commit-and-measure protocol (DeÔ¨Ånition 4.2) implies that
the probability that the veriÔ¨Åer outputs 1 is negl(Œª)-close to the probability that the FHM protocol
(PFHM, VFHM) accepts when run with an honest prover, but where h = (PRFs(1), . . . , PRFs(‚Ñì)) for
s ‚Üê{0, 1}Œª. Then, the security of the PRF implies that this probability is negl(Œª)-close to the
probability that the FHM protocol accepts when h ‚Üê{0, 1}‚Ñì. Finally, this is negl(Œª)-close to 1 by
the completeness of the FHM protocol (Lemma 8.4).
49


Finally, we argue soundness. Consider any x /
‚ààL. By Theorem 8.3, it suÔ¨Éces to show that
the single repetition of the protocol satisÔ¨Åes the conditions of Lemma 8.2. We deÔ¨Åne VŒª,r,0 to be
the veriÔ¨Åer‚Äôs accept projection on a test round, and VŒª,r,1 to be the veriÔ¨Åer‚Äôs accept projection
on a measurement round. Condition 1 of Lemma 8.2 follows immediately from the structure of
the commit-and-measure protocol. Now, consider any prover P ‚àósuch that the Ô¨Årst expectation in
condition 2 is 1 ‚àínegl(Œª), meaning that P ‚àópasses the test round with 1 ‚àínegl(Œª) probability. By
the soundness of the commit-and-measure protocol, there exists a state œÅ such that the probability
that the veriÔ¨Åer accepts on a measurement round is negl(Œª)-close to the probability that VFHM
accepts given x, h, and M(h, œÅ), where h = (PRFs(1), . . . , PRFs(‚Ñì)) for s ‚Üê{0, 1}Œª. By security
of the PRF, this probability is negl(Œª)-close to the probability that VFHM accepts given x, h, and
M(h, œÅ), where h ‚Üê{0, 1}. Since x /
‚ààL, soundness of the FHM protocol implies that this is negl(Œª).
Thus, the second expectation in condition 2 of Lemma 8.2 is negl(Œª), which establishes that this
condition is satisÔ¨Åed, and completes the proof.
9
The Fully Succinct Protocol
In this section, we compile the veriÔ¨Åer-succinct delegation scheme from Section 8 into a full-Ô¨Çedged
delegation scheme for QMA. Formally, we assume the existence of a delegation scheme for QMA
satisfying the following properties:
1. All veriÔ¨Åer messages can be computed in time poly(Œª, log N). (This is the deÔ¨Ånition of veriÔ¨Åer
succinctness.)
2. Moreover, the veriÔ¨Åer messages can be computed obliviously to the QMA instance and the
prover messages (this holds for the Section 8 protocol).
We present two compilers enabling this:
1. The Ô¨Årst (and simpler) compiler only additionally assumes the existence of a collapsing hash
function, which is implied by LWE (Lemma 3.7). It converts a 2r-round veriÔ¨Åer-succinct
protocol into a 4(r + 1) round fully succinct protocol.
In particular, the protocol from
Section 8 is compiled into a 12-round succinct argument for QMA.
2. The second compiler additionally assumes collapsing hash function and a (classical, post-
quantum) fully homomorphic encryption (FHE) scheme.
It converts a 2r round veriÔ¨Åer-
succinct protocol to a 4r round fully succinct protocol. Moreover, if the veriÔ¨Åer-succinct
protocol is public-coin (except for the Ô¨Årst message), then so is the fully succinct protocol.
This results in an 8 round succinct argument system for QMA that is public-coin except for
the Ô¨Årst message.
For simplicity, we write down the compiled protocols in the case r = 2, corresponding to the
protocols from Section 8.
Our main tool for these compilers are post-quantum succinct arguments of knowledge for NP
[CMSZ21, LMS21]. SpeciÔ¨Åcally, the security guarantees proved in [CMSZ21] are insuÔ¨Écient for
50


the compilers, because the post-quantum extraction algorithm from [CMSZ21] is not suÔ¨Éciently
composable since their extractor might signiÔ¨Åcantly disturb the prover‚Äôs state. Instead, we make
use of a composable variant of the [CMSZ21] extractor due to [LMS21] called ‚Äústate-preserving
succinct arguments of knowledge,‚Äù24 which we now deÔ¨Åne.
9.1
State-Preserving Succinct Arguments of Knowledge
DeÔ¨Ånition 9.1. A publicly veriÔ¨Åable argument system Œ† for an NP language L (with witness
relation R) is an œµ-state-preserving succinct argument-of-knowledge if it satisÔ¨Åes the following
properties.
‚Ä¢ Succinctness: when invoked on a security parameter Œª and instance size n and a relation
decidable in time T, the communication complexity of the protocol is poly(Œª, log T). The
veriÔ¨Åer computational complexity is poly(Œª, log T) + Àú
O(n).
‚Ä¢ œµ-State-Preserving Extraction.
There exists an extractor E(¬∑)(x, œµ) with the following
properties
‚Äì EÔ¨Éciency: E(¬∑)(x, œµ) runs in time poly(n, Œª, 1/œµ) as a quantum oracle algorithm
(with the ability to apply controlled U-gates given an oracle U(¬∑)), outputting a
classical transcript Àú
œÑ and a classical string w.
‚Äì State-preserving:
Let |œà‚ü©‚ààA ‚äóI be any poly(Œª)-qubit pure state and let œÅ =
TrA(|œà‚ü©) ‚ààD(I).25 Consider the following two games:
‚àóGame 0 (Real) Generate a transcript œÑ by running P ‚àó(œÅI, x) with the honest
veriÔ¨Åer V . Output œÑ along with the residual state on A ‚äóI.
‚àóGame 1 (Simulated) Generate a transcript-witness pair (Àú
œÑ, w) ‚ÜêEP ‚àó(œÅI,x).
Output Àú
œÑ and the residual state on A ‚äóI.
Then, we have that the output distributions of Game 0 and Game 1 are computa-
tionally Œµ-indistinguishable to any quantum distinguisher.
‚Äì Extraction correctness: for any P ‚àóas above, the probability that Àú
œÑ is an accepting
transcript but w is not in Rx is at most œµ + negl(Œª).
Theorem 9.2 ([LMS21]). Assuming the post-quantum poly(Œª, 1/œµ) hardness of learning with
errors, there exists a (4-message, public coin) œµ-state preserving succinct argument of knowl-
edge for NP.
24We only require a weak variant of what was constructed in [LMS21], where state preservation is allowed an
inverse polynomial œµ error.
25In general, the prover‚Äôs input state on I may be entangled with some external register A, and we ask that
computational indistinguishability holds even given A. Our deÔ¨Ånition is stated this way for maximal generality,
though we remark that the applications in this section do not require indistinguishability in the presence of an
entangled external register.
51


9.2
The QMA Protocol, Version 1
Let SemiSuccinct denote a veriÔ¨Åer-succinct QMA delegation scheme additionally satisfying veriÔ¨Åer
obliviousness. For simplicity, we assume that SemiSuccinct is a four-round protocol. We formalize
the execution of SemiSuccinct on a QMA instance x as follows:
‚Ä¢ The veriÔ¨Åer computes and sends pk ‚ÜêSemiSuccinct.V1(1Œª, 1|x|; r) (obliviously to the instance
x) with randomness r ‚Üê{0, 1}Œª.
‚Ä¢ The prover, on initial state |œà‚ü©, computes (y, œÅ) ‚ÜêSemiSuccinct.P(1Œª, pk, |œà‚ü©), which results
in a message y and residual state œÅ.
‚Ä¢ The veriÔ¨Åer computes and sends Œ≤ = SemiSuccinct.V2(r), obliviously to the instance x and
the prover message y.
‚Ä¢ The prover computes and sends z ‚ÜêSemiSuccinct.P(œÅ, Œ≤).
‚Ä¢ The veriÔ¨Åer computes and outputs a (potentially expensive) predicate V (x, y, z, r).
Finally, let AoK denote the state-preserving succinct argument of knowledge of Theorem 9.2,
and let H denote a collapsing hash function family mapping {0, 1}‚àóto {0, 1}Œª. Our succinct QMA
delegation protocol QMArg is deÔ¨Åned as follows.
1. The veriÔ¨Åer computes and sends pk = SemiSuccinct.V1(1Œª, 1|x|; r) with randomness r ‚Üê
{0, 1}Œª, along with a hash function h ‚ÜêHŒª.
2. The prover computes (y, œÅ) ‚ÜêSemiSuccinct.P(1Œª, pk, |œà‚ü©) and sends ÀÜ
y = h(y).
3. The prover and veriÔ¨Åer execute AoK on the statement ‚Äú‚àÉw such that ÀÜ
y = h(w).‚Äù
4. The veriÔ¨Åer computes and sends Œ≤ = SemiSuccinct.V2(r). Note that SemiSuccinct.V2 is obliv-
ious to the prover message and so can be computed without it.
5. The prover computes z ‚ÜêSemiSuccinct.P(œÅ, Œ≤) and sends ÀÜ
z = h(z).
6. The prover and veriÔ¨Åer execute AoK on the statement ‚Äú‚àÉw such that ÀÜ
z = h(w).‚Äù
7. The veriÔ¨Åer sends r.
8. The prover and veriÔ¨Åer execute AoK on the statement ‚àÉw1, w2 such that ÀÜ
y = h(w1), ÀÜ
z = h(w2),
and V (x, w1, w2, r) = 1.
Completeness of the protocol follows directly from the completeness of SemiSuccinct and AoK.
Moreover, succinctness follows directly from the compression of H, the veriÔ¨Åer succinctness of
SemiSuccinct, and the succinctness of AoK.
Since AoK has a round complexity of 4 and the Ô¨Årst message can be re-used (indeed, h can be
used as the Ô¨Årst message for AoK), the round complexity of QMArg is 12.
52


9.2.1
Proof of Soundness
Theorem 9.3. Assume that SemiSuccinct is (post-quantum) computationally sound, H is col-
lapsing,26 and that AoK is an œµ-state-preserving argument of knowledge.
Then, QMArg is
(post-quantum) computationally sound.
Proof. Let x Ã∏‚ààL and suppose that a QPT P ‚àó(œÅ, x) breaks the soundness of QMArg with probability
œµ‚àó. We use P ‚àó, together with the soundness guarantees of AoK and the collision resistance property
of H, to break the soundness of SemiSuccinct. In particular, consider the following attack on the
soundness of SemiSuccinct:
‚Ä¢ Set an accuracy parameter œµ =
œµ‚àó
10.
Whenever we call the AoK extractor E, we will use
accuracy parameter œµ.
‚Ä¢ Given a veriÔ¨Åer message pk, we feed (h, pk) to P ‚àó(œÅ, x) and obtain a hash value ÀÜ
y. Then, we
run the AoK extractor E on P ‚àó‚Äôs execution of step (3) (the Ô¨Årst execution of AoK), outputting
a triple (Àú
œÑ1, Àú
œÅ1, y). We send y to the veriÔ¨Åer.
‚Ä¢ Given the veriÔ¨Åer challenge Œ≤, we run P ‚àó( Àú
œÅ1, pk, h, Àú
œÑ1) to obtain a message ÀÜ
z. Then, we run
the AoK extractor E on P ‚àó‚Äôs execution of step (6), obtaining a triple (Àú
œÑ2, Àú
œÅ2, z). We send z
to the veriÔ¨Åer.
Finally, to analyze the behavior of this attack, we consider the following additional step (this
is only a mental experiment).
‚Ä¢ Given the secret veriÔ¨Åer randomness r, run the AoK extractor E on P ‚àó‚Äôs execution of step
(8) to obtain a triple (Àú
œÑ3, Àú
œÅ3, y‚Ä≤, z‚Ä≤).
Claim 9.4. With probability at least œµ over the attack experiment, we have that SemiSuccinct.V (x,
y, z, r) = 1.
Note that this claim contradicts the soundness of SemiSuccinct.
Proof. The equation SemiSuccinct.V (x, y, z, r) = 1 follows from the following properties of an
execution of the mental experiment:
‚Ä¢ h(y) = ÀÜ
y
‚Ä¢ h(z) = ÀÜ
z
‚Ä¢ h(y‚Ä≤) = ÀÜ
y
‚Ä¢ h(z‚Ä≤) = ÀÜ
z
‚Ä¢ SemiSuccinct.V (x, y‚Ä≤, z‚Ä≤, r) = 1.
26Collision-resistance of H suÔ¨Éces.
53


The above suÔ¨Éces because it implies that (y, z) = (y‚Ä≤, z‚Ä≤) except with negligible probabil-
ity by the collapsing (or just collision-resistance) of H, and so the last equation implies that
SemiSuccinct.V (x, y, z, r) = 1 (except with negligible probability).
Finally, we note that all Ô¨Åve of the above conditions simultaneously hold with probability at
least œµ by the state-preservation and correctness of E.
More speciÔ¨Åcally,
‚Ä¢ The transcript (x, pk, h, ÀÜ
y, Àú
œÑ1, Œ≤, ÀÜ
z, Àú
œÑ2, r, Àú
œÑ3) is accepting (according to the QMArg veriÔ¨Åer) with
probability at least œµ‚àó‚àí3œµ. This follows by a hybrid argument invoking the state preservation
of E‚àóon the three executions of AoK (Ô¨Årst w.r.t. Àú
œÑ1, then Àú
œÑ2, then Àú
œÑ3).
‚Ä¢ Then, the correctness property of E implies that all Ô¨Åve conditions hold simultaneously with
probability at least œµ‚àó‚àí6œµ ‚àínegl(Œª).
This completes the proof of soundness of QMArg.
9.3
The QMA Protocol, Version 2
We now describe a public-coin variant of the Section 9.2 transformation that additionally uses a
Fully Homomorphic Encryption (FHE) scheme FHE = (FHE.Gen, FHE.Enc, FHE.Dec, FHE.Eval).
Let SemiSuccinct and AoK denote the argument systems from Section 9.2. Then, our second
succinct argument system QMArg2 is deÔ¨Åned as follows.
1. The veriÔ¨Åer computes and sends pk = SemiSuccinct.V1(1Œª, 1|x|; r) with randomness r ‚Üê
{0, 1}Œª, along with a hash function h ‚ÜêHŒª.
2. The veriÔ¨Åer also samples (FHE.pk, FHE.sk) ‚ÜêFHE.Gen(1Œª) and computes FHE ciphertext
ctV = FHE.Enc(FHE.pk, r). The veriÔ¨Åer sends FHE.pk, ctV to the prover.
3. The prover computes (y, œÅ) ‚ÜêSemiSuccinct.P(1Œª, pk, |œà‚ü©) and sends ÀÜ
y = h(y).
4. The prover and veriÔ¨Åer execute AoK on the statement ‚Äú‚àÉw such that ÀÜ
y = h(w).‚Äù
5. The veriÔ¨Åer computes and sends Œ≤ = SemiSuccinct.V2(r). Note that SemiSuccinct.V2 is obliv-
ious to the prover message and so can be computed without it.
6. The prover computes z ‚ÜêSemiSuccinct.P(œÅ, Œ≤) and sends ÀÜ
z = h(z). The prover also com-
putes ctP = FHE.Eval(V (x, y, z, ¬∑), ctV ) and sends ctP to the veriÔ¨Åer.
7. The prover and veriÔ¨Åer execute AoK on the statement ‚àÉw1, w2 such that ÀÜ
y = h(w1), ÀÜ
z = h(w2),
and ctP = FHE.Eval(V (x, y, z, ¬∑), ctV ).
8. The veriÔ¨Åer checks that FHE.Dec(ctP ) = 1.
As before, completeness and succinctness follow immediately from the deÔ¨Ånitions. Additionally,
we note that the round complexity has been reduced to 8 because AoK is only invoked twice.
Finally, we note that as long as SemiSuccinct and AoK are public-coin (except for the Ô¨Årst message
of SemiSuccinct), then QMArg2 is also public-coin (except for the Ô¨Årst veriÔ¨Åer message).
54


9.3.1
Proof of Soundness
Theorem 9.5. Assume that SemiSuccinct is (post-quantum) computationally sound, H is col-
lapsing, FHE is semantically secure, and that AoK is an œµ-state-preserving argument of knowl-
edge. Then, QMArg2 is (post-quantum) computationally sound.
Proof. Let x Ã∏‚ààL and suppose that a QPT P ‚àó(œÅ, x) breaks the soundness of QMArg2 with proba-
bility œµ‚àó. We use P ‚àó, together with the soundness guarantees of AoK, the semantic security of FHE,
and the collision resistance property of H, to break the soundness of SemiSuccinct. In particular,
consider the following attack on the soundness of SemiSuccinct:
‚Ä¢ Set an accuracy parameter œµ =
œµ‚àó
10.
Whenever we call the AoK extractor E, we will use
accuracy parameter œµ.
‚Ä¢ Given a veriÔ¨Åer message pk, we sample h, FHE.pk ourselves and feed (h, pk, FHE.pk, ctV =
FHE.Enc(FHE.pk, 0)) to P ‚àó(œÅ, x) and obtain a hash value ÀÜ
y. Then, we run the AoK extractor
E on P ‚àó‚Äôs execution of step (3) (the Ô¨Årst execution of AoK), outputting a triple (Àú
œÑ1, Àú
œÅ1, y).
We send y to the veriÔ¨Åer.
‚Ä¢ Given the veriÔ¨Åer challenge Œ≤, we run P ‚àó( Àú
œÅ1, pk, h, Àú
œÑ1) to obtain a message ÀÜ
z, ctP . Then, we
run the AoK extractor E on P ‚àó‚Äôs execution of step (6), obtaining a triple (Àú
œÑ2, Àú
œÅ2, y‚Ä≤, z). We
send z to the veriÔ¨Åer.
We claim that this attack breaks the soundness of SemiSuccinct ‚Äì meaning that V (x, y, z, r) = 1
‚Äì with probability at least œµ‚àó‚àí4œµ ‚àínegl(Œª). To prove this, by FHE semantic security, it suÔ¨Éces to
show the same thing when ctV is instead sampled as FHE.Enc(FHE.pk, r).
From here, the proof proceeds similarly to the proof of Theorem 9.3. In particular, the equation
SemiSuccinct.V (x, y, z, r) = 1 follows from the following properties of the hybrid attack execution:
‚Ä¢ h(y) = ÀÜ
y
‚Ä¢ h(y‚Ä≤) = ÀÜ
y
‚Ä¢ h(z) = ÀÜ
z
‚Ä¢ FHE.Eval(V (x, y‚Ä≤, z, ¬∑), ctV ) = ctP
‚Ä¢ FHE.Dec(FHE.sk, ctP ) = 1.
This suÔ¨Éces due to the collapsing of H and the correctness of FHE.Eval. By the same argument
as in the proof of Theorem 9.3, these properties simultaneously hold with probabiltiy at least
œµ‚àó‚àí4œµ ‚àínegl(Œª) by the state-preserving extraction properties of AoK.
This completes the proof of soundness of QMArg2.
55


10
Additional Results
In this section, we describe a number of additional new results that follow from our template
for building succinct arguments for QMA. First, we show how to compile the protocol from Sec-
tion 9.3 into a two-message succinct argument for QMA in the quantum random oracle model.
We sometimes refer to such argument systems as designated-veriÔ¨Åer SNARGs (dvSNARGs) in the
QROM. Next, we show how to obtain batch arguments for QMA (where the communication size
only depends on a single instance size) from only the quantum hardness of learning with errors
(i.e. without indistinguishability obfuscation). Finally, we describe how to add zero-knowledge to
our succinct argument in the plain model and to our dvSNARG in the QROM.
10.1
Succinct Non-interactive Arguments in the QROM
Consider any constant-round protocol (P, V ) for language L that is public-coin except for the Ô¨Årst
message. That is, the veriÔ¨Åer is deÔ¨Åned by two circuits (V0, V1). Given instance x, the veriÔ¨Åer Ô¨Årst
samples random coins r and computes a Ô¨Årst message s0 = V0(x, r). Then, the subsequent veriÔ¨Åer
message are uniformly random strings s1, . . . , sc of at least Œª bits. Finally, the veriÔ¨Åer computes a
circuit V1(x, r, s0, t0, s1, t1, . . . , sc, tc) that determines whether it accepts or rejects, where t0, . . . , tc
are the prover messages. Let H : ((I √ó S) ‚à™S) √ó ([c] √ó T) ‚ÜíS be a random oracle, where I is the
space of instances, S is the space of veriÔ¨Åer messages, and T is the space of prover messages. Let
(PFS, VFS) be the following protocol.
‚Ä¢ Given x, VFS samples r and outputs s0 = V0(x, r).
‚Ä¢ PFS runs P on (x, s0) to obtain t0. Then it computes s1 = H((x, s0), (0, t0)) and continues to
run P on s1 to obtain t1. Then for i ‚àà[c], it computes si = H(si‚àí1, (i, ti‚àí1)) and continues
to run P on si to obtain ti. Finally, it sends (t0, . . . , tc).
‚Ä¢ VFS checks that s1 = H((x, s0), (0, t0)) and that for each i ‚àà[2, . . . , c], si = H(si‚àí1, (i ‚àí
1, ti‚àí1)). If so, it outputs V (x, r, s0, t0, . . . , sc, tc).
Theorem 10.1 (Multi-input measure-and-reprogram [DFM20]). Let c be an integer, and W, X, Y
be Ô¨Ånite sets. There exists a polynomial-time quantum algorithm S such that the following
holds. Let A be an arbitrary quantum oracle algorithm that makes q queries to a uniformly
random H : (W ‚à™Y )√óX ‚ÜíY and outputs a tuple (x0, . . . , xc). Then for any b
x ‚ààXc+1 without
duplicate entries, any predicate V , and any w ‚ààW,
Pr
y1,...,yc

(x0, . . . , xc) = b
x ‚àßV (w, x0, y1, x1, . . . , yc, xc) = 1 : (x0, . . . , xc) ‚ÜêSA(y1, . . . , yc)

‚â•
c!
(q + c + 1)2c Pr
H
Ô£Æ
Ô£Ø
Ô£Ø
Ô£Ø
Ô£∞(x0, . . . , xc) = b
x ‚àßV
Ô£´
Ô£¨
Ô£¨
Ô£¨
Ô£≠
w, x0,
y1 := H(w, x0), x1,
y2 := H(y1, x1), x2, . . . ,
yc := H(yc‚àí1, xc‚àí1), xc
Ô£∂
Ô£∑
Ô£∑
Ô£∑
Ô£∏= 1 : (x0, . . . , xc) ‚ÜêAH
Ô£π
Ô£∫
Ô£∫
Ô£∫
Ô£ª‚àíœµb
x,
56


where P
b
x œµb
x = c!/|Y |, and SA is an algorithm that has black-box access to the algorithms
of A and for each i ‚àà[c], receives yi and only after outputting xi‚àí1.27
Theorem 10.2. If (P, V ) is a sound protocol for L, then (PFS, VFS) is a sound protocol for L
in the quantum random oracle model.
The following corollary then follows immediately from the protocol given in Section 9.3.
Corollary 10.3. Assuming post-quantum indistinguishability obfuscation, the post-quantum
hardness of the learning with errors problem, and post-quantum fully homomorphic encryp-
tion, there exists a designated veriÔ¨Åer succinct non-interactive argument system (dvSNARG)
for QMA in the quantum random oracle model.
Proof. (of Theorem 10.2) Let H : ((I √ó S) ‚à™S) √ó ([c] √ó T) ‚ÜíS be the random oracle used in
(PFS, VFS). Consider an adversary A in the protocol (PFS, VFS) that makes q = poly(Œª) queries to
H and consider any x /
‚ààL. For any r, let V1,r be the predicate V1 with r hard-coded, and let Ar be
the adversary A initialized with (x, V0(x, r)). DeÔ¨Åne œµ(r) to be the success probability of Ar (that
is, the probability it makes VFS output 1). Then for any Ô¨Åxed r,
œµ(r) = Pr
H
Ô£Æ
Ô£∞V1,r
Ô£´
Ô£≠
x, t0,
s1 := H((x, V0(x, r), (0, t0)), t1, . . . ,
sc := H(sc‚àí1, (c ‚àí1, tc‚àí1)), tc
Ô£∂
Ô£∏= 1 : (t0, . . . , tn) ‚ÜêAH
r
Ô£π
Ô£ª.
Note that the overall success probability A is œµ := Er[œµ(r)]. Now, by setting W = (I √ó S), X =
([c] √ó T), Y = S, and w = (x, V0(x, r)), Theorem 10.1 implies that for any Ô¨Åxed r, the success
probability Œ¥(r) of the simulator SAr(s1, . . . , sc) is
Œ¥(r) ‚â•
1
poly(Œª)œµ(r) ‚àínegl(Œª),
which follows by (i) summing over all t0, . . . , t1 and noting that (0, t0), . . . , (c, tc) contain no dupli-
cates, and (ii) the fact that q = poly(Œª) and c is a constant. Finally, observe that by the soundness
of (P, V ), Er[Œ¥(r)] = negl(Œª). Indeed, by deÔ¨Ånition SA is a valid cheating prover in the protocol
(P, V ) since it only receives random si after outputting ti‚àí1. This establishes that
1
poly(Œª) E
r [œµ(r)] ‚àínegl(Œª) ‚â§negl(Œª),
which implies that œµ = negl(Œª).
27This theorem as stated is actually a special case of [DFM20, Theorem 7], where w is Ô¨Åxed. In other words, it
corresponds to [DFM20, Theorem 7] where the class of adversaries considered all produce a Ô¨Åxed w as the Ô¨Årst part
of their output.
57


10.2
Batch Arguments for QMA
Now, we show how to obtain batch arguments for QMA from the post-quantum hardness of learning
with errors. We Ô¨Årst describe a veriÔ¨Åer-succinct protocol for verifying n QMA instances, where the
veriÔ¨Åer message size only grows with the time T needed for QMA veriÔ¨Åcation of a single instance.
Note that here we do not use the succinct key generation protocol from Section 7.1, and thus do
not rely on indistinguishability obfuscation.
Ingredients:
‚Ä¢ Let (PFHM, VFHM) be the non-interactive protocol described in Lemma 8.4 for language L
with associated polynomials k(Œª), ‚Ñì(Œª).
‚Ä¢ Let PMeas = (Commit, Open) and VMeas = (Gen, Test, Out) be the prover and veriÔ¨Åer algo-
rithms for an ‚Ñì(Œª)-qubit commit-and-open measurement protocol, deÔ¨Åned in Section 4 and
constructed in [Mah18].
The Protocol:
‚Ä¢ The veriÔ¨Åer is initialized with n instances (x1, . . . , xn) ‚àà{0, 1}Œª and the prover is initialized
with (x1, . . . , xn) and k(Œª) copies of each witness |œÜj‚ü©‚ààRL(xj).
‚Ä¢ The veriÔ¨Åer samples h ‚Üê{0, 1}‚Ñì(Œª) and deÔ¨Ånes C such that C(i) = hi. The veriÔ¨Åer computes
(pk, sk) ‚ÜêGen(1Œª, C) and sends pk to the prover.
‚Ä¢ For each j ‚àà[n], the prover Ô¨Årst computes |œàj‚ü©‚ÜêPFHM

xj, |œÜj‚ü©‚äók(Œª)
, and then computes
(yj, |stj‚ü©) ‚ÜêCommit(pk, |œàj‚ü©). It sends (y1, . . . , yn) to the veriÔ¨Åer.
‚Ä¢ The veriÔ¨Åer samples a random challenge c ‚Üê{0, 1} and sends c to the prover.
‚Ä¢ For each j ‚àà[n], the prover computes zj ‚ÜêOpen(|stj‚ü©, c) and sends (z1, . . . , zn) to the veriÔ¨Åer.
‚Ä¢ If c = 0, the veriÔ¨Åer checks whether Test(pk, (yj, zj)) = acc and rejects if the test fails
on any index. If c = 1, the veriÔ¨Åer computes mj ‚ÜêOut(sk, (yj, zj)) and checks whether
VFHM(xj, mj) = acc. The veriÔ¨Åer accepts if and only if all of the veriÔ¨Åcations are successful.
Theorem 10.4. Let (PBatch, VBatch) be the Œª-fold parallel repetition of the above protocol. Then,
(PBatch, VBatch) satisÔ¨Åes completeness as in DeÔ¨Ånition 3.1 and soundness as in DeÔ¨Ånition 3.2.
Moreover, for instances (x1, . . . , xn) where T is the maximum QMA veriÔ¨Åcation time for any
individual xi, the total size of veriÔ¨Åer messages is poly(Œª, T).
Proof. First, the veriÔ¨Åer message guarantee follows immediately from the description of the pro-
tocol. Completeness follows via the same argument used to prove completeness in Theorem 8.5
(without the additional step involving the PRF). Soundness also follows along the same lines, ex-
cept that, if xi /
‚ààL, we deÔ¨Åne V (i)
Œª,r,0 to be the veriÔ¨Åer‚Äôs accept projection on instance i on a test
round, and V (i)
Œª,r,1 to be the veriÔ¨Åer‚Äôs accept projection on instance i on a measurement round.
58


Finally, we observe that Theorem 9.3 holds when the veriÔ¨Åer-succinct protocol is replaced with
the batch protocol above, with no change in analysis. This results in the following corollary.
Corollary 10.5. Assuming the post-quantum hardness of the learning with errors problem,
there exists a batch argument for QMA, where the total communication is polynomial in the
QMA veriÔ¨Åcation time for a single QMA instance.
10.3
Zero Knowledge
In this section, we provide sketches for how to obtain the following results.
‚Ä¢ A (non-adaptive) zero-knowledge succinct argument for QMA (in the plain model).
‚Ä¢ A (non-adaptive) zero-knowledge dvSNARG for QMA in the quantum random oracle model.
In both of our sketches, we will make use of secure two-party computation for reactive func-
tionalities, which are interactive functionalities where multiple public circuits may be computed
sequentially over private inputs, and where the description of these public circuits may be deter-
mined after some of the private inputs are submitted to the functionality and may even depend on
the outputs of previously computed circuits.
The plain model.
Here, we can start with the protocol in Section 9.2. This protocol as such
does not provide any hiding property for the prover‚Äôs witness. However, we can use secure two-
party computation for the following reactive functionality to hide all information about the prover‚Äôs
witness from the veriÔ¨Åer, while preserving soundness.
‚Ä¢ Take as input random coins rP , rV from each party, compute the veriÔ¨Åer‚Äôs Ô¨Årst message of
the protocol using randomness r := rP ‚äïrV , and output this message to the prover.
‚Ä¢ For each subsequent round, take as input the prover‚Äôs message, and then compute and output
the next veriÔ¨Åer‚Äôs message (using random coins r) to the prover.
‚Ä¢ After the Ô¨Ånal prover‚Äôs message, compute and output the veriÔ¨Åer‚Äôs verdict (based on all prover
messages and r) to the veriÔ¨Åer.
Note that, since the veriÔ¨Åer is classical, this functionality can be implemented by a protocol
for (post-quantum) secure two-party computation of classical (reactive) functionalities, such as
[HSS11].28 To argue soundness (for any Ô¨Åxed no instance), we can run the two-party computation
simulator for a malicious prover in order to extract inputs from the prover and reduce to soundness
of the underlying protocol.
To argue zero-knowledge (for any Ô¨Åxed yes instance), we can run
the two-party computation simulator for a malicious veriÔ¨Åer, programming the Ô¨Ånal output to 1.
Note that the veriÔ¨Åer only receives this single bit of information from the functionality, which is
internally running an honest veriÔ¨Åer. Thus, this simulation and output is indistinguishable from
the real interaction with an honest prover.
28Note that [HSS11] is based on Watrous rewinding, and thus requires polynomially many rounds of interaction.
We do not attempt to optimize the round-complexity of our zero-knowledge protocol, but note that non-black-box
techniques such as those of [BS20] (with additional assumptions), or a relaxation to œµ-zero-knowledge [CCLY21] could
result in a constant-round protocol.
59


The QROM.
In order to add zero-knowledge to our two-message succinct argument in the
QROM, we have to be careful in order to avoid using the random oracle in a non-black-box manner.
We achieve this in two steps: We Ô¨Årst construct a constant-round honest-veriÔ¨Åer zero-knowledge
argument where, (i) the veriÔ¨Åer is public-coin except for the Ô¨Årst message, and (ii) the protocol
remains zero-knowledge even against a veriÔ¨Åer that computes its Ô¨Årst message maliciously. Second,
we compress this protocol into a two-message protocol in the QROM using the same arguments
in Section 10.1. Since the protocol has constant rounds and is public-coin after the Ô¨Årst veriÔ¨Åer
message, soundness holds via the same argument. Zero-knowledge holds because we have zero-
knowledge against a malicious Ô¨Årst message, and honest-veriÔ¨Åer zero-knowledge with respect to all
subsequent messages, which will be sampled uniformly at random by the random oracle.
We now turn our attention to the construction of the constant-round honest-veriÔ¨Åer zero-
knowledge argument. We are going to assume the existence of a post-quantum secure two-message
two-party computation protocol for reactive (classical) functionalities. One can instantiate this
with the two-message secure computation protocol of [IPS08] based on (post-quantum) two-message
oblivious transfer in the common random string (CRS) model, which we can instantiate from the
post-quantum hardness of learning with errors [PVW08]. Note that when we later compress this
protocol in the QROM, the CRS can be sampled by querying the random oracle on a Ô¨Åxed input.
We will use such a protocol to implement the following reactive functionality.
‚Ä¢ Take as input random coins r from the veriÔ¨Åer.
‚Ä¢ The veriÔ¨Åer‚Äôs Ô¨Årst message is sampled by the veriÔ¨Åer given to the functionality as a public
input.
‚Ä¢ Take as input the prover‚Äôs Ô¨Årst message.
‚Ä¢ The veriÔ¨Åer‚Äôs second message is sampled by the veriÔ¨Åer and given to the functionality as a
public input.
‚Ä¢ . . .
‚Ä¢ Take as input the prover‚Äôs Ô¨Ånal message.
‚Ä¢ Check that the veriÔ¨Åer‚Äôs Ô¨Årst message is computed honestly from random coins r, and if so,
compute the veriÔ¨Åer‚Äôs verdict using r, the prover messages, and the veriÔ¨Åer‚Äôs messages, and
deliver this output to the veriÔ¨Åer.
Note that all the veriÔ¨Åer messages are still sampled publicly and as in the protocol from Section 9.3,
so the prover can still compute its responses given these messages.
Now, we argue that the resulting protocol satisÔ¨Åes the required properties. To argue soundness,
we can run the two-party computation simulator for a malicious prover in order to extract inputs
from the prover and reduce to soundness of the original protocol. To argue honest-veriÔ¨Åer zero-
knowledge with a malicious Ô¨Årst message, we can run the two-party computation simulator for a
malicious veriÔ¨Åer, programming the Ô¨Ånal output to 1. However, since we are allowing the veriÔ¨Åer
to choose its Ô¨Årst message maliciously, we have to argue that for any choice of randomness used to
generate the veriÔ¨Åer‚Äôs Ô¨Årst message, the subsequent interaction between honest prover (on input a
60


valid witness for a true statement) and an honest veriÔ¨Åer results in the veriÔ¨Åer outputting 1 with
overwhelming probability. Recalling the structure of the veriÔ¨Åer‚Äôs Ô¨Årst message in the Section 9.3
protocol, we see that this requires perfectly correct FHE and a perfectly correct measurement pro-
tocol. Achieving FHE with perfect correctness is standard by truncating the error distribution, and
we can obtain a perfectly correct measurement protocol as discussed in Section 3.5 and Section 4.1.
References
[ACGH20]
Gorjan Alagic, Andrew M. Childs, Alex B. Grilo, and Shih-Han Hung. Non-interactive
classical veriÔ¨Åcation of quantum computation. pages 153‚Äì180, 2020. 3, 6, 13, 47, 48,
65
[ALM+92]
Sanjeev Arora, Carsten Lund, Rajeev Motwani, Madhu Sudan, and Mario Szegedy.
Proof veriÔ¨Åcation and hardness of approximation problems. pages 14‚Äì23, 1992. 1
[AS92]
Sanjeev Arora and Shmuel Safra. Probabilistic checking of proofs; A new characteri-
zation of NP. pages 2‚Äì13, 1992. 1
[BCM+18] Zvika Brakerski, Paul Christiano, Urmila Mahadev, Umesh V. Vazirani, and Thomas
Vidick. A cryptographic test of quantumness and certiÔ¨Åable randomness from a single
quantum device. pages 320‚Äì331, 2018. 18, 19, 20, 27, 28
[BDGM20] Zvika Brakerski, Nico D√∂ttling, Sanjam Garg, and Giulio Malavolta. Factoring and
pairings are not necessary for io:
Circular-secure lwe suÔ¨Éces.
Cryptology ePrint
Archive, Report 2020/1024, 2020. https://ia.cr/2020/1024. 22
[BFL90]
L√°szl√≥ Babai, Lance Fortnow, and Carsten Lund. Non-deterministic exponential time
has two-prover interactive protocols. pages 16‚Äì25, 1990. 1
[BGI14]
Elette Boyle, ShaÔ¨ÅGoldwasser, and Ioana Ivan. Functional signatures and pseudoran-
dom functions. pages 501‚Äì519, 2014. 22
[BGKW88] Michael Ben-Or, ShaÔ¨ÅGoldwasser, Joe Kilian, and Avi Wigderson. Multi-prover in-
teractive proofs: How to remove intractability assumptions. pages 113‚Äì131, 1988. 1
[BGMZ18] James Bartusek, Jiaxin Guan, Fermi Ma, and Mark Zhandry.
Return of GGH15:
Provable security against zeroizing attacks. pages 544‚Äì574, 2018. 22
[BGV12]
Zvika Brakerski, Craig Gentry, and Vinod Vaikuntanathan. (Leveled) fully homomor-
phic encryption without bootstrapping. pages 309‚Äì325, 2012. 21
[BS20]
Nir Bitansky and Omri Shmueli. Post-quantum zero knowledge in constant rounds.
pages 269‚Äì279, 2020. 59
[BV97]
Ethan Bernstein and Umesh Vazirani. Quantum complexity theory. SIAM Journal
on computing, 26(5):1411‚Äì1473, 1997. 1
61


[BV11]
Zvika Brakerski and Vinod Vaikuntanathan. EÔ¨Écient fully homomorphic encryption
from (standard) LWE. pages 97‚Äì106, 2011. 21
[BV14]
Zvika Brakerski and Vinod Vaikuntanathan. Lattice-based FHE as secure as PKE.
pages 1‚Äì12, 2014. 21
[BV17]
Nir Bitansky and Vinod Vaikuntanathan. A note on perfect correctness by derandom-
ization. pages 592‚Äì606, 2017. 22
[BW13]
Dan Boneh and Brent Waters. Constrained pseudorandom functions and their appli-
cations. pages 280‚Äì300, 2013. 22
[CCLY21]
Nai-Hui Chia, Kai-Min Chung, Xiao Liang, and Takashi Yamakawa. Post-quantum sim-
ulatable extraction with minimal assumptions: Black-box and constant-round. Cryp-
tology ePrint Archive, Report 2021/1516, 2021. https://ia.cr/2021/1516. 59
[CCY20]
Nai-Hui Chia, Kai-Min Chung, and Takashi Yamakawa. Classical veriÔ¨Åcation of quan-
tum computations with eÔ¨Écient veriÔ¨Åer. pages 181‚Äì206, 2020. 3
[CLLW20]
Kai-Min Chung, Yi Lee, Han-Hsuan Lin, and Xiaodi Wu. Constant-round blind clas-
sical veriÔ¨Åcation of quantum sampling. arXiv preprint arXiv:2012.04848, 2020. 1
[CMSZ21]
Alessandro Chiesa, Fermi Ma, Nicholas Spooner, and Mark Zhandry. Post-quantum
succinct arguments: breaking the quantum rewinding barrier. FOCS ‚Äô21, 2021. 13, 14,
50, 51
[CVW18]
Yilei Chen, Vinod Vaikuntanathan, and Hoeteck Wee. GGH15 beyond permutation
branching programs: Proofs, attacks, and candidates. pages 577‚Äì607, 2018. 22
[DFM20]
Jelle Don, Serge Fehr, and Christian Majenz. The measure-and-reprogram technique
2.0: Multi-round Ô¨Åat-shamir and more. pages 602‚Äì631, 2020. 56, 57
[DQV+21]
Lalita Devadas, Willy Quach, Vinod Vaikuntanathan, Hoeteck Wee, and Daniel Wichs.
Succinct lwe sampling, random polynomials, and obfuscation.
Cryptology ePrint
Archive, Report 2021/1226, 2021. https://ia.cr/2021/1226. 22
[FHM18]
Joseph F. Fitzsimons, Michal Hajdusek, and Tomoyuki Morimae. Post hoc veriÔ¨Åcation
of quantum computation. Phys. Rev. Lett., 120:040501, Jan 2018. 2, 6, 13, 47, 48
[Gen09]
Craig Gentry. Fully homomorphic encryption using ideal lattices. pages 169‚Äì178, 2009.
21
[GGM84]
Oded Goldreich, ShaÔ¨ÅGoldwasser, and Silvio Micali. How to construct random func-
tions (extended abstract). pages 464‚Äì479, 1984. 22
[GMR85]
ShaÔ¨ÅGoldwasser, Silvio Micali, and Charles RackoÔ¨Ä. The knowledge complexity of
interactive proof-systems (extended abstract). pages 291‚Äì304, 1985. 1
62


[GP21]
Romain Gay and Rafael Pass. Indistinguishability obfuscation from circular security.
In Samir Khuller and Virginia Vassilevska Williams, editors, STOC ‚Äô21: 53rd Annual
ACM SIGACT Symposium on Theory of Computing, Virtual Event, Italy, June
21-25, 2021, pages 736‚Äì749. ACM, 2021. 22
[GVW15]
Sergey Gorbunov, Vinod Vaikuntanathan, and Daniel Wichs. Leveled fully homomor-
phic signatures from standard lattices. pages 469‚Äì477, 2015. 4, 18
[HSS11]
Sean Hallgren, Adam Smith, and Fang Song. Classical cryptographic protocols in a
quantum world. pages 411‚Äì428, 2011. 59
[IPS08]
Yuval Ishai, Manoj Prabhakaran, and Amit Sahai. Founding cryptography on oblivious
transfer - eÔ¨Éciently. pages 572‚Äì591, 2008. 60
[JLS21]
Aayush Jain, Huijia Lin, and Amit Sahai. Indistinguishability obfuscation from well-
founded assumptions. In Samir Khuller and Virginia Vassilevska Williams, editors,
STOC ‚Äô21: 53rd Annual ACM SIGACT Symposium on Theory of Computing,
Virtual Event, Italy, June 21-25, 2021, pages 60‚Äì73. ACM, 2021. 22
[Kil92]
Joe Kilian. A note on eÔ¨Écient zero-knowledge proofs and arguments (extended ab-
stract). pages 723‚Äì732, 1992. 1
[KPTZ13]
Aggelos Kiayias, Stavros Papadopoulos, Nikos Triandopoulos, and Thomas Zacharias.
Delegatable pseudorandom functions and applications. pages 669‚Äì684, 2013. 22
[LMS21]
Alex Lombardi, Fermi Ma, and Nicholas Spooner.
Post-quantum zero knowledge,
revisited (or: How to do quantum rewinding undetectably). Cryptology ePrint Archive,
Report 2021/1543, 2021. https://ia.cr/2021/1543. 14, 50, 51
[Mah18]
Urmila Mahadev. Classical veriÔ¨Åcation of quantum computations. pages 259‚Äì267, 2018.
1, 2, 3, 4, 5, 6, 7, 8, 16, 18, 19, 20, 23, 24, 25, 26, 27, 29, 41, 58
[Mic94]
Silvio Micali.
A secure and eÔ¨Écient digital signature algorithm.
Technical Memo
MIT/LCS/TM-501b, Massachusetts Institute of Technology, Laboratory for Computer
Science, April 1994. 1
[PVW08]
Chris Peikert, Vinod Vaikuntanathan, and Brent Waters. A framework for eÔ¨Écient
and composable oblivious transfer. pages 554‚Äì571, 2008. 4, 18, 60
[PW08]
Chris Peikert and Brent Waters. Lossy trapdoor functions and their applications. pages
187‚Äì196, 2008. 4, 18, 20
[Reg05]
Oded Regev. On lattices, learning with errors, random linear codes, and cryptography.
pages 84‚Äì93, 2005. 18
[SW14]
Amit Sahai and Brent Waters. How to use indistinguishability obfuscation: deniable
encryption, and more. pages 475‚Äì484, 2014. 7, 22
63


[Unr12]
Dominique Unruh. Quantum proofs of knowledge. In Annual international confer-
ence on the theory and applications of cryptographic techniques, pages 135‚Äì152.
Springer, 2012. 16
[Unr16a]
Dominique Unruh. Collapse-binding quantum commitments without random oracles.
pages 166‚Äì195, 2016. 20
[Unr16b]
Dominique Unruh. Computationally binding quantum commitments. pages 497‚Äì527,
2016. 5, 20
[Vid20]
Thomas Vidick. Interactions with quantum devices (course), 2020. http://users.
cms.caltech.edu/~vidick/teaching/fsmp/fsmp.pdf. 2, 8, 9, 29, 35
[VZ21]
Thomas Vidick and Tina Zhang. Classical proofs of quantum knowledge. pages 630‚Äì
660, 2021. 6
[WW21]
Hoeteck Wee and Daniel Wichs. Candidate obfuscation via oblivious LWE sampling.
pages 127‚Äì156, 2021. 22
A
Proofs from Section 8
Lemma A.1. Consider a commit-challenge-response protocol with the following properties.
1. VŒª,r,0 does not depend on r (that is, it is publicly computable given the transcript).
2. For any P ‚àó, if Er
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
Ei
= 1‚àínegl(Œª), then Er
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,1


œàP ‚àó
Œª,r
Ei
= negl(Œª).
Then, the protocol has computationally orthogonal projectors.
Proof. Suppose there exists a prover P ‚àóand a polynomial p(Œª) such that for inÔ¨Ånitely many Œª,
E
r
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0Œ†P ‚àó
Œª,r,1Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
Ei
‚â•1/p(Œª).
DeÔ¨Åne an alternate prover b
P ‚àóas follows.
1. b
P ‚àótakes as input p(Œª)4 copies of P ‚àó‚Äôs auxiliary advice, and pk sampled by the veriÔ¨Åer.
2. Repeat the following at most p(Œª)4 times:
(a) Prepare the state


œàP ‚àó
Œª,r
E
using a copy of P ‚àó‚Äôs auxiliary advice.
(b) Apply the projective measurement
n
Œ†P ‚àó
Œª,r,0, I ‚àíŒ†P ‚àó
Œª,r,0
o
, which is eÔ¨Écient due to property
1 of the commit-challenge-response protocol.
(c) If the Ô¨Årst outcome is observed, output the resulting state. Otherwise, repeat.
3. If b
P ‚àóhas not terminated, output a dummy state |œÜ‚ü©such that ‚ü®œÜ| Œ†P ‚àó
Œª,r,0 |œÜ‚ü©= 1.
64


Let


œà b
P ‚àó
Œª,r
E
be the state that results from the above procedure. Finally, let b
P ‚àóact identically to
P ‚àóafter this point.
Next, let Rterm,Œª :=
n
r :
D
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
E
> 1/p(Œª)2o
, and note that for any r ‚ààRterm,Œª,
Pr
Ô£Æ
Ô£∞


œà
b
P ‚àó
Œª,r
E
Ã∏=
Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
E
‚à•Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
E
‚à•
Ô£π
Ô£ª‚â§
1 ‚àí1/p(Œª)2p(Œª)4
‚â§e‚àíp(Œª)2 = negl(Œª).
Now, on the one hand,
1
|R|
X
r‚ààRterm,Œª
D
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0Œ†P ‚àó
Œª,r,1Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
E
‚â§1
|R|
X
r‚ààRterm,Œª
D
œà
b
P ‚àó
Œª,r


 Œ†
b
P ‚àó
Œª,r,1


œà
b
P ‚àó
Œª,r
E
+ negl(Œª)
‚â§E
r
hD
œà
b
P ‚àó
Œª,r


 Œ†
b
P ‚àó
Œª,r,1


œà
b
P ‚àó
Œª,r
Ei
+ negl(Œª)
‚â§negl(Œª),
where the third inequality follows from property 2 of the commit-challenge-response protocol,
since by deÔ¨Ånition Er
hD
œà b
P ‚àó
Œª,r


 Œ† b
P ‚àó
Œª,r,0


œà b
P ‚àó
Œª,r
Ei
= 1. On the other hand,
1
|R|
X
r‚ààRterm,Œª
D
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0Œ†P ‚àó
Œª,r,1Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
E
= E
r
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0Œ†P ‚àó
Œª,r,1Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
Ei
‚àí1
|R|
X
r/
‚ààRterm,Œª
D
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,0Œ†P ‚àó
Œª,r,1Œ†P ‚àó
Œª,r,0


œàP ‚àó
Œª,r
E
‚â•1/p(Œª) ‚àí1/p(Œª)2,
which is a contradiction, completing the proof.
Theorem A.2 ([ACGH20]). Consider the Œª-fold parallel repetition of any commit-challenge-
response protocol with computationally orthogonal projectors. The probability that the veriÔ¨Åer
accepts all Œª parallel repetitions of the protocol is negl(Œª).
Proof. Let R be the randomness space of the single repetition protocol, and r = (r1, . . . , rŒª) ‚ààR‚äóŒª
be veriÔ¨Åer randomness for the Œª-fold parallel repetition. Now, any non-uniform prover P ‚àócan be
described by states
n

œàP ‚àó
Œª,r
Eo
Œª,r and families of unitaries
n
U P ‚àó
Œª,c
o
Œª,c, where c ‚àà{0, 1}Œª ranges over
all of the veriÔ¨Åer challenges.
For each c ‚àà{0, 1}Œª, deÔ¨Åne
Œ†P ‚àó
Œª,r,c := U P ‚àó
Œª,c
‚Ä† (VŒª,r1,c1 ‚äó¬∑ ¬∑ ¬∑ ‚äóVŒª,rŒª,cŒª) U P ‚àó
Œª,c.
Claim A.3. For any c1 Ã∏= c2 ‚àà{0, 1}Œª,
E
r
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,c2Œ†P ‚àó
Œª,r,c1 + Œ†P ‚àó
Œª,r,c1Œ†P ‚àó
Œª,r,c2


œàP ‚àó
Œª,r
Ei
= negl(Œª).
65


Proof. Suppose there exists i ‚àà[Œª] such that (c1)i = 1 and (c2)i = 0 (the other case is symmetric).
Since for any quantum state |œà‚ü©and two projectors Œ†1, Œ†2,
‚ü®œà| Œ†2Œ†1 + Œ†1Œ†2 |œà‚ü©‚â§2| ‚ü®œà| Œ†2Œ†1 |œà‚ü©| ‚â§2 ‚ü®œà| Œ†2Œ†1Œ†2 |œà‚ü©1/2 ,
it then suÔ¨Éces (by Jensen‚Äôs inequality) to show that
E
r
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,c2Œ†P ‚àó
Œª,r,c1Œ†P ‚àó
Œª,r,c2


œàP ‚àó
Œª,r
Ei
= negl(Œª).
To see this, let
V (i)
Œª,ri,b := I ‚äó¬∑ ¬∑ ¬∑ ‚äóI ‚äóVŒª,ri,b ‚äóI ‚äó¬∑ ¬∑ ¬∑ ‚äóI,
for i ‚àà[Œª], b ‚àà{0, 1}, and observe that
E
r
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,r,c2Œ†P ‚àó
Œª,r,c1Œ†P ‚àó
Œª,r,c2


œàP ‚àó
Œª,r
Ei
‚â§E
r
hD
œàP ‚àó
Œª,r


 U P ‚àó
Œª,c2
‚Ä†V (i)
Œª,ri,0U P ‚àó
Œª,c2U P ‚àó
Œª,c1
‚Ä†V (i)
Œª,ri,1U P ‚àó
Œª,c1U P ‚àó
Œª,c2
‚Ä†V (i)
Œª,ri,0U P ‚àó
Œª,c2


œàP ‚àó
Œª,r
Ei
= E
ri
hD
b
œàP ‚àó
Œª,ri


 U P ‚àó
Œª,c2
‚Ä†V (i)
Œª,ri,0U P ‚àó
Œª,c2U P ‚àó
Œª,c1
‚Ä†V (i)
Œª,ri,1U P ‚àó
Œª,c1U P ‚àó
Œª,c2
‚Ä†V (i)
Œª,ri,0U P ‚àó
Œª,c2


 b
œàP ‚àó
Œª,ri
Ei
=negl(Œª),
where for each ri ‚ààR,


 b
œàP ‚àó
Œª,ri
E
is the puriÔ¨Åcation of the mixed state (written in ensemble form)

1
|R|Œª‚àí1 ,


œàP ‚àó
Œª,(r1,...,rŒª)
E
(r1,...,ri‚àí1,ri+1,...,rŒª)‚ààR‚äóŒª‚àí1 ,
and the Ô¨Ånal equality follows from the computational orthogonal projectors property of the commit-
challenge-response protocol. Indeed, one can deÔ¨Åne an eÔ¨Écient prover P ‚àó
i for the i‚Äôth iteration of
the commit-challenge-response protocol by deÔ¨Åning U P ‚àó
i
Œª,0 := U P ‚àó
Œª,c2 and U P ‚àó
i
Œª,1 := U P ‚àó
Œª,c1 and noting that


 b
œàP ‚àó
Œª,ri
E
is eÔ¨Écient to prepare while interacting with the i‚Äôth iteration of V, by running P ‚àóand Œª‚àí1
coherently executed copies of V.
Now observe that the probability the veriÔ¨Åer accepts the parallel repeated protocol is
66


1
2Œª E
r
Ô£Æ
Ô£∞
D
œàP ‚àó
Œª,r



X
c‚àà{0,1}Œª
Œ†P ‚àó
Œª,c,r


œàP ‚àó
Œª,r
E
Ô£π
Ô£ª
‚â§1
2Œª E
r
Ô£Æ
Ô£Ø
Ô£∞
Ô£´
Ô£≠
D
œàP ‚àó
Œª,r



Ô£´
Ô£≠
X
c‚àà{0,1}Œª
Œ†P ‚àó
Œª,c,r
Ô£∂
Ô£∏
2 

œàP ‚àó
Œª,r
E
Ô£∂
Ô£∏
1/2Ô£π
Ô£∫
Ô£ª
‚â§1
2Œª E
r
Ô£Æ
Ô£Ø
Ô£∞
Ô£´
Ô£≠
X
c‚àà{0,1}Œª
D
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,c,r


œàP ‚àó
Œª,r
E
Ô£∂
Ô£∏
1/2Ô£π
Ô£∫
Ô£ª
+ 1
2Œª
Ô£´
Ô£≠
X
{c1,c2}‚àà({0,1}Œª)2
E
r
hD
œàP ‚àó
Œª,r


 Œ†P ‚àó
Œª,c2,rŒ†P ‚àó
Œª,c1,r + Œ†P ‚àó
Œª,c1,rŒ†P ‚àó
Œª,c2,r


œàP ‚àó
Œª,r
Ei
Ô£∂
Ô£∏
1/2
‚â§1
2Œª/2 + 1
2Œª
Ô£´
Ô£≠
X
{c1,c2}‚àà({0,1}Œª)2
negl(Œª)
Ô£∂
Ô£∏
1/2
= negl(Œª),
where the Ô¨Årst inequality holds because


œàP ‚àó
Œª,r
E D
œàP ‚àó
Œª,r


 ‚™ØI, the second inequality uses Jensen‚Äôs
inequality and the fact that projectors are idempotent, and the third inequality follows from
Claim A.3.
B
Proof of Claim 6.4
We now prove Claim 6.4, which is restated below for convenience.
Claim B.1. For all (u, v) ‚àà{0, 1}R √ó {0, 1}S it holds that
Tr
Œ†œÉx
u Œ†œÉz
v œÑ

=
E
u‚Ä≤‚àà{0,1}R ‚ü®œà| Œ†Z
v Z(u‚Ä≤)Œ†X
u‚Ä≤‚äïuZ(u‚Ä≤)Œ†Z
v |œà‚ü©.
(7)
Proof. Using the deÔ¨Ånition of œÑ, we get
Tr(Œ†œÉx
u Œ†œÉz
v œÑ) = 2‚àí2N
X
r‚Ä≤,s‚Ä≤,r‚Ä≤‚Ä≤,s‚Ä≤‚Ä≤‚àà{0,1}N

‚ü®œà| Z(s‚Ä≤)X(r‚Ä≤ ‚äïr‚Ä≤‚Ä≤)Z(s‚Ä≤‚Ä≤) |œà‚ü©H

œÜ+
‚äóN œÉz(s‚Ä≤)œÉx(r‚Ä≤ ‚äïr‚Ä≤‚Ä≤)œÉz(s‚Ä≤‚Ä≤)

A1 ‚äó(Œ†œÉx
u Œ†œÉz
v )A2

œÜ+‚äóN 
= 2‚àí2N
X
r‚Ä≤,s‚Ä≤,r‚Ä≤‚Ä≤,s‚Ä≤‚Ä≤‚àà{0,1}N
(‚àí1)(r‚Ä≤‚äïr‚Ä≤‚Ä≤)¬∑s‚Ä≤‚Ä≤
‚ü®œà| Z(s‚Ä≤)X(r‚Ä≤ ‚äïr‚Ä≤‚Ä≤)Z(s‚Ä≤‚Ä≤) |œà‚ü©H

œÜ+
‚äóN œÉz(s‚Ä≤ ‚äïs‚Ä≤‚Ä≤)œÉx(r‚Ä≤ ‚äïr‚Ä≤‚Ä≤)

A1 ‚äó(Œ†œÉx
u Œ†œÉz
v )A2

œÜ+‚äóN 
.
(8)
However, most of the terms in Eq. (8) are zero: observe that when (r‚Ä≤ ‚äïr‚Ä≤‚Ä≤)j Ã∏= 0 for any j ‚ààS, or
(s‚Ä≤ ‚äïs‚Ä≤‚Ä≤)j Ã∏= 0 for any j ‚ààR, we have

œÜ+
‚äóN œÉz(s‚Ä≤ ‚äïs‚Ä≤‚Ä≤)œÉx(r‚Ä≤ ‚äïr‚Ä≤‚Ä≤)

A1 ‚äó(œÉx(u)œÉz(v))A2

œÜ+‚äóN = 0.
67


We can therefore rewrite Eq. (8) using the following change of variables:
‚Ä¢ Since s‚Ä≤ ‚äïs‚Ä≤‚Ä≤ must be 0 on R, the restriction of s‚Ä≤ and s‚Ä≤‚Ä≤ to R must be the same vector
u‚Ä≤ ‚àà{0, 1}R. Let the restriction of s‚Ä≤ and s‚Ä≤‚Ä≤ to indices in S be v‚Ä≤, v‚Ä≤‚Ä≤ ‚àà{0, 1}S respectively.
‚Ä¢ Since r‚Ä≤ ‚äïr‚Ä≤‚Ä≤ must be 0 on S, let u‚Ä≤‚Ä≤ ‚àà{0, 1}R denote the restriction of r‚Ä≤ ‚äïr‚Ä≤‚Ä≤ to indices in
R. Note that for each u‚Ä≤‚Ä≤, there are 2N choices of (r‚Ä≤, r‚Ä≤‚Ä≤) satisfying u‚Ä≤‚Ä≤ = r‚Ä≤ ‚äïr‚Ä≤‚Ä≤.
By a straightforward calculation, we have for all u‚Ä≤‚Ä≤ ‚àà{0, 1}R and all s‚Ä≤, s‚Ä≤‚Ä≤ ‚àà{0, 1}N that
X
r‚Ä≤,r‚Ä≤‚Ä≤‚àà{0,1}N
(r‚Ä≤‚äïr‚Ä≤‚Ä≤)=u‚Ä≤‚Ä≤

œÜ+
‚äóN œÉz(s‚Ä≤ ‚äïs‚Ä≤‚Ä≤)œÉx(r‚Ä≤ ‚äïr‚Ä≤‚Ä≤)

A1 ‚äó(Œ†œÉx
u Œ†œÉz
v )A2

œÜ+‚äóN = (‚àí1)u‚Ä≤‚Ä≤¬∑u+(s‚Ä≤‚äïs‚Ä≤‚Ä≤)v.
Plugging this into Eq. (8), and using the fact that (‚àí1)(s‚Ä≤‚äïs‚Ä≤‚Ä≤)v = (‚àí1)(v‚Ä≤‚äïv‚Ä≤‚Ä≤)v, we obtain
Tr(Œ†œÉx
u Œ†œÉz
v œÑ) = 2‚àí2N
X
u‚Ä≤,u‚Ä≤‚Ä≤‚àà{0,1}R
v‚Ä≤,v‚Ä≤‚Ä≤‚àà{0,1}S
(‚àí1)(u‚äïu‚Ä≤)¬∑u‚Ä≤‚Ä≤+(v‚Ä≤‚äïv‚Ä≤‚Ä≤)v
‚ü®œà| Z(v‚Ä≤)Z(u‚Ä≤)X(u‚Ä≤‚Ä≤)Z(u‚Ä≤)Z(v‚Ä≤‚Ä≤) |œà‚ü©H

=
E
u‚Ä≤‚àà{0,1}R ‚ü®œà| Œ†Z
v Z(u‚Ä≤)Œ†X
u‚äïu‚Ä≤Z(u‚Ä≤)Œ†Z
v |œà‚ü©
where the second equality follows from plugging in the deÔ¨Ånitions of Œ†Z
v and Œ†X
u‚äïu‚Ä≤.
C
Proof of Claim 6.7
We now prove Claim 6.7, which we restate below for convenience.
Claim C.1. Let k = k(Œª) be a positive integer-valued function of a security parameter Œª.
Let {D0,Œª}Œª‚â•1 and {D1,Œª}Œª‚â•1 be families of distributions on {0, 1}k+1 such that the marginal
distributions D‚Ä≤
0,Œª and D‚Ä≤
1,Œª of D0,Œª and D1,Œª respectively on the Ô¨Årst k bits are computationally
indistinguishable. Suppose that D0,Œª and D1,Œª are computationally distinguishable. Then there
is an eÔ¨Éciently computable binary-outcome POVM {M, Id ‚àíM} acting on k qubits such that



E
x‚àºD0,Œª(‚àí1)xk+1 ‚ü®x‚â§k| M |x‚â§k‚ü©‚àí
E
x‚àºD1,Œª(‚àí1)xk+1 ‚ü®x‚â§k| M |x‚â§k‚ü©


 >
1
poly(Œª).
Proof. By assumption there exists an eÔ¨Écient distinguisher between D0 and D1 (for simplicity we
omit the index Œª from the notation). Let A be a circuit for the distinguisher: A has (k + 1) input
qubits as well as m ancilla qubits, and a designated output qubit. Let Œ†1 be the projection on the
output qubit being equal to 1. Suppose without loss of generality that
E
x‚àºD0 ‚ü®x, 0m| A‚Ä†Œ†1A |x, 0m‚ü©>
E
x‚àºD1 ‚ü®x, 0m| A‚Ä†Œ†1A |x, 0m‚ü©+ 1
q ,
(9)
for some polynomial q = q(Œª). Letting |b‚ü©k+1 denote the (k + 1)-st qubit, we can write
E
x‚àºD1 ‚ü®x, 0m| A‚Ä†Œ†1A |x, 0m‚ü©=
E
x‚àºD1 xk+1 ‚ü®x‚â§k, 0m| ‚ü®1|k+1 A‚Ä†Œ†1A |1‚ü©k+1 |x‚â§k, 0m‚ü©
+
E
x‚àºD1(1 ‚àíxk+1) ‚ü®x‚â§k, 0m| ‚ü®0|k+1 A‚Ä†Œ†1A |0‚ü©k+1 |x‚â§k, 0m‚ü©.
68


Let Mb := ‚ü®b, 0m| A‚Ä†Œ†1A |b, 0m‚ü©(where b corresponds to the (k + 1)-st qubit); note that Mb is a
positive semi-deÔ¨Åne. We can rewrite the right-hand-side as
E
x‚àºD1 xk+1 ‚ü®x‚â§k| (M1 ‚àíM0) |x‚â§k‚ü©+
E
x‚àºD1 ‚ü®x‚â§k| M0 |x‚â§k‚ü©.
(10)
Using a similar expansion while taking the expectation under D0 yields
E
x‚àºD0 xk+1 ‚ü®x‚â§k| (M1 ‚àíM0) |x‚â§k‚ü©+
E
x‚àºD0 ‚ü®x‚â§k| M0 |x‚â§k‚ü©.
(11)
Plugging Eqs. (10) and (11) into Eq. (9) gives
E
x‚àºD0 xk+1 ‚ü®x‚â§k| (M1 ‚àíM0) |x‚â§k‚ü©‚àí
E
x‚àºD1 xk+1 ‚ü®x‚â§k| (M1 ‚àíM0) |x‚â§k‚ü©
>
E
x‚àºD1 ‚ü®x‚â§k| M0 |x‚â§k‚ü©‚àí
E
x‚àºD0 ‚ü®x‚â§k| M0 |x‚â§k‚ü©+ 1
q .
For b ‚àà{0, 1}, note that {Mb, Id‚àíMb} is an eÔ¨Éciently computable POVM since it can be performed
by initializing the (k + 1)-st qubit to |b‚ü©, the ancilla qubits to |0m‚ü©, applying A, and measuring
whether the output qubit is 1. Since D‚Ä≤
0 and D‚Ä≤
1 are computationally indistinguishable, we have
E
x‚àºD0 xk+1 ‚ü®x‚â§k, 0m| (M1 ‚àíM0) |x‚â§k, 0m‚ü©‚àí
E
x‚àºD1 xk+1 ‚ü®x‚â§k, 0m| (M1 ‚àíM0) |x‚â§k, 0m‚ü©
> 1
q ‚àínegl(Œª).
We observe that there must exist b ‚àà{0, 1} such that when M = Mb, we have



E
x‚àºD0 xk+1 ‚ü®x‚â§k, 0m| M |x‚â§k, 0m‚ü©‚àí
E
x‚àºD1 xk+1 ‚ü®x‚â§k, 0m| M |x‚â§k, 0m‚ü©



>
1
poly(Œª).
Finally, by plugging in the identity (‚àí1)b = 1 ‚àí2b for b ‚àà{0, 1} and appealing once again to the
indistinguishability of D‚Ä≤
0 and D‚Ä≤
1, we conclude that



E
x‚àºD0(‚àí1)xk+1 ‚ü®x‚â§k, 0m| M |x‚â§k, 0m‚ü©‚àí
E
x‚àºD1(‚àí1)xk+1 ‚ü®x‚â§k, 0m| M |x‚â§k, 0m‚ü©



>
1
poly(Œª).
69